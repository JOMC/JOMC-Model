<?xml version="1.0" encoding="UTF-8"?>
<!--

  Copyright (C) Christian Schulte <cs@schulte.it>, 2005-206
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    o Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    o Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.

  THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  $JOMC$

-->
<jaxb:bindings xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc"
               xmlns:jaxb="http://java.sun.com/xml/ns/jaxb"
               xmlns:xs="http://www.w3.org/2001/XMLSchema"
               xmlns:jomc="http://jomc.org/model"
               xmlns:ci="http://jaxb.dev.java.net/plugin/code-injector"
               xmlns:inheritance="http://jaxb2-commons.dev.java.net/basic/inheritance"
               version="2.0">

  <jaxb:bindings schemaLocation="jomc-1.2.xsd">
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Text']/xs:simpleContent/xs:extension/xs:attribute[@name='language']">
      <jaxb:property>
        <jaxb:javadoc>The language key of this text.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Text']/xs:simpleContent/xs:extension/xs:attribute[@name='type']">
      <jaxb:property>
        <jaxb:javadoc>The Multipurpose Internet Mail Extension (MIME) type, as defined in RFC 2045 and 2046.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Texts']">
      <ci:code><![CDATA[
    /**
     * Gets a text for a given language from the list of texts.
     *
     * @param language The language of the text to return.
     *
     * @return The first matching text or the default text, if no such text is found.
     *
     * @throws NullPointerException if {@code language} is {@code null}.
     *
     * @see #getText()
     * @see #getDefaultLanguage()
     * @see Text#getLanguage()
     */
    public Text getText( final String language )
    {
        if ( language == null )
        {
            throw new NullPointerException( "language" );
        }

        Text defaultText = null;

        for ( int i = 0, s0 = this.getText().size(); i < s0; i++ )
        {
            final Text t = this.getText().get( i );

            if ( t.getLanguage().equalsIgnoreCase( this.getDefaultLanguage() ) )
            {
                defaultText = t;
            }
            if ( t.getLanguage().equalsIgnoreCase( language ) )
            {
                return t;
            }
        }

        return defaultText;
    }

    /**
     * Gets a text for a given locale from the list of texts.
     *
     * @param locale The locale of the text to return.
     *
     * @return The first matching text or the default text, if no such text is found.
     *
     * @throws NullPointerException if {@code locale} is {@code null}.
     *
     * @see #getText()
     * @see #getDefaultLanguage()
     * @see Text#getLanguage()
     *
     * @since 1.4
     */
    public Text getText( final java.util.Locale locale )
    {
        if ( locale == null )
        {
            throw new NullPointerException( "locale" );
        }

        Text defaultText = null;

        for ( int i = 0, s0 = this.getText().size(); i < s0; i++ )
        {
            final Text t = this.getText().get( i );

            if ( t.getLanguage().equalsIgnoreCase( this.getDefaultLanguage() ) )
            {
                defaultText = t;
            }
            if ( t.getLanguage().equalsIgnoreCase( locale.getLanguage() ) )
            {
                return t;
            }
        }

        return defaultText;
    }]]>
      </ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Texts']/xs:attribute[@name='defaultLanguage']">
      <jaxb:property>
        <jaxb:javadoc>Default text of this list.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Text']">
      <ci:code><![CDATA[
    /**
     * Gets the mime-type of the text.
     *
     * @return The mime-type of the text.
     *
     * @throws ModelObjectException if compiling the type to a {@code MimeType} fails.
     *
     * @see #getType()
     *
     * @since 1.4
     */
    public javax.activation.MimeType getMimeType() throws ModelObjectException
    {
        try
        {
            return new javax.activation.MimeType( this.getType() );
        }
        catch ( final javax.activation.MimeTypeParseException e )
        {
            throw new ModelObjectException( getMessage( "mimeTypeParseException", this.getType(),
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Formats the text to a Javadoc comment.
     *
     * @param lineSeparator String to use for separating lines.
     * @param indentation String to prepend any lines with.
     *
     * @return The Javadoc comment of the text or {@code null}.
     *
     * @throws NullPointerException if {@code lineSeparator} or {@code indentation} is {@code null}.
     * @throws ModelObjectException if compiling the referenced type to a {@code MimeType} fails.
     *
     * @since 1.4
     */
    public String getJavadocComment( final String lineSeparator, final String indentation ) throws ModelObjectException
    {
        if ( lineSeparator == null )
        {
            throw new NullPointerException( "lineSeparator" );
        }
        if ( indentation == null )
        {
            throw new NullPointerException( "indentation" );
        }

        java.io.BufferedReader reader = null;

        try
        {
            String javadocComment = null;

            if ( this.getValue() != null )
            {
                reader = new java.io.BufferedReader( new java.io.StringReader( this.getValue() ) );
                final StringBuilder builder = new StringBuilder( this.getValue().length() );
                final boolean escapeHtml = !this.getMimeType().match( "text/html" );

                String line;
                while ( ( line = reader.readLine() ) != null )
                {
                    if ( escapeHtml )
                    {
                        builder.append( lineSeparator ).append( indentation ).append( " * " ).
                            append( line.replace( "&", "&amp;" ).replace( "<", "&lt;" ).replace( ">", "&gt;" ).
                            replace( "\"", "&quot;" ).replace( "*", "&lowast;" ) );

                    }
                    else
                    {
                        builder.append( lineSeparator ).append( indentation ).append( " * " ).append( line );
                    }
                }

                if ( builder.length() > 0 )
                {
                    javadocComment =
                        builder.substring( lineSeparator.length() + indentation.length() + " * ".length() );

                }

                reader.close();
                reader = null;
            }

            return javadocComment;
        }
        catch ( final javax.activation.MimeTypeParseException e )
        {
            throw new AssertionError( e );
        }
        catch ( final java.io.IOException e )
        {
            throw new AssertionError( e );
        }
        finally
        {
            try
            {
                if ( reader != null )
                {
                    reader.close();
                }
            }
            catch ( final java.io.IOException e )
            {
                throw new AssertionError( e );
            }
        }
    }

    private static String getMessage( final Throwable t )
    {
        return t != null
               ? t.getMessage() != null && t.getMessage().trim().length() > 0
                 ? t.getMessage()
                 : getMessage( t.getCause() )
               : null;

    }

    private static String getMessage( final String key, final Object... arguments )
    {
        return java.text.MessageFormat.format( java.util.ResourceBundle.getBundle(
            Text.class.getName().replace( '.', '/' ), java.util.Locale.getDefault() ).
            getString( key ), arguments );

    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='ModelObject']/xs:sequence/xs:element[@ref='jomc:documentation']">
      <jaxb:property>
        <jaxb:javadoc>Documentation of this object or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ModelObject']/xs:sequence/xs:element[@ref='jomc:authors']">
      <jaxb:property>
        <jaxb:javadoc>Authors of this object or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ModelObject']/xs:attribute[@name='modelVersion']">
      <jaxb:property>
        <jaxb:javadoc>Model version of this object.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ModelObject']/xs:attribute[@name='createDate']">
      <jaxb:property>
        <jaxb:javadoc>The date this object got created or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ModelObject']/xs:attribute[@name='deprecated']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this object is deprecated.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ModelObject']">
      <ci:code><![CDATA[
    /** Public identifier of the object management and configuration model. */
    public static final String MODEL_PUBLIC_ID = "http://jomc.org/model";

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from a given list of objects.
     *
     * @param any The list to search.
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} list or
     * {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code any}, {@code namespaceURI}, {@code localPart} or {@code type} is
     * {@code null}.
     * @throws IllegalStateException if {@code any} contains more than one matching element.
     *
     * @since 1.1
     */
    protected <T> javax.xml.bind.JAXBElement<T> getAnyElement( final java.util.List<Object> any,
                                                               final String namespaceURI,
                                                               final String localPart,
                                                               final Class<T> type )
    {
        if ( any == null )
        {
            throw new NullPointerException( "any" );
        }
        if ( namespaceURI == null )
        {
            throw new NullPointerException( "namespaceURI" );
        }
        if ( localPart == null )
        {
            throw new NullPointerException( "localPart" );
        }
        if ( type == null )
        {
            throw new NullPointerException( "type" );
        }

        javax.xml.bind.JAXBElement<?> anyElement = null;

        for ( int i = 0, s0 = any.size(); i < s0; i++ )
        {
            final Object o = any.get( i );

            if ( o instanceof javax.xml.bind.JAXBElement<?> )
            {
                final javax.xml.bind.JAXBElement<?> e = (javax.xml.bind.JAXBElement<?>) o;

                if ( namespaceURI.equals( e.getName().getNamespaceURI() )
                     && localPart.equals( e.getName().getLocalPart() ) )
                {
                    if ( anyElement == null )
                    {
                        anyElement = e;
                    }
                    else
                    {
                        throw new IllegalStateException( getMessage( "nonUniqueElement", this.getClass().getName(),
                                                                     namespaceURI, localPart ) );

                    }
                }
            }
        }

        if ( anyElement != null && anyElement.getValue() != null && anyElement.getValue().getClass().equals( type ) )
        {
            @SuppressWarnings( "unchecked" ) final javax.xml.bind.JAXBElement<T> e =
                (javax.xml.bind.JAXBElement<T>) anyElement;

            return e;
        }

        return null;
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from a given list of
     * objects.
     *
     * @param any The list to search.
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} list - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code any}, {@code namespaceURI}, {@code localPart} or {@code type} is
     * {@code null}.
     *
     * @since 1.1
     */
    protected <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final java.util.List<Object> any,
                                                                                final String namespaceURI,
                                                                                final String localPart,
                                                                                final Class<T> type )
    {
        if ( any == null )
        {
            throw new NullPointerException( "any" );
        }
        if ( namespaceURI == null )
        {
            throw new NullPointerException( "namespaceURI" );
        }
        if ( localPart == null )
        {
            throw new NullPointerException( "localPart" );
        }
        if ( type == null )
        {
            throw new NullPointerException( "type" );
        }

        final java.util.List<javax.xml.bind.JAXBElement<T>> anyElements =
            new java.util.ArrayList<javax.xml.bind.JAXBElement<T>>( any.size() );

        for ( int i = 0, s0 = any.size(); i < s0; i++ )
        {
            final Object o = any.get( i );

            if ( o instanceof javax.xml.bind.JAXBElement<?> )
            {
                final javax.xml.bind.JAXBElement<?> e = (javax.xml.bind.JAXBElement<?>) o;

                if ( namespaceURI.equals( e.getName().getNamespaceURI() )
                     && localPart.equals( e.getName().getLocalPart() )
                     && e.getValue() != null && e.getValue().getClass().equals( type ) )
                {
                    @SuppressWarnings( "unchecked" ) final javax.xml.bind.JAXBElement<T> anyElement =
                        (javax.xml.bind.JAXBElement<T>) e;

                    anyElements.add( anyElement );
                }
            }
        }

        return java.util.Collections.unmodifiableList( anyElements );
    }

    /**
     * Gets a single object matching a class from a given list of objects.
     *
     * @param any The list to search.
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} list or {@code null}, if no such instance is found.
     *
     * @throws NullPointerException if {@code any} or {@code clazz} is {@code null}.
     * @throws IllegalStateException if {@code any} contains more than one matching object.
     */
    protected <T> T getAnyObject( final java.util.List<Object> any, final Class<T> clazz )
    {
        if ( any == null )
        {
            throw new NullPointerException( "any" );
        }
        if ( clazz == null )
        {
            throw new NullPointerException( "clazz" );
        }

        T anyObject = null;

        for ( int i = 0, s0 = any.size(); i < s0; i++ )
        {
            Object o = any.get( i );

            if ( o instanceof javax.xml.bind.JAXBElement<?> )
            {
                o = ( (javax.xml.bind.JAXBElement<?>) o ).getValue();
            }

            if ( clazz.equals( o.getClass() ) )
            {
                if ( anyObject == null )
                {
                    @SuppressWarnings( "unchecked" ) final T object = (T) o;
                    anyObject = object;
                }
                else
                {
                    throw new IllegalStateException( getMessage( "nonUniqueObject", this.getClass().getName(),
                                                                 clazz.getName() ) );

                }
            }
        }

        return anyObject;
    }

    /**
     * Gets a list containing all objects matching a class from a given list of objects.
     *
     * @param any The list to search.
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} list - an empty list if no
     * such objects are found.
     *
     * @throws NullPointerException if {@code any} or {@code clazz} is {@code null}.
     */
    protected <T> java.util.List<T> getAnyObjects( final java.util.List<Object> any, final Class<T> clazz )
    {
        if ( any == null )
        {
            throw new NullPointerException( "any" );
        }
        if ( clazz == null )
        {
            throw new NullPointerException( "namespaceURI" );
        }

        final java.util.List<T> anyElements = new java.util.ArrayList<T>( any.size() );

        for ( int i = 0, s0 = any.size(); i < s0; i++ )
        {
            Object o = any.get( i );

            if ( o instanceof javax.xml.bind.JAXBElement<?> )
            {
                o = ( (javax.xml.bind.JAXBElement<?>) o ).getValue();
            }

            if ( clazz.equals( o.getClass() ) )
            {
                @SuppressWarnings( "unchecked" ) final T object = (T) o;
                anyElements.add( object );
            }
        }

        return java.util.Collections.unmodifiableList( anyElements );
    }

    private static String getMessage( final String key, final Object... args )
    {
        return java.text.MessageFormat.format( java.util.ResourceBundle.getBundle(
            ModelObject.class.getName().replace( '.', '/' ), java.util.Locale.getDefault() ).
            getString( key ), args );

    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:specifications']">
      <jaxb:property>
        <jaxb:javadoc>Specifications of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:implementations']">
      <jaxb:property>
        <jaxb:javadoc>Implementations of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:properties']">
      <jaxb:property>
        <jaxb:javadoc>Properties of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:messages']">
      <jaxb:property>
        <jaxb:javadoc>Messages of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>Name of this module.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>Version of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:attribute[@name='vendor']">
      <jaxb:property>
        <jaxb:javadoc>Vendor of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']">
      <ci:code><![CDATA[
    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null}, if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> javax.xml.bind.JAXBElement<T> getAnyElement( final String namespaceURI, final String localPart,
                                                            final Class<T> type )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final String namespaceURI,
                                                                             final String localPart,
                                                                             final Class<T> type )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a single object matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} property of the instance or {@code null}, if no such
     * instance is found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching object.
     *
     * @see #getAnyObject(java.util.List, java.lang.Class)
     */
    public <T> T getAnyObject( final Class<T> clazz )
    {
        return this.getAnyObject( this.getAny(), clazz );
    }

    /**
     * Gets a list containing all objects matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} property of the instance -
     * an empty list if no such objects are found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     *
     * @see #getAnyObjects(java.util.List, java.lang.Class)
     */
    public <T> java.util.List<T> getAnyObjects( final Class<T> clazz )
    {
        return this.getAnyObjects( this.getAny(), clazz );
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Specifications']">
      <ci:code><![CDATA[
    /**
     * Gets a specification for a given identifier from the list of specifications.
     *
     * @param specification The identifier of the specification to return.
     *
     * @return The first matching specification or {@code null}, if no such specification is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getSpecification()
     * @see Specification#getIdentifier()
     */
    public Specification getSpecification( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( int i = 0, s0 = this.getSpecification().size(); i < s0; i++ )
        {
            final Specification s = this.getSpecification().get( i );

            if ( specification.equals( s.getIdentifier() ) )
            {
                return s;
            }
        }

        return null;
    }

    /**
     * Gets a specification for a given class from the list of specifications.
     *
     * @param specification The class of the specification to return.
     *
     * @return The first matching specification declaring {@code specification} or {@code null}, if no such
     * specification is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     * @throws ModelObjectException if compiling the name of a referenced type to a {@code JavaTypeName} fails.
     *
     * @see #getSpecification()
     * @see Specification#isClassDeclaration()
     * @see Specification#getClazz()
     */
    public Specification getSpecification( final Class<?> specification ) throws ModelObjectException
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( int i = 0, s0 = this.getSpecification().size(); i < s0; i++ )
        {
            final Specification s = this.getSpecification().get( i );

            if ( s.isClassDeclaration() && s.getClazz() != null )
            {
                if ( specification.getName().equals( s.getJavaTypeName().getClassName() ) )
                {
                    return s;
                }
            }
        }

        return null;
    }

    /**
     * Gets a specification reference for a given identifier from the list of references.
     *
     * @param specification The identifier of the reference to return.
     *
     * @return The first matching specification reference or {@code null}, if no such specification reference is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getReference()
     * @see SpecificationReference#getIdentifier()
     */
    public SpecificationReference getReference( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( int i = 0, s0 = this.getReference().size(); i < s0; i++ )
        {
            final SpecificationReference r = this.getReference().get( i );

            if ( specification.equals( r.getIdentifier() ) )
            {
                return r;
            }
        }

        return null;
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:properties']">
      <jaxb:property>
        <jaxb:javadoc>Properties of this specification or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='identifier']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of this specification.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='class']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of the class providing the programming interface of this specification or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='vendor']">
      <jaxb:property>
        <jaxb:javadoc>The vendor of this specification or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>The version of this specification or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='multiplicity']">
      <jaxb:property>
        <jaxb:javadoc>The implementation multiplicity of this specification. A multiplicity equal to {@link Multiplicity#ONE} specifies that no more than one implementation of the specification is allowed to exist among a set of modules (including none). A multiplicity equal to {@link Multiplicity#MANY} specifies that many implementations are allowed to exist among a set of modules (including none).</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='scope']">
      <jaxb:property>
        <jaxb:javadoc>Scope instances of implementations of this specification apply to or {@code null}, if instances of implementations of this specification are not bound to any scope (multiton).</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='classDeclaration']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this specification declares the class given by property {@code clazz}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']">
      <ci:code><![CDATA[
    /**
     * Gets the Java class of the type referenced by the specification for a given class loader.
     *
     * @param classLoader The class loader to get the Java class from or {@code null}, to get the Java class from the
     * platform's bootstrap class loader.
     *
     * @return The Java class of the type referenced by the specification or {@code null}, if the specification does not
     * reference a type.
     *
     * @throws ClassNotFoundException if the Java class is not found.
     * @throws ModelObjectException if compiling the name of the referenced type to a {@code JavaTypeName} fails.
     *
     * @see #getClazz()
     * @see #getJavaTypeName()
     *
     * @since 1.2
     */
    public Class<?> getJavaClass( final ClassLoader classLoader )
        throws ClassNotFoundException, ModelObjectException
    {
        Class<?> javaClass = null;
        final org.jomc.jls.JavaTypeName javaTypeName = this.getJavaTypeName();

        if ( javaTypeName != null )
        {
            javaClass = javaTypeName.getClass( classLoader, false );
        }

        return javaClass;
    }

    /**
     * Gets the Java type name of the type referenced by the specification.
     *
     * @return The Java type name of the type referenced by the specification or {@code null}, if the specification does
     * not reference a type.
     *
     * @throws ModelObjectException if compiling the name of the referenced type to a {@code JavaTypeName} fails.
     *
     * @see #getClazz()
     *
     * @since 1.4
     */
    public org.jomc.jls.JavaTypeName getJavaTypeName() throws ModelObjectException
    {
        try
        {
            org.jomc.jls.JavaTypeName javaTypeName = null;

            if ( this.getClazz() != null )
            {
                javaTypeName = org.jomc.jls.JavaTypeName.parse( this.getClazz() );
            }

            return javaTypeName;
        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaTypeNameParseException", this.getClazz(),
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> javax.xml.bind.JAXBElement<T> getAnyElement( final String namespaceURI, final String localPart,
                                                            final Class<T> type )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final String namespaceURI,
                                                                             final String localPart,
                                                                             final Class<T> type )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a single object matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} property of the instance or {@code null}, if no such
     * instance is found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching object.
     *
     * @see #getAnyObject(java.util.List, java.lang.Class)
     */
    public <T> T getAnyObject( final Class<T> clazz )
    {
        return this.getAnyObject( this.getAny(), clazz );
    }

    /**
     * Gets a list containing all objects matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} property of the instance -
     * an empty list if no such objects are found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     *
     * @see #getAnyObjects(java.util.List, java.lang.Class)
     */
    public <T> java.util.List<T> getAnyObjects( final Class<T> clazz )
    {
        return this.getAnyObjects( this.getAny(), clazz );
    }

    private static String getMessage( final Throwable t )
    {
        return t != null
               ? t.getMessage() != null && t.getMessage().trim().length() > 0
                 ? t.getMessage()
                 : getMessage( t.getCause() )
               : null;

    }

    private static String getMessage( final String key, final Object... arguments )
    {
        return java.text.MessageFormat.format( java.util.ResourceBundle.getBundle(
            Specification.class.getName().replace( '.', '/' ), java.util.Locale.getDefault() ).
            getString( key ), arguments );

    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='SpecificationReference']/xs:complexContent/xs:extension/xs:attribute[@name='identifier']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of the referenced specification.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='SpecificationReference']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>The version of the referenced specification or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='SpecificationReference']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this specification reference is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='SpecificationReference']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this specification reference is intended to override a super specification reference.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='SpecificationReference']">
      <inheritance:implements>org.jomc.model.Inheritable</inheritance:implements>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Implementations']">
      <ci:code><![CDATA[
    /**
     * Gets an implementation for a given identifier from the list of implementations.
     *
     * @param implementation The identifier of the implementation to return.
     *
     * @return The first matching implementation or {@code null}, if no such implementation is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getImplementation()
     * @see Implementation#getIdentifier()
     */
    public Implementation getImplementation( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( int i = 0, s0 = this.getImplementation().size(); i < s0; i++ )
        {
            final Implementation current = this.getImplementation().get( i );

            if ( implementation.equals( current.getIdentifier() ) )
            {
                return current;
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given class from the list of implementations.
     *
     * @param implementation The class of the implementation to return.
     *
     * @return The first matching implementation declaring {@code implementation} or {@code null}, if no such
     * implementation is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     * @throws ModelObjectException if compiling the name of a referenced type to a {@code JavaTypeName} fails.
     *
     * @see #getImplementation()
     * @see Implementation#isClassDeclaration()
     * @see Implementation#getClazz()
     */
    public Implementation getImplementation( final Class<?> implementation ) throws ModelObjectException
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( int i = 0, s0 = this.getImplementation().size(); i < s0; i++ )
        {
            final Implementation current = this.getImplementation().get( i );

            if ( current.isClassDeclaration() && current.getClazz() != null )
            {
                if ( implementation.getName().equals( current.getJavaTypeName().getClassName() ) )
                {
                    return current;
                }
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given name from the list of implementations.
     *
     * @param name The name of the implementation to return.
     *
     * @return The first matching implementation or {@code null}, if no such implementation is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getImplementation()
     * @see Implementation#getName()
     */
    public Implementation getImplementationByName( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( int i = 0, s0 = this.getImplementation().size(); i < s0; i++ )
        {
            final Implementation current = this.getImplementation().get( i );

            if ( name.equals( current.getName() ) )
            {
                return current;
            }
        }

        return null;
    }

    /**
     * Gets an implementation reference for a given identifier from the list of references.
     *
     * @param implementation The identifier of the reference to return.
     *
     * @return The first matching implementation reference or {@code null}, if no such reference is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getReference()
     * @see ImplementationReference#getIdentifier()
     */
    public ImplementationReference getReference( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( int i = 0, s0 = this.getReference().size(); i < s0; i++ )
        {
            final ImplementationReference r = this.getReference().get( i );

            if ( implementation.equals( r.getIdentifier() ) )
            {
                return r;
            }
        }

        return null;
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:specifications']">
      <jaxb:property>
        <jaxb:javadoc>References to specifications implemented by this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:implementations']">
      <jaxb:property>
        <jaxb:javadoc>References to implementations this implementation inherits from or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:dependencies']">
      <jaxb:property>
        <jaxb:javadoc>Dependencies of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:properties']">
      <jaxb:property>
        <jaxb:javadoc>Properties of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:messages']">
      <jaxb:property>
        <jaxb:javadoc>Messages of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='identifier']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of this implementation.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>The name of this implementation.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='class']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of the class providing instances of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='location']">
      <jaxb:property>
        <jaxb:javadoc>An URI of the location providing instances of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='vendor']">
      <jaxb:property>
        <jaxb:javadoc>The vendor of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>The version of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this implementation is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='stateless']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if instances of this implementation do not retain state across operations.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='abstract']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this implementation is abstract.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='classDeclaration']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this implementation declares the class given by property {@code clazz}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']">
      <ci:code><![CDATA[
    /**
     * Gets the Java class of the type referenced by the implementation for a given class loader.
     *
     * @param classLoader The class loader to get the Java class from or {@code null}, to get the Java class from the
     * platform's bootstrap class loader.
     *
     * @return The Java class of the type referenced by the implementation or {@code null}, if the implementation does
     * not reference a type.
     *
     * @throws ClassNotFoundException if the Java class is not found.
     * @throws ModelObjectException if compiling the name of the referenced type to a {@code JavaTypeName} fails.
     *
     * @see #getClazz()
     * @see #getJavaTypeName()
     *
     * @since 1.2
     */
    public Class<?> getJavaClass( final ClassLoader classLoader )
        throws ClassNotFoundException, ModelObjectException
    {
        Class<?> javaClass = null;
        final org.jomc.jls.JavaTypeName javaTypeName = this.getJavaTypeName();

        if ( javaTypeName != null )
        {
            javaClass = javaTypeName.getClass( classLoader, false );
        }

        return javaClass;
    }

    /**
     * Gets the Java type name of the type referenced by the implementation.
     *
     * @return The Java type name of the type referenced by the implementation or {@code null}, if the implementation
     * does not reference a type.
     *
     * @throws ModelObjectException if compiling the name of the referenced type to a {@code JavaTypeName} fails.
     *
     * @see #getClazz()
     *
     * @since 1.4
     */
    public org.jomc.jls.JavaTypeName getJavaTypeName() throws ModelObjectException
    {
        try
        {
            org.jomc.jls.JavaTypeName javaTypeName = null;

            if ( this.getClazz() != null )
            {
                javaTypeName = org.jomc.jls.JavaTypeName.parse( this.getClazz() );
            }

            return javaTypeName;
        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaTypeNameParseException", this.getClazz(),
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Gets the location URI used for locating instances of this implementation.
     *
     * @return The location URI used for locating instances of this implementation or {@code null}, if instances of this
     * implementation do not need to be located.
     *
     * @throws ModelObjectException if compiling the location to an {@code URI} object fails.
     *
     * @see #getLocation()
     */
    public java.net.URI getLocationUri() throws ModelObjectException
    {
        try
        {
            java.net.URI javaLocation = null;

            if ( this.getLocation() != null )
            {
                javaLocation = new java.net.URI( this.getLocation() );
            }

            return javaLocation;
        }
        catch ( final java.net.URISyntaxException e )
        {
            throw new ModelObjectException( getMessage( "uriSyntaxException", this.getLocation(),
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null}, if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> javax.xml.bind.JAXBElement<T> getAnyElement( final String namespaceURI, final String localPart,
                                                            final Class<T> type )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final String namespaceURI,
                                                                             final String localPart,
                                                                             final Class<T> type )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a single object matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} property of the instance or {@code null}, if no such
     * instance is found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching object.
     *
     * @see #getAnyObject(java.util.List, java.lang.Class)
     */
    public <T> T getAnyObject( final Class<T> clazz )
    {
        return this.getAnyObject( this.getAny(), clazz );
    }

    /**
     * Gets a list containing all objects matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} property of the instance -
     * an empty list if no such objects are found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     *
     * @see #getAnyObjects(java.util.List, java.lang.Class)
     */
    public <T> java.util.List<T> getAnyObjects( final Class<T> clazz )
    {
        return this.getAnyObjects( this.getAny(), clazz );
    }

    private static String getMessage( final Throwable t )
    {
        return t != null
               ? t.getMessage() != null && t.getMessage().trim().length() > 0
                 ? t.getMessage()
                 : getMessage( t.getCause() )
               : null;

    }

    private static String getMessage( final String key, final Object... arguments )
    {
        return java.text.MessageFormat.format( java.util.ResourceBundle.getBundle(
            Implementation.class.getName().replace( '.', '/' ), java.util.Locale.getDefault() ).
            getString( key ), arguments );

    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='ImplementationReference']/xs:complexContent/xs:extension/xs:attribute[@name='identifier']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of the referenced implementation.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ImplementationReference']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>The version of the referenced implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ImplementationReference']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this implementation reference is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ImplementationReference']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this implementation reference is intended to override a super implementation reference.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ImplementationReference']">
      <inheritance:implements>org.jomc.model.Inheritable</inheritance:implements>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Dependencies']">
      <ci:code><![CDATA[
    /**
     * Gets a dependency for a given name from the list of dependencies.
     *
     * @param name The name of the dependency to return.
     *
     * @return The first matching dependency or {@code null}, if no such dependency is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getDependency()
     * @see Dependency#getName()
     */
    public Dependency getDependency( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "identifier" );
        }

        for ( int i = 0, s0 = this.getDependency().size(); i < s0; i++ )
        {
            final Dependency d = this.getDependency().get( i );

            if ( name.equals( d.getName() ) )
            {
                return d;
            }
        }

        return null;
    }

    /**
     * Gets a list of dependencies referencing a given specification.
     *
     * @param specification The identifier of a specification referenced by the dependencies to return.
     *
     * @return An unmodifiable list holding all dependencies referencing {@code specification}.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getDependency()
     * @see Dependency#getIdentifier()
     *
     * @since 1.2
     */
    public List<Dependency> getDependenciesBySpecification( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        final List<Dependency> list = new ArrayList<Dependency>( this.getDependency().size() );

        for ( int i = 0, s0 = this.getDependency().size(); i < s0; i++ )
        {
            final Dependency d = this.getDependency().get( i );

            if ( specification.equals( d.getIdentifier() ) )
            {
                list.add( d );
            }
        }

        return java.util.Collections.unmodifiableList( list );
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:dependencies']">
      <jaxb:property>
        <jaxb:javadoc>Dependencies of this dependency or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:messages']">
      <jaxb:property>
        <jaxb:javadoc>Messages of this dependency or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:properties']">
      <jaxb:property>
        <jaxb:javadoc>Properties of this dependency or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:attribute[@name='implementationName']">
      <jaxb:property>
        <jaxb:javadoc>Name of the selected implementation of the specification of this dependency or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>Name of this dependency.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:attribute[@name='bound']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if instances of this dependency are bound to the declaring implementation.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:attribute[@name='optional']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this dependency is optional.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']">
      <ci:code><![CDATA[
    /**
     * Gets the Java getter method name of the dependency.
     *
     * @return The Java getter method name of the dependency.
     *
     * @throws ModelObjectException if compiling the name of the dependency to a {@code JavaIdentifier} fails.
     *
     * @since 1.4
     *
     * @see #getName()
     */
    public org.jomc.jls.JavaIdentifier getJavaGetterMethodName() throws ModelObjectException
    {
        try
        {
            return org.jomc.jls.JavaIdentifier.parse( "get" + org.jomc.jls.JavaIdentifier.normalize(
                this.getName() != null ? this.getName() : "",
                org.jomc.jls.JavaIdentifier.NormalizationMode.CAMEL_CASE ) );

        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaIdentifierParseException", this.getName(),
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Gets the Java setter method name of the dependency.
     *
     * @return The Java setter method name of the dependency.
     *
     * @throws ModelObjectException if compiling the name of the dependency to a {@code JavaIdentifier} fails.
     *
     * @since 1.4
     *
     * @see #getName()
     */
    public org.jomc.jls.JavaIdentifier getJavaSetterMethodName() throws ModelObjectException
    {
        try
        {
            return org.jomc.jls.JavaIdentifier.parse( "set" + org.jomc.jls.JavaIdentifier.normalize(
                this.getName() != null ? this.getName() : "",
                org.jomc.jls.JavaIdentifier.NormalizationMode.CAMEL_CASE ) );

        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaIdentifierParseException", this.getName(),
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Gets the Java variable name of the dependency.
     *
     * @return The Java variable name of the dependency.
     *
     * @throws ModelObjectException if compiling the name of the dependency to a {@code JavaIdentifier} fails.
     *
     * @since 1.4
     *
     * @see #getName()
     */
    public org.jomc.jls.JavaIdentifier getJavaVariableName() throws ModelObjectException
    {
        try
        {
            return org.jomc.jls.JavaIdentifier.normalize(
                this.getName() != null ? this.getName() : "",
                org.jomc.jls.JavaIdentifier.NormalizationMode.VARIABLE_NAME_CONVENTION );

        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaIdentifierParseException", this.getName(),
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Gets the Java constant name of the dependency.
     *
     * @return The Java constant name of the dependency.
     *
     * @throws ModelObjectException if compiling the name of the dependency to a {@code JavaIdentifier} fails.
     *
     * @since 1.4
     *
     * @see #getName()
     */
    public org.jomc.jls.JavaIdentifier getJavaConstantName() throws ModelObjectException
    {
        try
        {
            return org.jomc.jls.JavaIdentifier.normalize(
                this.getName() != null ? this.getName() : "",
                org.jomc.jls.JavaIdentifier.NormalizationMode.CONSTANT_NAME_CONVENTION );

        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaIdentifierParseException", this.getName(),
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null}, if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> javax.xml.bind.JAXBElement<T> getAnyElement( final String namespaceURI, final String localPart,
                                                            final Class<T> type )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final String namespaceURI,
                                                                             final String localPart,
                                                                             final Class<T> type )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a single object matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} property of the instance or {@code null}, if no such
     * instance is found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching object.
     *
     * @see #getAnyObject(java.util.List, java.lang.Class)
     */
    public <T> T getAnyObject( final Class<T> clazz )
    {
        return this.getAnyObject( this.getAny(), clazz );
    }

    /**
     * Gets a list containing all objects matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} property of the instance -
     * an empty list if no such objects are found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     *
     * @see #getAnyObjects(java.util.List, java.lang.Class)
     */
    public <T> java.util.List<T> getAnyObjects( final Class<T> clazz )
    {
        return this.getAnyObjects( this.getAny(), clazz );
    }

    private static String getMessage( final Throwable t )
    {
        return t != null
               ? t.getMessage() != null && t.getMessage().trim().length() > 0
                 ? t.getMessage()
                 : getMessage( t.getCause() )
               : null;

    }

    private static String getMessage( final String key, final Object... arguments )
    {
        return java.text.MessageFormat.format( java.util.ResourceBundle.getBundle(
            Dependency.class.getName().replace( '.', '/' ), java.util.Locale.getDefault() ).
            getString( key ), arguments );

    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Properties']">
      <ci:code><![CDATA[
    /**
     * Gets a property for a given name from the list of properties.
     *
     * @param name The name of the property to return.
     *
     * @return The first matching property or {@code null}, if no such property is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getProperty()
     * @see Property#getName()
     */
    public Property getProperty( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( int i = 0, s0 = this.getProperty().size(); i < s0; i++ )
        {
            final Property p = this.getProperty().get( i );

            if ( name.equals( p.getName() ) )
            {
                return p;
            }
        }

        return null;
    }

    /**
     * Gets a property reference for a given name from the list of references.
     *
     * @param name The name of the property reference to return.
     *
     * @return The first matching property reference or {@code null}, if no such reference is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getReference()
     * @see PropertyReference#getName()
     */
    public PropertyReference getReference( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( int i = 0, s0 = this.getReference().size(); i < s0; i++ )
        {
            final PropertyReference r = this.getReference().get( i );

            if ( name.equals( r.getName() ) )
            {
                return r;
            }
        }

        return null;
    }

    /**
     * Gets a list of properties of a given type.
     *
     * @param type The type of the properties to return or {@code null}, to return properties of the default type.
     *
     * @return An unmodifiable list holding all properties of {@code type}.
     *
     * @see #getProperty()
     * @see Property#getType()
     *
     * @since 1.2
     */
    public List<Property> getPropertiesByType( final String type )
    {
        final List<Property> list = new ArrayList<Property>( this.getProperty().size() );

        for ( int i = 0, s0 = this.getProperty().size(); i < s0; i++ )
        {
            final Property p = this.getProperty().get( i );

            if ( type == null ? p.getType() == null : type.equals( p.getType() ) )
            {
                list.add( p );
            }
        }

        return java.util.Collections.unmodifiableList( list );
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:sequence/xs:any">
      <jaxb:property>
        <jaxb:javadoc>Object value of this property or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>Name of this property.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:attribute[@name='type']">
      <jaxb:property>
        <jaxb:javadoc>Type of this property or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:attribute[@name='value']">
      <jaxb:property>
        <jaxb:javadoc>String value of this property or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this property is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this property is intended to override a super property.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']">
      <inheritance:implements>org.jomc.model.Inheritable</inheritance:implements>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']">
      <ci:code><![CDATA[
    /**
     * Gets the Java value of the property.
     * <p>The Java value of the property is computed based on the following rules:
     * <ol>
     * <li>If property {@code any} is set, the Java value is computed based on the object returned by method
     * {@code getAny()} by possibly unwrapping any {@code JAXBElement} instances. If that object declares a
     * <blockquote><pre>public Object getJavaValue( ClassLoader )</pre></blockquote> method, the value returned by this
     * method is the object returned by a call to that method. If that object does not declare such a method, the value
     * returned by this method is that (possibly unwrapped) object.</li>
     * <li>If property {@code value} is set, the Java value is computed based on the values of properties {@code type}
     * and {@code value}. If property {@code type} is not set or equals {@code java.lang.String}, the value returned
     * by this method is the string value returned by method {@code getValue()}. If property {@code type} equals a name
     * of a Java primitive type, an instance of the wrapper class corresponding to that primitive type name is returned
     * instantiated by passing the value of property {@code value} to the public constructor of that wrapper class
     * taking a single {@code java.lang.String} argument. For all other values of property {@code type} an instance of
     * a class with a name equal to the value of property {@code type} is returned, either instantiated by passing the
     * value of property {@code value} to the public constructor of that class taking a single {@code java.lang.String}
     * argument, or, failing that, by passing the value of property {@code value} to the static {@code valueOf} method
     * of that class taking a single {@code java.lang.String} argument.</li>
     * <li>If properties {@code any} and {@code value} are both {@code null}, this method returns {@code null}.</li>
     * </ol></p>
     *
     * @param classLoader The class loader to use for getting the Java value; {@code null} to use the platform's
     * bootstrap class loader.
     *
     * @return The Java value of the property or {@code null}.
     *
     * @throws ModelObjectException if compiling the name of the type to a {@code JavaTypeName} fails.
     * @throws PropertyException if getting the Java value of the property fails unexpectedly.
     *
     * @see #getJavaTypeName()
     */
    public Object getJavaValue( final ClassLoader classLoader ) throws ModelObjectException, PropertyException
    {
        try
        {
            if ( this.getAny() != null )
            {
                if ( this.getType() == null )
                {
                    throw new PropertyException( getMessage( "mandatoryType", this.getName() ) );
                }

                final Object anyObject = this.getAny() instanceof JAXBElement
                                         ? ( (JAXBElement) this.getAny() ).getValue() : this.getAny();

                return this.getJavaValue( classLoader, anyObject,
                                          this.getJavaTypeName().getClass( classLoader, false ) );

            }
            else
            {
                if ( this.getJavaTypeName().isPrimitive() && this.getValue() == null )
                {
                    throw new PropertyException( getMessage( "mandatoryPrimitiveValue", this.getName(),
                                                             this.getType() ) );

                }

                return this.getJavaValue( this.getJavaTypeName().isPrimitive()
                                          ? this.getJavaTypeName().getBoxedName().getClass( classLoader, false )
                                          : this.getJavaTypeName().getClass( classLoader, false ),
                                          this.getValue() );

            }
        }
        catch ( final ClassNotFoundException e )
        {
            throw new PropertyException( getMessage( "classNotFound", this.getName(), this.getType() ), e );
        }
    }

    /**
     * Gets the Java type name of the property.
     *
     * @return The Java type name of the type referenced by the property or {@code null}, if the property does not
     * reference a type.
     *
     * @throws ModelObjectException if compiling the name of the type referenced by the property to a
     * {@code JavaTypeName} fails.
     *
     * @since 1.4
     */
    public org.jomc.jls.JavaTypeName getJavaTypeName() throws ModelObjectException
    {
        final String typeName = this.getType() == null
                                ? this.getAny() == null
                                  ? String.class.getName()
                                  : Object.class.getName()
                                : this.getType();

        try
        {
            return org.jomc.jls.JavaTypeName.parse( typeName );
        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaTypeNameParseException", typeName, getMessage( e ) ), e );
        }
    }

    /**
     * Gets the Java getter method name of the property.
     *
     * @return The Java getter method name of the property.
     *
     * @throws ModelObjectException if compiling the name of the type referenced by the property to a
     * {@code JavaTypeName} fails or if compiling the name of the property to a {@code JavaIdentifier} fails.
     *
     * @since 1.4
     *
     * @see #getName()
     */
    public org.jomc.jls.JavaIdentifier getJavaGetterMethodName() throws ModelObjectException
    {
        try
        {
            final org.jomc.jls.JavaTypeName javaType = this.getJavaTypeName();
            final String prefix = javaType.runtimeEquals( org.jomc.jls.JavaTypeName.BOOLEAN )
                                  || javaType.runtimeEquals( org.jomc.jls.JavaTypeName.BOOLEAN_TYPE ) ? "is" : "get";

            return org.jomc.jls.JavaIdentifier.parse( prefix + org.jomc.jls.JavaIdentifier.normalize(
                this.getName() != null ? this.getName() : "",
                org.jomc.jls.JavaIdentifier.NormalizationMode.CAMEL_CASE ) );

        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaIdentifierParseException", this.getName(),
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Gets the Java setter method name of the property.
     *
     * @return The Java setter method name of the property.
     *
     * @throws ModelObjectException if compiling the name of the property to a {@code JavaIdentifier} fails.
     *
     * @since 1.4
     *
     * @see #getName()
     */
    public org.jomc.jls.JavaIdentifier getJavaSetterMethodName() throws ModelObjectException
    {
        try
        {
            return org.jomc.jls.JavaIdentifier.parse( "set" + org.jomc.jls.JavaIdentifier.normalize(
                this.getName() != null ? this.getName() : "",
                org.jomc.jls.JavaIdentifier.NormalizationMode.CAMEL_CASE ) );

        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaIdentifierParseException", this.getName(),
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Gets the Java variable name of the property.
     *
     * @return The Java variable name of the property.
     *
     * @throws ModelObjectException if compiling the name of the property to a {@code JavaIdentifier} fails.
     *
     * @since 1.4
     *
     * @see #getName()
     */
    public org.jomc.jls.JavaIdentifier getJavaVariableName() throws ModelObjectException
    {
        try
        {
            return org.jomc.jls.JavaIdentifier.normalize(
                this.getName() != null ? this.getName() : "",
                org.jomc.jls.JavaIdentifier.NormalizationMode.VARIABLE_NAME_CONVENTION );

        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaIdentifierParseException", this.getName(),
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Gets the Java constant name of the message.
     *
     * @return The Java constant name of the message.
     *
     * @throws ModelObjectException if compiling the name of the property to a {@code JavaIdentifier} fails.
     *
     * @since 1.4
     *
     * @see #getName()
     */
    public org.jomc.jls.JavaIdentifier getJavaConstantName() throws ModelObjectException
    {
        try
        {
            return org.jomc.jls.JavaIdentifier.normalize(
                this.getName() != null ? this.getName() : "",
                org.jomc.jls.JavaIdentifier.NormalizationMode.CONSTANT_NAME_CONVENTION );

        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaIdentifierParseException", this.getName(),
                                                        getMessage( e ) ), e );

        }
    }

    private Object getJavaValue( final ClassLoader classLoader, final Object any, final Class<?> returnType )
        throws PropertyException
    {
        if ( any != null )
        {
            final String methodName = "getJavaValue";

            try
            {
                final java.lang.reflect.Method m = any.getClass().getMethod( methodName, ClassLoader.class );
                final Object result = m.invoke( any, classLoader );

                if ( result != null && !returnType.isAssignableFrom( result.getClass() ) )
                {
                    throw new PropertyException( getMessage( "illegalMethodInvocationResult", methodName,
                                                             any.getClass().getName(), result.getClass().getName(),
                                                             returnType.getName() ) );

                }

                return result;
            }
            catch ( final IllegalAccessException e )
            {
                throw new PropertyException( getMessage( "methodAccessDenied", methodName,
                                                         any.getClass().getName() ), e );

            }
            catch ( final IllegalArgumentException e )
            {
                throw new AssertionError( e );
            }
            catch ( final InvocationTargetException e )
            {
                throw new PropertyException( getMessage( "methodInvocationFailure", methodName,
                                                         any.getClass().getName() ), e );

            }
            catch ( final SecurityException e )
            {
                throw new PropertyException( getMessage( "methodAccessDenied", methodName,
                                                         any.getClass().getName() ), e );

            }
            catch ( final NoSuchMethodException e )
            {
                // Optional method not provided.
            }
        }

        return any;
    }

    private Object getJavaValue( final Class<?> type, final String value ) throws PropertyException
    {
        if ( value != null )
        {
            try
            {
                if ( type == Character.class )
                {
                    if ( value.length() != 1 )
                    {
                        throw new PropertyException( getMessage( "illegalValue", value, Character.class.getName() ) );
                    }

                    return type.getConstructor( char.class ).newInstance( value.charAt( 0 ) );
                }
                else if ( type == String.class )
                {
                    return value;
                }
                else
                {
                    try
                    {
                        return type.getConstructor( String.class ).newInstance( value );
                    }
                    catch ( final NoSuchMethodException e )
                    {
                        // Since 1.5: Try static 'valueOf' method.
                        final java.lang.reflect.Method valueOf = type.getMethod( "valueOf", String.class );

                        if ( !type.isAssignableFrom( valueOf.getReturnType() ) )
                        {
                            throw new PropertyException( getMessage( "notAssignable", valueOf.getReturnType().getName(),
                                                                     valueOf.getName(), type.getName(),
                                                                     type.getName(), this.getName() ) );

                        }

                        return valueOf.invoke( null, value );
                    }
                }
            }
            catch ( final InstantiationException e )
            {
                throw new PropertyException( getMessage( "instantiationException", type.getName() ), e );
            }
            catch ( final IllegalAccessException e )
            {
                throw new PropertyException( getMessage( "accessDenied", type.getName() ), e );
            }
            catch ( final IllegalArgumentException e )
            {
                throw new AssertionError( e );
            }
            catch ( final InvocationTargetException e )
            {
                throw new PropertyException( getMessage( "invocationFailure", type.getName() ), e );
            }
            catch ( final NoSuchMethodException e )
            {
                throw new PropertyException( getMessage( "constructorNotFound", type.getName() ), e );
            }
        }

        return value;
    }

    private static String getMessage( final Throwable t )
    {
        return t != null
               ? t.getMessage() != null && t.getMessage().trim().length() > 0
                 ? t.getMessage()
                 : getMessage( t.getCause() )
               : null;

    }

    private static String getMessage( final String key, final Object... arguments )
    {
        return java.text.MessageFormat.format( java.util.ResourceBundle.getBundle(
            Property.class.getName().replace( '.', '/' ), java.util.Locale.getDefault() ).getString( key ), arguments );

    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='PropertyReference']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>The name of the referenced property.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='PropertyReference']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this property reference is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='PropertyReference']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this property reference is intended to override a super property reference.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='PropertyReference']">
      <inheritance:implements>org.jomc.model.Inheritable</inheritance:implements>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Messages']">
      <ci:code><![CDATA[
    /**
     * Gets a message for a given name from the list of messages.
     *
     * @param name The name of the message to return.
     *
     * @return The first matching message or {@code null}, if no such message is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getMessage()
     * @see Message#getName()
     */
    public Message getMessage( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( int i = 0, s0 = this.getMessage().size(); i < s0; i++ )
        {
            final Message m = this.getMessage().get( i );

            if ( name.equals( m.getName() ) )
            {
                return m;
            }
        }

        return null;
    }

    /**
     * Gets a message reference for a given name from the list of references.
     *
     * @param name The name of the message reference to return.
     *
     * @return The first matching message reference or {@code null}, if no such reference is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getReference()
     * @see MessageReference#getName()
     */
    public MessageReference getReference( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( int i = 0, s0 = this.getReference().size(); i < s0; i++ )
        {
            final MessageReference r = this.getReference().get( i );

            if ( name.equals( r.getName() ) )
            {
                return r;
            }
        }

        return null;
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Message']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:template']">
      <jaxb:property>
        <jaxb:javadoc>The localizable template of this message.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Message']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:arguments']">
      <jaxb:property>
        <jaxb:javadoc>The format arguments of this message or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Message']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>The name of this message.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Message']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this message is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Message']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this message is intended to override a super message.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Message']">
      <inheritance:implements>org.jomc.model.Inheritable</inheritance:implements>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Message']">
      <ci:code><![CDATA[
    /**
     * System's line separator.
     * @since 1.2
     */
    @javax.xml.bind.annotation.XmlTransient
    private static final String LINE_SEPARATOR = System.getProperty( "line.separator", "\n" );

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null}, if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> javax.xml.bind.JAXBElement<T> getAnyElement( final String namespaceURI, final String localPart,
                                                            final Class<T> type )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final String namespaceURI,
                                                                             final String localPart,
                                                                             final Class<T> type )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a single object matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} property of the instance or {@code null}, if no such
     * instance is found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching object.
     *
     * @see #getAnyObject(java.util.List, java.lang.Class)
     */
    public <T> T getAnyObject( final Class<T> clazz )
    {
        return this.getAnyObject( this.getAny(), clazz );
    }

    /**
     * Gets a list containing all objects matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} property of the instance -
     * an empty list if no such objects are found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     *
     * @see #getAnyObjects(java.util.List, java.lang.Class)
     */
    public <T> java.util.List<T> getAnyObjects( final Class<T> clazz )
    {
        return this.getAnyObjects( this.getAny(), clazz );
    }

    /**
     * Gets a Java {@code MessageFormat} instance for a given locale.
     *
     * @param locale The locale to get a Java {@code MessageFormat} instance for.
     *
     * @return A Java {@code MessageFormat} instance for {@code locale}.
     *
     * @throws NullPointerException if {@code locale} is {@code null}.
     * @throws ModelObjectException if compiling the template of the message for {@code locale} to a
     * {@code MessageFormat} fails.
     *
     * @see #getTemplate()
     *
     * @since 1.2
     */
    public java.text.MessageFormat getJavaMessage( final Locale locale ) throws ModelObjectException
    {
        if ( locale == null )
        {
            throw new NullPointerException( "locale" );
        }

        final Text text = this.getTemplate().getText( locale.getLanguage().toLowerCase( Locale.ENGLISH ) );
        final StringBuilder builder = new StringBuilder( text.getValue().length() );
        String pattern = null;

        try
        {
            final java.io.BufferedReader reader =
                new java.io.BufferedReader( new java.io.StringReader( text.getValue() ) );

            String line;
            while ( ( line = reader.readLine() ) != null )
            {
                builder.append( LINE_SEPARATOR ).append( line );
            }

            pattern = builder.length() > 0 ? builder.substring( LINE_SEPARATOR.length() ) : builder.toString();
            return new java.text.MessageFormat( pattern, locale );

        }
        catch ( final IllegalArgumentException e )
        {
            throw new ModelObjectException( getMessage( "javaMessageParseException", pattern, getMessage( e ) ), e );
        }
        catch ( final java.io.IOException e )
        {
            throw new AssertionError( e );
        }
    }

    /**
     * Gets the Java getter method name of the message.
     *
     * @return The Java getter method name of the message.
     *
     * @throws ModelObjectException if compiling the name of the message to a {@code JavaIdentifier} fails.
     *
     * @since 1.4
     *
     * @see #getName()
     */
    public org.jomc.jls.JavaIdentifier getJavaGetterMethodName() throws ModelObjectException
    {
        try
        {
            return org.jomc.jls.JavaIdentifier.parse( "get" + org.jomc.jls.JavaIdentifier.normalize(
                this.getName() != null ? this.getName() : "",
                org.jomc.jls.JavaIdentifier.NormalizationMode.CAMEL_CASE ) );

        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaIdentifierParseException", this.getName(),
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Gets the Java setter method name of the message.
     *
     * @return The Java setter method name of the message.
     *
     * @throws ModelObjectException if compiling the name of the message to a {@code JavaIdentifier} fails.
     *
     * @since 1.4
     *
     * @see #getName()
     */
    public org.jomc.jls.JavaIdentifier getJavaSetterMethodName() throws ModelObjectException
    {
        try
        {
            return org.jomc.jls.JavaIdentifier.parse( "set" + org.jomc.jls.JavaIdentifier.normalize(
                this.getName() != null ? this.getName() : "",
                org.jomc.jls.JavaIdentifier.NormalizationMode.CAMEL_CASE ) );

        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaIdentifierParseException", this.getName(),
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Gets the Java variable name of the message.
     *
     * @return The Java variable name of the message.
     *
     * @throws ModelObjectException if compiling the name of the message to a {@code JavaIdentifier} fails.
     *
     * @since 1.4
     *
     * @see #getName()
     */
    public org.jomc.jls.JavaIdentifier getJavaVariableName() throws ModelObjectException
    {
        try
        {
            return org.jomc.jls.JavaIdentifier.normalize(
                this.getName() != null ? this.getName() : "",
                org.jomc.jls.JavaIdentifier.NormalizationMode.VARIABLE_NAME_CONVENTION );

        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaIdentifierParseException", this.getName(),
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Gets the Java constant name of the message.
     *
     * @return The Java constant name of the message.
     *
     * @throws ModelObjectException if compiling the name of the message to a {@code JavaIdentifier} fails.
     *
     * @since 1.4
     *
     * @see #getName()
     */
    public org.jomc.jls.JavaIdentifier getJavaConstantName() throws ModelObjectException
    {
        try
        {
            return org.jomc.jls.JavaIdentifier.normalize(
                this.getName() != null ? this.getName() : "",
                org.jomc.jls.JavaIdentifier.NormalizationMode.CONSTANT_NAME_CONVENTION );

        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaIdentifierParseException", this.getName(),
                                                        getMessage( e ) ), e );

        }
    }

    private static String getMessage( final Throwable t )
    {
        return t != null
               ? t.getMessage() != null && t.getMessage().trim().length() > 0
                 ? t.getMessage()
                 : getMessage( t.getCause() )
               : null;

    }

    private static String getMessage( final String key, final Object... arguments )
    {
        return java.text.MessageFormat.format( java.util.ResourceBundle.getBundle(
            Message.class.getName().replace( '.', '/' ), java.util.Locale.getDefault() ).
            getString( key ), arguments );

    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='MessageReference']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>The name of the referenced message.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='MessageReference']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this message reference is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='MessageReference']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this message reference is intended to override a super message reference.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='MessageReference']">
      <inheritance:implements>org.jomc.model.Inheritable</inheritance:implements>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Arguments']">
      <ci:code><![CDATA[
    /**
     * Gets an argument for a given name from the list of arguments.
     *
     * @param name The name of the argument to return.
     *
     * @return The first matching argument or {@code null}, if no such argument is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getArgument()
     * @see Argument#getName()
     */
    public Argument getArgument( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( int i = 0, s0 = this.getArgument().size(); i < s0; i++ )
        {
            final Argument a = this.getArgument().get( i );

            if ( name.equals( a.getName() ) )
            {
                return a;
            }
        }

        return null;
    }

    /**
     * Gets an argument for a given index from the list of arguments.
     *
     * @param index The index of the argument to return.
     *
     * @return The first matching argument or {@code null}, if no such argument is found.
     *
     * @throws IndexOutOfBoundsException if {@code index} is negative, greater or equal to the size of the list of
     * arguments.
     *
     * @see #getArgument()
     * @see Argument#getIndex()
     */
    public Argument getArgument( final int index )
    {
        if ( index < 0 || index >= this.getArgument().size() )
        {
            throw new IndexOutOfBoundsException( Integer.toString( index ) );
        }

        for ( int i = 0, s0 = this.getArgument().size(); i < s0; i++ )
        {
            final Argument a = this.getArgument().get( i );

            if ( index == a.getIndex() )
            {
                return a;
            }
        }

        return null;
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Argument']/xs:complexContent/xs:extension/xs:attribute[@name='index']">
      <jaxb:property>
        <jaxb:javadoc>Index of this argument.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Argument']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>Name of this argument.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Argument']/xs:complexContent/xs:extension/xs:attribute[@name='type']">
      <jaxb:property>
        <jaxb:javadoc>Type of this argument.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Argument']">
      <ci:code><![CDATA[
    /**
     * Gets the Java type name of the type referenced by the argument.
     *
     * @return The Java type name of the type referenced by the argument or {@code null}, if the argument does not
     * reference a type.
     *
     * @throws ModelObjectException if compiling the name of the referenced type to a {@code JavaTypeName} fails.
     *
     * @since 1.4
     *
     * @see #getType()
     */
    public org.jomc.jls.JavaTypeName getJavaTypeName() throws ModelObjectException
    {
        try
        {
            String typeName = "java.lang.String";

            if ( this.getType() == ArgumentType.DATE || this.getType() == ArgumentType.TIME )
            {
                typeName = "java.util.Date";
            }
            else if ( this.getType() == ArgumentType.NUMBER )
            {
                typeName = "java.lang.Number";
            }

            return org.jomc.jls.JavaTypeName.parse( typeName );
        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaTypeNameParseException", this.getType(), getMessage( e ) ),
                                            e );

        }
    }

    /**
     * Gets the Java variable name of the argument.
     *
     * @return The Java variable name of the argument.
     *
     * @throws ModelObjectException if compiling the name of the argument to a {@code JavaIdentifier} fails.
     *
     * @since 1.4
     *
     * @see #getName()
     */
    public org.jomc.jls.JavaIdentifier getJavaVariableName() throws ModelObjectException
    {
        try
        {
            return org.jomc.jls.JavaIdentifier.normalize(
                this.getName() != null ? this.getName() : "",
                org.jomc.jls.JavaIdentifier.NormalizationMode.VARIABLE_NAME_CONVENTION );

        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaMethodParameterNameParseException", this.getName(),
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null}, if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> javax.xml.bind.JAXBElement<T> getAnyElement( final String namespaceURI, final String localPart,
                                                            final Class<T> type )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final String namespaceURI,
                                                                             final String localPart,
                                                                             final Class<T> type )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a single object matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} property of the instance or {@code null}, if no such
     * instance is found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching object.
     *
     * @see #getAnyObject(java.util.List, java.lang.Class)
     */
    public <T> T getAnyObject( final Class<T> clazz )
    {
        return this.getAnyObject( this.getAny(), clazz );
    }

    /**
     * Gets a list containing all objects matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} property of the instance -
     * an empty list if no such objects are found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     *
     * @see #getAnyObjects(java.util.List, java.lang.Class)
     */
    public <T> java.util.List<T> getAnyObjects( final Class<T> clazz )
    {
        return this.getAnyObjects( this.getAny(), clazz );
    }

    private static String getMessage( final Throwable t )
    {
        return t != null
               ? t.getMessage() != null && t.getMessage().trim().length() > 0
                 ? t.getMessage()
                 : getMessage( t.getCause() )
               : null;

    }

    private static String getMessage( final String key, final Object... arguments )
    {
        return java.text.MessageFormat.format( java.util.ResourceBundle.getBundle(
            Argument.class.getName().replace( '.', '/' ), java.util.Locale.getDefault() ).
            getString( key ), arguments );

    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Instances']">
      <ci:code><![CDATA[
    /**
     * Gets an instance for a given identifier from the list of instances.
     *
     * @param identifier The identifier of the instance to return.
     *
     * @return The first matching instance or {@code null}, if no such instance is found.
     *
     * @throws NullPointerException if {@code identifier} is {@code null}.
     *
     * @see #getInstance()
     * @see Instance#getIdentifier()
     */
    public Instance getInstance( final String identifier )
    {
        if ( identifier == null )
        {
            throw new NullPointerException( "identifier" );
        }

        for ( int i = 0, s0 = this.getInstance().size(); i < s0; i++ )
        {
            final Instance current = this.getInstance().get( i );

            if ( identifier.equals( current.getIdentifier() ) )
            {
                return current;
            }
        }

        return null;
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:specifications']">
      <jaxb:property>
        <jaxb:javadoc>Specifications implemented by this instance or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:dependencies']">
      <jaxb:property>
        <jaxb:javadoc>Dependencies of this instance or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:properties']">
      <jaxb:property>
        <jaxb:javadoc>Properties of this instance or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:messages']">
      <jaxb:property>
        <jaxb:javadoc>Messages of this instance or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:attribute[@name='identifier']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of this instance.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>The name of the implementation of the specifications implemented by this instance.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:attribute[@name='class']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of the class of this instance.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:attribute[@name='stateless']">
      <jaxb:property>
        <jaxb:javadoc>{@code true}, if this instance does not retain state across operations.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']">
      <ci:code><![CDATA[
    /**
     * Empty {@code Class} array.
     * @since 1.2
     */
    @javax.xml.bind.annotation.XmlTransient
    private static final Class<?>[] NO_CLASSES =
    {
    };

    /** Maps dependency names to dependency objects. */
    @javax.xml.bind.annotation.XmlTransient private java.util.Map<String, Object> dependencyObjects;

    /**
     * Maps message names and locales to message format objects.
     * @since 1.2
     */
    @javax.xml.bind.annotation.XmlTransient private java.util.Map<String, java.util.Map<java.util.Locale, java.text.MessageFormat>> messageObjects;

    /** Maps property names to property objects. */
    @javax.xml.bind.annotation.XmlTransient private java.util.Map<String, Object> propertyObjects;

    /**
     * Gets a mapping of dependency names to objects bound to the instance.
     * <p>This method returns a reference to the live map, not a snapshot. Any modification you make to the returned map
     * will be present inside the object.</p>
     *
     * @return A mapping of dependency names to objects bound to the instance.
     */
    public java.util.Map<String, Object> getDependencyObjects()
    {
        if ( this.dependencyObjects == null )
        {
            this.dependencyObjects = new java.util.HashMap<String, Object>();
        }

        return this.dependencyObjects;
    }

    /**
     * Gets a mapping of message names to a mapping of locales to message format objects bound to the instance.
     * <p>This method returns a reference to the live map, not a snapshot. Any modification you make to the returned map
     * will be present inside the object.</p>
     *
     * @return A mapping of message names to a mapping of locales to message format objects bound to the instance.
     *
     * @since 1.2
     */
    public java.util.Map<String, java.util.Map<java.util.Locale, java.text.MessageFormat>> getMessageObjects()
    {
        if ( this.messageObjects == null )
        {
            this.messageObjects =
                new java.util.HashMap<String, java.util.Map<java.util.Locale, java.text.MessageFormat>>();

        }

        return this.messageObjects;
    }

    /**
     * Gets a mapping of property names to objects bound to the instance.
     * <p>This method returns a reference to the live map, not a snapshot. Any modification you make to the returned map
     * will be present inside the object.</p>
     *
     * @return A mapping of property names to objects bound to the instance.
     */
    public java.util.Map<String, Object> getPropertyObjects()
    {
        if ( this.propertyObjects == null )
        {
            this.propertyObjects = new java.util.HashMap<String, Object>();
        }

        return this.propertyObjects;
    }

    /**
     * Gets the Java class of the type referenced by the instance for a given class loader.
     *
     * @param classLoader The class loader to get the Java class from or {@code null}, to get the Java class from the
     * platform's bootstrap class loader.
     *
     * @return The Java class of the type referenced by the instance or {@code null}, if the instance does not reference
     * a type.
     *
     * @throws ClassNotFoundException if the Java class is not found.
     * @throws ModelObjectException if compiling the name of the referenced type to a {@code JavaTypeName} fails.
     *
     * @see #getClazz()
     * @see #getJavaTypeName()
     *
     * @since 1.2
     */
    public Class<?> getJavaClass( final ClassLoader classLoader )
        throws ClassNotFoundException, ModelObjectException
    {
        Class<?> javaClass = null;
        final org.jomc.jls.JavaTypeName javaTypeName = this.getJavaTypeName();

        if ( javaTypeName != null )
        {
            javaClass = javaTypeName.getClass( classLoader, false );
        }

        return javaClass;
    }

    /**
     * Gets the Java classes of all types referenced by the specifications of the instance for a given class loader.
     *
     * @param classLoader The class loader to get the Java classes from or {@code null}, to get the Java classes from
     * the platform's bootstrap class loader.
     *
     * @return The Java classes of all types referenced by the specifications of the instance.
     *
     * @throws ClassNotFoundException if a Java class is not found.
     * @throws ModelObjectException if parsing a name of a referenced type to a {@code JavaTypeName} fails.
     *
     * @see #getSpecifications()
     * @see Specification#getClazz()
     * @see Specification#getJavaClass(java.lang.ClassLoader)
     *
     * @since 1.2
     */
    public Class<?>[] getJavaClasses( final ClassLoader classLoader )
        throws ClassNotFoundException, ModelObjectException
    {
        final java.util.Set<Class<?>> classes = new java.util.HashSet<Class<?>>();

        if ( this.getSpecifications() != null )
        {
            for ( int i = 0, s0 = this.getSpecifications().getSpecification().size(); i < s0; i++ )
            {
                final Specification s = this.getSpecifications().getSpecification().get( i );
                final org.jomc.jls.JavaTypeName javaTypeName = s.getJavaTypeName();

                if ( javaTypeName != null )
                {
                    classes.add( javaTypeName.getClass( classLoader, false ) );
                }
            }
        }

        return classes.toArray( new Class<?>[ classes.size() ] );
    }

    /**
     * Gets the Java constructor to use for creating objects of the instance.
     *
     * @param classLoader The class loader to get the Java class from or {@code null}, to get the Java class from the
     * platform's bootstrap class loader.
     *
     * @return The public default Java constructor of the Java class of the instance or {@code null}, if the instance
     * does not reference a type, or if the class is not accessible or abstract or does not declare such a constructor.
     *
     * @throws ClassNotFoundException if the Java class is not found.
     * @throws ModelObjectException if compiling the name of the type referenced by the instance to a
     * {@code JavaTypeName} fails.
     *
     * @see #getJavaClass(java.lang.ClassLoader)
     *
     * @since 1.2
     */
    public java.lang.reflect.Constructor<?> getJavaConstructor( final ClassLoader classLoader )
        throws ClassNotFoundException, ModelObjectException
    {
        java.lang.reflect.Constructor<?> javaConstructor = null;
        final org.jomc.jls.JavaTypeName javaTypeName = this.getJavaTypeName();

        if ( javaTypeName != null )
        {
            final Class<?> javaClass = javaTypeName.getClass( classLoader, false );

            if ( java.lang.reflect.Modifier.isPublic( javaClass.getModifiers() )
                 && !java.lang.reflect.Modifier.isAbstract( javaClass.getModifiers() ) )
            {
                try
                {
                    javaConstructor = javaClass.getConstructor( NO_CLASSES );
                }
                catch ( final NoSuchMethodException e )
                {
                    javaConstructor = null;
                }
            }
        }

        return javaConstructor;
    }

    /**
     * Gets the name of the Java method to use for creating objects of the instance.
     *
     * @return The name of the Java method to use for creating objects of the instance or {@code null}, if no such
     * method name is supported.
     *
     * @throws ModelObjectException if compiling the name of the instance to a {@code JavaIdentifier} fails.
     *
     * @see #getName()
     *
     * @since 1.2
     */
    public String getJavaFactoryMethodName() throws ModelObjectException
    {
        try
        {
            String javaFactoryMethodName = null;

            if ( this.getName() != null )
            {
                javaFactoryMethodName =
                    org.jomc.jls.JavaIdentifier.parse( "get" + org.jomc.jls.JavaIdentifier.normalize(
                        this.getName(), org.jomc.jls.JavaIdentifier.NormalizationMode.CAMEL_CASE ) ).toString();

            }

            return javaFactoryMethodName;
        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaIdentifierParseException", this.getName(),
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Gets the Java method to use for creating objects of the instance.
     *
     * @param classLoader The class loader to get the Java class from or {@code null}, to get the Java class from the
     * platform's bootstrap class loader.
     *
     * @return The public Java method of the Java class of the instance to use for creating objects of the instance or
     * {@code null}, if the instance does not reference a type or no such method is supported.
     *
     * @throws ClassNotFoundException if the Java class is not found.
     * @throws ModelObjectException if compiling the name of the type referenced by the instance to a
     * {@code JavaTypeName} or if compiling the name of the instance to a {@code JavaIdentifier} fails.
     *
     * @see #getJavaClass(java.lang.ClassLoader)
     * @see #getJavaFactoryMethodName()
     *
     * @since 1.2
     */
    public java.lang.reflect.Method getJavaFactoryMethod( final ClassLoader classLoader )
        throws ClassNotFoundException, ModelObjectException
    {
        final org.jomc.jls.JavaTypeName javaTypeName = this.getJavaTypeName();
        java.lang.reflect.Method factoryMethod = null;

        if ( javaTypeName != null )
        {
            final Class<?> javaClass = javaTypeName.getClass( classLoader, false );
            final String methodName = this.getJavaFactoryMethodName();

            if ( methodName != null )
            {
                try
                {
                    factoryMethod = javaClass.getMethod( methodName, (Class[]) null );
                }
                catch ( final NoSuchMethodException e )
                {
                    factoryMethod = null;
                }
            }

            if ( factoryMethod == null )
            {
                try
                {
                    factoryMethod = javaClass.getMethod( "getObject", (Class[]) null );
                }
                catch ( final NoSuchMethodException e )
                {
                    factoryMethod = null;
                }
            }
        }

        return factoryMethod;
    }

    /**
     * Gets a flag indicating the Java class of the instance is assignable to all Java classes of all specifications of
     * the instance.
     *
     * @param classLoader The class loader to get the Java classes from or {@code null}, to get the Java classes from
     * the platform's bootstrap class loader.
     *
     * @return {@code true}, if the Java class of the instance is assignable to all Java classes of all specifications
     * of the instance; {@code false}, if the Java class of the instance is not assignable to all Java classes of all
     * specifications of the instance.
     *
     * @throws ClassNotFoundException if a Java class is not found.
     * @throws ModelObjectException if compiling a name of a referenced type to a {@code JavaTypeName} fails.
     *
     * @see #getJavaClass(java.lang.ClassLoader)
     * @see #getJavaClasses(java.lang.ClassLoader)
     * @see Class#isAssignableFrom(java.lang.Class)
     *
     * @since 1.2
     */
    public boolean isJavaClassAssignable( final ClassLoader classLoader )
        throws ClassNotFoundException, ModelObjectException
    {
        final org.jomc.jls.JavaTypeName javaTypeName = this.getJavaTypeName();
        boolean assignable = javaTypeName != null;

        if ( assignable )
        {
            final Class<?> javaClass = javaTypeName.getClass( classLoader, false );
            final Class<?>[] javaClasses = this.getJavaClasses( classLoader );

            for ( int i = javaClasses.length - 1; i >= 0; i-- )
            {
                if ( !javaClasses[i].isAssignableFrom( javaClass ) )
                {
                    assignable = false;
                    break;
                }
            }
        }

        return assignable;
    }

    /**
     * Gets the Java proxy class for a given class loader.
     *
     * @param classLoader The class loader to get the Java proxy class from or {@code null}, to get the Java proxy class
     * from the platform's bootstrap class loader.
     *
     * @return The Java proxy class for {@code classLoader} or {@code null}, if the instance does not support a Java
     * proxy class.
     *
     * @throws ClassNotFoundException if a Java class is not found.
     * @throws ModelObjectException if compiling a name of a referenced type to a {@code JavaTypeName} fails.
     *
     * @see #getJavaClasses(java.lang.ClassLoader)
     * @see Class#isInterface()
     *
     * @since 1.2
     */
    public Class<?> getJavaProxyClass( final ClassLoader classLoader )
        throws ClassNotFoundException, ModelObjectException
    {
        final Class<?>[] javaClasses = this.getJavaClasses( classLoader );
        boolean canProxy = javaClasses.length > 0;

        if ( canProxy )
        {
            for ( int i = javaClasses.length - 1; i >= 0; i-- )
            {
                if ( !javaClasses[i].isInterface() )
                {
                    canProxy = false;
                    break;
                }
            }
        }

        return canProxy ? java.lang.reflect.Proxy.getProxyClass( classLoader, javaClasses ) : null;
    }

    /**
     * Gets the Java type name of the type referenced by the instance.
     *
     * @return The Java type name of the type referenced by the instance or {@code null}, if the instance does not
     * reference a type.
     *
     * @throws ModelObjectException if compiling the name of the referenced type to a {@code JavaTypeName} fails.
     *
     * @see #getClazz()
     *
     * @since 1.4
     */
    public org.jomc.jls.JavaTypeName getJavaTypeName() throws ModelObjectException
    {
        try
        {
            org.jomc.jls.JavaTypeName javaTypeName = null;

            if ( this.getClazz() != null )
            {
                javaTypeName = org.jomc.jls.JavaTypeName.parse( this.getClazz() );
            }

            return javaTypeName;
        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "javaTypeNameParseException", this.getClazz(),
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null}, if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> javax.xml.bind.JAXBElement<T> getAnyElement( final String namespaceURI, final String localPart,
                                                            final Class<T> type )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final String namespaceURI,
                                                                             final String localPart,
                                                                             final Class<T> type )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a single object matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} property of the instance or {@code null} if no such
     * instance is found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching object.
     *
     * @see #getAnyObject(java.util.List, java.lang.Class)
     */
    public <T> T getAnyObject( final Class<T> clazz )
    {
        return this.getAnyObject( this.getAny(), clazz );
    }

    /**
     * Gets a list containing all objects matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} property of the instance -
     * an empty list if no such objects are found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     *
     * @see #getAnyObjects(java.util.List, java.lang.Class)
     */
    public <T> java.util.List<T> getAnyObjects( final Class<T> clazz )
    {
        return this.getAnyObjects( this.getAny(), clazz );
    }

    private static String getMessage( final Throwable t )
    {
        return t != null
               ? t.getMessage() != null && t.getMessage().trim().length() > 0
                 ? t.getMessage()
                 : getMessage( t.getCause() )
               : null;

    }

    private static String getMessage( final String key, final Object... arguments )
    {
        return java.text.MessageFormat.format( java.util.ResourceBundle.getBundle(
            Instance.class.getName().replace( '.', '/' ), java.util.Locale.getDefault() ).
            getString( key ), arguments );

    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Person']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>Name of this person.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Person']/xs:complexContent/xs:extension/xs:attribute[@name='mail']">
      <jaxb:property>
        <jaxb:javadoc>Mail address of this person or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Person']">
      <ci:code><![CDATA[
    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null}, if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> javax.xml.bind.JAXBElement<T> getAnyElement( final String namespaceURI, final String localPart,
                                                            final Class<T> type )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final String namespaceURI,
                                                                             final String localPart,
                                                                             final Class<T> type )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a single object matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} property of the instance or {@code null}, if no such
     * instance is found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching object.
     *
     * @see #getAnyObject(java.util.List, java.lang.Class)
     */
    public <T> T getAnyObject( final Class<T> clazz )
    {
        return this.getAnyObject( this.getAny(), clazz );
    }

    /**
     * Gets a list containing all objects matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} property of the instance -
     * an empty list if no such objects are found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     *
     * @see #getAnyObjects(java.util.List, java.lang.Class)
     */
    public <T> java.util.List<T> getAnyObjects( final Class<T> clazz )
    {
        return this.getAnyObjects( this.getAny(), clazz );
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Author']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>The version created by this author or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:simpleType[@name='ArgumentType']/xs:restriction/xs:enumeration[@value='Number']">
      <jaxb:typesafeEnumMember name="NUMBER">
        <jaxb:javadoc>Argument of type {@code java.lang.Number}.</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <jaxb:bindings node="xs:simpleType[@name='ArgumentType']/xs:restriction/xs:enumeration[@value='Date']">
      <jaxb:typesafeEnumMember name="DATE">
        <jaxb:javadoc>Argument of type {@code java.util.Date}.</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <jaxb:bindings node="xs:simpleType[@name='ArgumentType']/xs:restriction/xs:enumeration[@value='Time']">
      <jaxb:typesafeEnumMember name="TIME">
        <jaxb:javadoc>Argument of type {@code java.util.Date}.</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <jaxb:bindings node="xs:simpleType[@name='ArgumentType']/xs:restriction/xs:enumeration[@value='Text']">
      <jaxb:typesafeEnumMember name="TEXT">
        <jaxb:javadoc>Argument of type {@code java.lang.String}.</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:simpleType[@name='Multiplicity']/xs:restriction/xs:enumeration[@value='One']">
      <jaxb:typesafeEnumMember name="ONE">
        <jaxb:javadoc>A multiplicity equal to {@code ONE} specifies that no more than one implementation of the specification is allowed to exist among a set of modules (including none).</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <jaxb:bindings node="xs:simpleType[@name='Multiplicity']/xs:restriction/xs:enumeration[@value='Many']">
      <jaxb:typesafeEnumMember name="MANY">
        <jaxb:javadoc>A multiplicity equal to {@code MANY} specifies that many implementations of the specification are allowed to exist among a set of modules (including none).</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Modules']">
      <ci:code><![CDATA[
    /**
     * Constant for the default name of the classpath module.
     * @see #getDefaultClasspathModuleName()
     */
    @javax.xml.bind.annotation.XmlTransient
    private static final String DEFAULT_CLASSPATH_MODULE_NAME = "Java Classpath";

    /** Default classpath module name. */
    @javax.xml.bind.annotation.XmlTransient
    private static volatile String defaultClasspathModuleName;

    /** Empty {@code Class} array. */
    @javax.xml.bind.annotation.XmlTransient
    private static final Class<?>[] NO_CLASSES =
    {
    };

    /**
     * Comparator comparing dependency names lexicographically.
     * @since 1.2
     */
    @javax.xml.bind.annotation.XmlTransient
    private static final java.util.Comparator<Dependency> DEPENDENCY_NAME_COMPARATOR =
        new java.util.Comparator<Dependency>()
    {

        public int compare( final Dependency o1, final Dependency o2 )
        {
            return o1.getName().compareTo( o2.getName() );
        }

    };

    /**
     * Comparator comparing message names lexicographically.
     * @since 1.2
     */
    @javax.xml.bind.annotation.XmlTransient
    private static final java.util.Comparator<Message> MESSAGE_NAME_COMPARATOR =
        new java.util.Comparator<Message>()
    {

        public int compare( final Message o1, final Message o2 )
        {
            return o1.getName().compareTo( o2.getName() );
        }

    };

    /**
     * Comparator comparing property names lexicographically.
     * @since 1.2
     */
    @javax.xml.bind.annotation.XmlTransient
    private static final java.util.Comparator<Property> PROPERTY_NAME_COMPARATOR =
        new java.util.Comparator<Property>()
    {

        public int compare( final Property o1, final Property o2 )
        {
            return o1.getName().compareTo( o2.getName() );
        }

    };

    /**
     * Comparator comparing specification identifiers lexicographically.
     * @since 1.2
     */
    @javax.xml.bind.annotation.XmlTransient
    private static final java.util.Comparator<Specification> SPECIFICATION_IDENTIFIER_COMPARATOR =
        new java.util.Comparator<Specification>()
    {

        public int compare( final Specification o1, final Specification o2 )
        {
            return o1.getIdentifier().compareTo( o2.getIdentifier() );
        }

    };

    /**
     * Comparator comparing specification reference identifiers lexicographically.
     * @since 1.2
     */
    @javax.xml.bind.annotation.XmlTransient
    private static final java.util.Comparator<SpecificationReference> SPECIFICATION_REFERENCE_IDENTIFIER_COMPARATOR =
        new java.util.Comparator<SpecificationReference>()
    {

        public int compare( final SpecificationReference o1, final SpecificationReference o2 )
        {
            return o1.getIdentifier().compareTo( o2.getIdentifier() );
        }

    };

    /**
     * Comparator comparing {@code JavaTypeName} names lexicographically.
     * @since 1.4
     */
    @javax.xml.bind.annotation.XmlTransient
    private static final java.util.Comparator<org.jomc.jls.JavaTypeName> JAVA_TYPE_NAME_COMPARATOR =
        new java.util.Comparator<org.jomc.jls.JavaTypeName>()
    {

        public int compare( final org.jomc.jls.JavaTypeName o1, final org.jomc.jls.JavaTypeName o2 )
        {
            return o1.getName( true ).compareTo( o2.getName( true ) );
        }

    };

    /** Maps objects to {@code Instance}s. */
    @javax.xml.bind.annotation.XmlTransient private java.util.Map<Object, Instance> objects =
        new org.jomc.util.WeakIdentityHashMap<Object, Instance>();

    /**
     * Creates a new {@code Modules} instance taking a map backing the instance.
     *
     * @param objects The map backing the instance.
     */
    public Modules( final java.util.Map<Object, Instance> objects )
    {
        super();

        if ( objects == null )
        {
            throw new NullPointerException( "objects" );
        }

        this.objects = objects;
    }

    /**
     * Creates a new {@code Modules} instance by deeply copying a given {@code Modules} instance taking a map backing
     * the instance.
     *
     * @param o The instance to copy.
     * @param objects The map backing the instance.
     *
     * @throws NullPointerException if {@code o} or {@code objects} is {@code null}.
     */
    public Modules( final Modules o, final java.util.Map<Object, Instance> objects )
    {
        super( o );
        if ( o == null )
        {
            throw new NullPointerException( "Cannot create a copy of 'Modules' from 'null'." );
        }
        if ( objects == null )
        {
            throw new NullPointerException( "objects" );
        }

        copyModule( o.getModule(), getModule() );
        this.objects = objects;
    }

    /**
     * Gets the default classpath module name.
     * <p>The default classpath module name is controlled by system property
     * {@code org.jomc.model.Modules.defaultClasspathModuleName} holding the default classpath module name. If that
     * property is not set, the {@code Java Classpath} default is returned.</p>
     *
     * @return The default classpath module name.
     *
     * @see #getClasspathModule(java.lang.String, java.lang.ClassLoader)
     */
    public static String getDefaultClasspathModuleName()
    {
        if ( defaultClasspathModuleName == null )
        {
            defaultClasspathModuleName = System.getProperty( "org.jomc.model.Modules.defaultClasspathModuleName",
                                                             DEFAULT_CLASSPATH_MODULE_NAME );

        }

        return defaultClasspathModuleName;
    }

    /**
     * Sets the default classpath module name.
     *
     * @param value The new default classpath module name or {@code null},
     */
    public static void setDefaultClasspathModuleName( final String value )
    {
        defaultClasspathModuleName = value;
    }

    /**
     * Gets a module holding model objects resolved by inspecting a given class loader.
     * <p>This method searches this list of modules for unresolved references and tries to resolve each unresolved
     * reference by inspecting the given class loader.</p>
     *
     * @param moduleName The name of the module to return.
     * @param classLoader The class loader to use for resolving entities or {@code null}, to resolve entities using the
     * bootstrap class loader.
     *
     * @return A module holding model objects resolved by inspecting the given class loader or {@code null}, if nothing
     * is resolved.
     *
     * @throws NullPointerException if {@code moduleName} is {@code null}.
     *
     * @see #getDefaultClasspathModuleName()
     * @see #getModule()
     */
    public Module getClasspathModule( final String moduleName, final ClassLoader classLoader )
    {
        if ( moduleName == null )
        {
            throw new NullPointerException( "moduleName" );
        }

        final Module classpathModule = new Module();
        classpathModule.setVersion( System.getProperty( "java.specification.version" ) );
        classpathModule.setName( moduleName );

        this.resolveClasspath( classpathModule, classLoader );

        final boolean resolved = ( classpathModule.getSpecifications() != null
                                   && !classpathModule.getSpecifications().getSpecification().isEmpty() )
                                 || ( classpathModule.getImplementations() != null
                                      && !classpathModule.getImplementations().getImplementation().isEmpty() );

        return resolved ? classpathModule : null;
    }

    /**
     * Gets a module for a given name from the list of modules.
     *
     * @param name The name of the module to return.
     *
     * @return The first matching module or {@code null}, if no such module is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getModule()
     * @see Module#getName()
     */
    public Module getModule( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getName().equals( name ) )
            {
                return m;
            }
        }

        return null;
    }

    /**
     * Gets all specifications of the list of modules.
     *
     * @return All specifications or {@code null}, if no specifications are found.
     *
     * @see #getModule()
     */
    public Specifications getSpecifications()
    {
        final Specifications specifications = new Specifications();

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getSpecifications() != null )
            {
                specifications.getSpecification().addAll( m.getSpecifications().getSpecification() );
            }
        }

        return specifications.getSpecification().isEmpty() ? null : specifications;
    }

    /**
     * Gets all implementations of the list of modules.
     *
     * @return All implementations or {@code null}, if no implementations are found.
     *
     * @see #getModule()
     */
    public Implementations getImplementations()
    {
        final Implementations implementations = new Implementations();

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getImplementations() != null )
            {
                implementations.getImplementation().addAll( m.getImplementations().getImplementation() );
            }
        }

        return implementations.getImplementation().isEmpty() ? null : implementations;
    }

    /**
     * Gets the module declaring a given specification from the list of modules.
     *
     * @param specification The identifier of the specification whose declaring module to return.
     *
     * @return The first matching module or {@code null}, if no such module is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getModule()
     * @see Module#getSpecifications()
     * @see Specifications#getSpecification( java.lang.String )
     */
    public Module getModuleOfSpecification( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getSpecifications() != null && m.getSpecifications().getSpecification( specification ) != null )
            {
                return m;
            }
        }

        return null;
    }

    /**
     * Gets the module declaring a given implementation from the list of modules.
     *
     * @param implementation The identifier of the implementation whose declaring module to return.
     *
     * @return The first matching module or {@code null}, if no such module is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     * @see Module#getImplementations()
     * @see Implementations#getImplementation( java.lang.String )
     */
    public Module getModuleOfImplementation( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getImplementations() != null && m.getImplementations().getImplementation( implementation ) != null )
            {
                return m;
            }
        }

        return null;
    }

    /**
     * Gets a specification for a given identifier from the list of modules.
     *
     * @param specification The identifier of the specification to return.
     *
     * @return The first matching specification or {@code null}, if no such specification is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getModule()
     * @see Module#getSpecifications()
     * @see Specifications#getSpecification( java.lang.String )
     */
    public Specification getSpecification( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getSpecifications() != null )
            {
                final Specification s = m.getSpecifications().getSpecification( specification );

                if ( s != null )
                {
                    return s;
                }
            }
        }

        return null;
    }

    /**
     * Gets a specification declaring a given class from the list of modules.
     *
     * @param specification The class of the specification to return.
     *
     * @return The first matching specification declaring the given class or {@code null}, if no such specification is
     * found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     * @throws ModelObjectException if compiling a name of a referenced type to a {@code JavaTypeName} fails.
     *
     * @see #getModule()
     * @see Module#getSpecifications()
     * @see Specifications#getSpecification( java.lang.Class )
     */
    public Specification getSpecification( final Class<?> specification ) throws ModelObjectException
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getSpecifications() != null )
            {
                final Specification s = m.getSpecifications().getSpecification( specification );

                if ( s != null )
                {
                    return s;
                }
            }
        }

        return null;
    }

    /**
     * Gets all specifications an implementation implements from the list of modules.
     *
     * @param implementation The identifier of the implementation to get all implemented specifications of.
     *
     * @return All specifications implemented by the first matching implementation or {@code null}, if no such
     * implementation is found or if the first matching implementation does not implement any specification.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     * @see #getImplementation( java.lang.String )
     * @see Implementation#getImplementations()
     * @see Implementations#getReference()
     * @see Implementation#getSpecifications()
     */
    public Specifications getSpecifications( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Specifications specs = new Specifications();
        final Implementation impl = this.getImplementation( implementation );
        this.collectModelObjects( impl, null, null, null, specs, null, new java.util.HashSet<String>(), true );
        this.collectClassDeclarationModelObjects( impl, null, null, null, specs, null );
        java.util.Collections.sort( specs.getSpecification(), SPECIFICATION_IDENTIFIER_COMPARATOR );
        java.util.Collections.sort( specs.getReference(), SPECIFICATION_REFERENCE_IDENTIFIER_COMPARATOR );
        return specs.getSpecification().isEmpty() && specs.getReference().isEmpty() ? null : specs;
    }

    /**
     * Gets a list holding all {@code JavaTypeName}s an implementation implements from the list of modules.
     *
     * @param implementation The identifier of the implementation to get all implemented specifications of.
     *
     * @return An unmodifiable list holding all {@code JavaTypeName}s implemented by the first matching implementation
     * or {@code null}, if no such implementation is found or if that implementation does not implement any
     * {@code JavaTypeName}.
     *
     * @throws ModelObjectException if compiling the name of a referenced type to a {@code JavaTypeName} fails.
     *
     * @see #getSpecifications(java.lang.String)
     * @see Specification#getJavaTypeName()
     *
     * @since 1.4
     */
    public List<org.jomc.jls.JavaTypeName> getImplementedJavaTypeNames( final String implementation ) throws ModelObjectException
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Specifications implemented = this.getSpecifications( implementation );
        java.util.List<org.jomc.jls.JavaTypeName> javaTypeNames = null;

        if ( implemented != null )
        {
            javaTypeNames =
                new java.util.ArrayList<org.jomc.jls.JavaTypeName>( implemented.getSpecification().size() );

            for ( int i = 0, s0 = implemented.getSpecification().size(); i < s0; i++ )
            {
                final Specification s = implemented.getSpecification().get( i );
                final org.jomc.jls.JavaTypeName javaTypeName = s.getJavaTypeName();

                if ( javaTypeName != null && !javaTypeNames.contains( javaTypeName ) )
                {
                    javaTypeNames.add( javaTypeName );
                }
            }

            java.util.Collections.sort( javaTypeNames, JAVA_TYPE_NAME_COMPARATOR );
            javaTypeNames = java.util.Collections.unmodifiableList( javaTypeNames );
        }

        return javaTypeNames;
    }

    /**
     * Gets an implementation for a given identifier from the list of modules.
     *
     * @param implementation The identifier of the implementation to return.
     *
     * @return The first matching implementation or {@code null}, if no such implementation is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     * @see Module#getImplementations()
     * @see Implementations#getImplementation( java.lang.String )
     */
    public Implementation getImplementation( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getImplementations() != null )
            {
                final Implementation current = m.getImplementations().getImplementation( implementation );

                if ( current != null )
                {
                    return current;
                }
            }
        }

        return null;
    }

    /**
     * Gets an implementation declaring a given class from the list of modules.
     *
     * @param implementation The class of the implementation to return.
     *
     * @return The first matching implementation declaring the given class or {@code null}, if no such implementation is
     * found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     * @throws ModelObjectException if compiling a name of a referenced type to a {@code JavaTypeName} fails.
     *
     * @see #getModule()
     * @see Module#getImplementations()
     * @see Implementations#getImplementation( java.lang.Class )
     */
    public Implementation getImplementation( final Class<?> implementation ) throws ModelObjectException
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getImplementations() != null )
            {
                final Implementation current = m.getImplementations().getImplementation( implementation );

                if ( current != null )
                {
                    return current;
                }
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given object from the list of modules.
     *
     * @param object The object of the implementation to return.
     *
     * @return The first matching implementation or {@code null}, if no such implementation is found.
     *
     * @throws NullPointerException if {@code object} is {@code null}.
     * @throws ModelObjectException if compiling a name of a referenced type to a {@code JavaTypeName} fails.
     *
     * @see #getModule()
     * @see #getImplementation( java.lang.Class )
     */
    public Implementation getImplementation( final Object object ) throws ModelObjectException
    {
        return this.collectImplementation( object.getClass() );
    }

    /**
     * Gets an implementation for a given name implementing a given specification from the list of modules.
     *
     * @param specification The identifier of the specification to return an implementation of.
     * @param name The name of the implementation to return.
     *
     * @return The first matching implementation or {@code null}, if no such implementation is found.
     *
     * @throws NullPointerException if {@code specification} or {@code name} is {@code null}.
     *
     * @see #getModule()
     * @see #getImplementations( java.lang.String )
     * @see Implementations#getImplementationByName( java.lang.String )
     */
    public Implementation getImplementation( final String specification, final String name )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        final Implementations implementations = this.getImplementations( specification );
        if ( implementations != null )
        {
            return implementations.getImplementationByName( name );
        }

        return null;
    }

    /**
     * Gets all dependencies of an implementation from the list of modules.
     *
     * @param implementation The identifier of the implementation to get all dependencies of.
     *
     * @return All dependencies of the first matching implementation or {@code null}, if no such implementation is
     * found or if the first matching implementation does not have any dependencies.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     * @see #getImplementation( java.lang.String )
     * @see Implementation#getImplementations()
     * @see Implementations#getReference()
     * @see Implementation#getDependencies()
     */
    public Dependencies getDependencies( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Dependencies dependencies = new Dependencies();
        final Implementation impl = this.getImplementation( implementation );
        this.collectModelObjects( impl, dependencies, null, null, null, null, new java.util.HashSet<String>(), true );
        this.collectClassDeclarationModelObjects( impl, dependencies, null, null, null, null );
        java.util.Collections.sort( dependencies.getDependency(), DEPENDENCY_NAME_COMPARATOR );
        return dependencies.getDependency().isEmpty() ? null : dependencies;
    }

    /**
     * Gets the Java type name of a dependency.
     *
     * @param implementation The identifier of the implementation of the dependency.
     * @param dependency The name of the dependency to get the Java type name of.
     *
     * @return The Java type name of the dependency named {@code dependency } of the first matching implementation
     * identified by {@code implementation} or {@code null}, if the implementation, the dependency or the referenced
     * specification is not found or does not reference a Java type.
     *
     * @throws NullPointerException if {@code implementation} or {@code dependency} is {@code null}.
     * @throws ModelObjectException if compiling the name of the referenced type to a {@code JavaTypeName} fails.
     *
     * @since 1.4
     *
     * @see #getDependencies(java.lang.String)
     * @see Dependencies#getDependency(java.lang.String)
     * @see #getSpecification(java.lang.String)
     * @see Specification#getJavaTypeName()
     */
    public org.jomc.jls.JavaTypeName getDependencyJavaTypeName( final String implementation, final String dependency )
        throws ModelObjectException
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }
        if ( dependency == null )
        {
            throw new NullPointerException( "dependency" );
        }

        String typeName = null;

        try
        {
            org.jomc.jls.JavaTypeName javaTypeName = null;
            final Dependencies dependencies = this.getDependencies( implementation );

            if ( dependencies != null )
            {
                final Dependency d = dependencies.getDependency( dependency );

                if ( d != null )
                {
                    final Specification specification = this.getSpecification( d.getIdentifier() );

                    if ( specification != null && specification.getClazz() != null )
                    {
                        typeName = specification.getClazz();

                        if ( specification.getMultiplicity() == Multiplicity.MANY
                             && d.getImplementationName() == null )
                        {
                            typeName += "[]";
                        }

                        javaTypeName = org.jomc.jls.JavaTypeName.parse( typeName );
                    }
                }
            }

            return javaTypeName;
        }
        catch ( final java.text.ParseException e )
        {
            throw new ModelObjectException( getMessage( "dependencyJavaTypeNameParseException", typeName,
                                                        getMessage( e ) ), e );

        }
    }

    /**
     * Gets the Java modifier name of a dependency.
     *
     * @param implementation The identifier of the implementation of the dependency.
     * @param dependency The name of the dependency to get the Java modifier name of.
     *
     * @return The Java modifier name of the dependency named {@code dependency} of the first matching implementation
     * identified by {@code implementation} or {@code null}, if the implementation or the dependency is not found.
     *
     * @throws NullPointerException if {@code implementation} or {@code dependency} is {@code null}.
     *
     * @since 1.4
     *
     * @see #getDependencies(java.lang.String)
     * @see Dependencies#getDependency(java.lang.String)
     */
    public String getDependencyJavaModifierName( final String implementation, final String dependency )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }
        if ( dependency == null )
        {
            throw new NullPointerException( "dependency" );
        }

        final Dependencies dependencies = this.getDependencies( implementation );

        if ( dependencies != null )
        {
            final Dependency d = dependencies.getDependency( dependency );

            if ( d != null )
            {
                return "private";
            }
        }

        return null;
    }

    /**
     * Gets all properties of an implementation from the list of modules.
     *
     * @param implementation The identifier of the implementation to get all properties of.
     *
     * @return All properties of the first matching implementation or {@code null}, if no such implementation is found
     * or if the first matching implementation does not have any properties.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     * @see #getImplementation( java.lang.String )
     * @see Implementation#getImplementations()
     * @see Implementations#getReference()
     * @see Implementation#getProperties()
     */
    public Properties getProperties( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Properties properties = new Properties();
        final Specifications specifications = new Specifications();
        final Implementation impl = this.getImplementation( implementation );
        this.collectModelObjects(
            impl, null, null, properties, specifications, null, new java.util.HashSet<String>(), true );

        this.collectClassDeclarationModelObjects( impl, null, null, properties, specifications, null );
        this.collectSpecifiedModelObjects( specifications, properties );
        java.util.Collections.sort( properties.getProperty(), PROPERTY_NAME_COMPARATOR );
        return properties.getProperty().isEmpty() ? null : properties;
    }

    /**
     * Gets all properties specified for an implementation from the list of modules.
     *
     * @param implementation The identifier of the implementation to return specified properties of.
     *
     * @return All properties specified for the first matching implementation or {@code null}, if no such implementation
     * is found or if the first matching implementation does not have any specified properties.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     * @see #getSpecifications( java.lang.String )
     * @see Specification#getProperties()
     */
    public Properties getSpecifiedProperties( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Properties properties = new Properties();
        final Specifications specs = this.getSpecifications( implementation );

        if ( specs != null )
        {
            for ( int i = 0, s0 = specs.getSpecification().size(); i < s0; i++ )
            {
                final Specification s = specs.getSpecification().get( i );

                if ( s.getProperties() != null )
                {
                    properties.getProperty().addAll( s.getProperties().getProperty() );
                }
            }
        }

        java.util.Collections.sort( properties.getProperty(), PROPERTY_NAME_COMPARATOR );
        return properties.getProperty().isEmpty() ? null : properties;
    }

    /**
     * Gets the Java modifier name of a property.
     *
     * @param implementation The identifier of the implementation of the property.
     * @param property The name of the property to get the Java modifier name of.
     *
     * @return The Java modifier name of the property named {@code property} of the first matching implementation
     * identified by {@code implementation} or {@code null}, if the implementation or the property is not found.
     *
     * @throws NullPointerException if {@code implementation} or {@code dependency} is {@code null}.
     *
     * @since 1.4
     *
     * @see #getProperties(java.lang.String)
     * @see Properties#getProperty(java.lang.String)
     */
    public String getPropertyJavaModifierName( final String implementation, final String property )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }
        if ( property == null )
        {
            throw new NullPointerException( "property" );
        }

        final Properties properties = this.getProperties( implementation );

        if ( properties != null )
        {
            final Property p = properties.getProperty( property );

            if ( p != null )
            {
                final Properties specified = this.getSpecifiedProperties( implementation );

                return specified != null && specified.getProperty( property ) != null ? "public" : "private";
            }
        }

        return null;
    }
     
    /**
     * Gets all messages of an implementation from the list of modules.
     *
     * @param implementation The identifier of the implementation to get all messages of.
     *
     * @return All messages of the first matching implementation or {@code null}, if no such implementation is found
     * or if the first matching implementation does not have any messages.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     * @see #getImplementation( java.lang.String )
     * @see Implementation#getImplementations()
     * @see Implementations#getReference()
     * @see Implementation#getMessages()
     */
    public Messages getMessages( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Messages msgs = new Messages();
        final Implementation impl = this.getImplementation( implementation );
        this.collectModelObjects( impl, null, msgs, null, null, null, new java.util.HashSet<String>(), true );
        this.collectClassDeclarationModelObjects( impl, null, msgs, null, null, null );
        java.util.Collections.sort( msgs.getMessage(), MESSAGE_NAME_COMPARATOR );
        return msgs.getMessage().isEmpty() ? null : msgs;
    }

    /**
     * Gets the Java modifier name of a message.
     *
     * @param implementation The identifier of the implementation of the message.
     * @param message The name of the message to get the Java modifier name of.
     *
     * @return The Java modifier name of the message named {@code message} of the first matching implementation
     * identified by {@code implementation} or {@code null}, if the implementation or the message is not found.
     *
     * @throws NullPointerException if {@code implementation} or {@code message} is {@code null}.
     *
     * @since 1.4
     *
     * @see #getMessages(java.lang.String)
     * @see Messages#getMessage(java.lang.String)
     */
    public String getMessageJavaModifierName( final String implementation, final String message )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }
        if ( message == null )
        {
            throw new NullPointerException( "message" );
        }

        final Messages messages = this.getMessages( implementation );

        if ( messages != null )
        {
            final Message m = messages.getMessage( message );

            if ( m != null )
            {
                return "private";
            }
        }

        return null;
    }

    /**
     * Gets any objects of an implementation from the list of modules.
     *
     * @param implementation The identifier of the implementation to get any objects of.
     *
     * @return Any objects of the first matching implementation or {@code null}, if no such implementation is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     * @see #getImplementation( java.lang.String )
     * @see Implementation#getImplementations()
     * @see Implementations#getReference()
     * @see Implementation#getAny()
     *
     * @since 1.2
     */
    public List<Object> getAnyObjects( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Implementation impl = this.getImplementation( implementation );
        final java.util.List<Object> any = new java.util.LinkedList<Object>();
        this.collectModelObjects( impl, null, null, null, null, any, new java.util.HashSet<String>(), true );
        this.collectClassDeclarationModelObjects( impl, null, null, null, null, any );
        return any;
    }

    /**
     * Gets all implementations implementing a given specification from the list of modules.
     *
     * @param specification The identifier of the specification to return all implementations of.
     *
     * @return All implementations implementing the first matching specification or {@code null}, if no such
     * specification is found or if the first matching specification does not have any implementations.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getModule()
     * @see #getSpecifications( java.lang.String )
     */
    public Implementations getImplementations( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        final Implementations implementations = new Implementations();

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getImplementations() != null )
            {
                for ( int j = 0, s1 = m.getImplementations().getImplementation().size(); j < s1; j++ )
                {
                    final Implementation impl = m.getImplementations().getImplementation().get( j );
                    final Specifications specs = this.getSpecifications( impl.getIdentifier() );

                    if ( specs != null && specs.getSpecification( specification ) != null )
                    {
                        implementations.getImplementation().add( impl );
                    }
                }
            }
        }

        return implementations.getImplementation().size() > 0 ? implementations : null;
    }

    /**
     * Merges this list of modules to a single module.
     *
     * @param name The name of the module to return.
     *
     * @return A module holding all model objects from the list.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     */
    public Module getMergedModule( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        final Modules copy = this.clone();
        final Module mergedModule = new Module();
        mergedModule.setName( name );

        for ( int i = 0, s0 = copy.getModule().size(); i < s0; i++ )
        {
            final Module m = copy.getModule().get( i );
            final java.util.Set<String> referencedMessages = new java.util.HashSet<String>();
            final java.util.Set<String> referencedProperties = new java.util.HashSet<String>();

            if ( m.getImplementations() != null )
            {
                for ( int j = 0, s1 = m.getImplementations().getImplementation().size(); j < s1; j++ )
                {
                    final Implementation impl = m.getImplementations().getImplementation().get( j );
                    if ( mergedModule.getImplementations() == null )
                    {
                        mergedModule.setImplementations( new Implementations() );
                    }

                    if ( impl.getMessages() != null && !impl.getMessages().getReference().isEmpty() )
                    {
                        for ( java.util.Iterator<MessageReference> it = impl.getMessages().getReference().iterator();
                              it.hasNext(); )
                        {
                            final String messageName = it.next().getName();
                            impl.getMessages().getMessage().add( m.getMessages().getMessage( messageName ) );
                            referencedMessages.add( messageName );
                            it.remove();
                        }
                    }

                    if ( impl.getProperties() != null && !impl.getProperties().getReference().isEmpty() )
                    {
                        for ( java.util.Iterator<PropertyReference> it = impl.getProperties().getReference().iterator();
                              it.hasNext(); )
                        {
                            final String propertyName = it.next().getName();
                            impl.getProperties().getProperty().add( m.getProperties().getProperty( propertyName ) );
                            referencedProperties.add( propertyName );
                            it.remove();
                        }
                    }

                    mergedModule.getImplementations().getImplementation().add( impl );
                }
            }

            if ( m.getSpecifications() != null )
            {
                if ( mergedModule.getSpecifications() == null )
                {
                    mergedModule.setSpecifications( new Specifications() );
                }

                for ( int j = 0, s1 = m.getSpecifications().getSpecification().size(); j < s1; j++ )
                {
                    final Specification s = m.getSpecifications().getSpecification().get( j );

                    if ( s.getProperties() != null && !s.getProperties().getReference().isEmpty() )
                    {
                        for ( java.util.Iterator<PropertyReference> it = s.getProperties().getReference().iterator();
                              it.hasNext(); )
                        {
                            final String propertyName = it.next().getName();
                            s.getProperties().getProperty().add( m.getProperties().getProperty( propertyName ) );
                            referencedProperties.add( propertyName );
                            it.remove();
                        }
                    }

                    mergedModule.getSpecifications().getSpecification().add( s );
                }
            }

            for ( String messageName : referencedMessages )
            {
                for ( java.util.Iterator<Message> it = m.getMessages().getMessage().iterator(); it.hasNext(); )
                {
                    if ( messageName.equals( it.next().getName() ) )
                    {
                        it.remove();
                        break;
                    }
                }
            }

            for ( String propertyName : referencedProperties )
            {
                for ( java.util.Iterator<Property> it = m.getProperties().getProperty().iterator(); it.hasNext(); )
                {
                    if ( propertyName.equals( it.next().getName() ) )
                    {
                        it.remove();
                        break;
                    }
                }
            }

            if ( m.getProperties() != null && !m.getProperties().getProperty().isEmpty() )
            {
                if ( mergedModule.getProperties() == null )
                {
                    mergedModule.setProperties( new Properties() );
                }

                mergedModule.getProperties().getProperty().addAll( m.getProperties().getProperty() );
            }

            if ( m.getMessages() != null && !m.getMessages().getMessage().isEmpty() )
            {
                if ( mergedModule.getMessages() == null )
                {
                    mergedModule.setMessages( new Messages() );
                }

                mergedModule.getMessages().getMessage().addAll( m.getMessages().getMessage() );
            }
        }

        return mergedModule;
    }

    /**
     * Gets the instance of an object from the list of modules.
     *
     * @param object The object to get the instance of.
     *
     * @return The instance of {@code object} or {@code null}, if no such instance is found.
     *
     * @throws NullPointerException if {@code object} is {@code null}.
     * @throws ModelObjectException if compiling a name of a referenced type to a {@code JavaTypeName} fails.
     *
     * @see #getModule()
     * @see #getImplementation( java.lang.Object )
     * @see #getInstance( java.lang.String )
     * @see #createObject(org.jomc.model.Instance instance, java.lang.ClassLoader classLoader)
     */
    public Instance getInstance( final Object object ) throws ModelObjectException
    {
        if ( object == null )
        {
            throw new NullPointerException( "object" );
        }

        synchronized ( this.objects )
        {
            Instance instance = this.objects.get( object );

            if ( instance == null )
            {
                final Implementation i = this.getImplementation( object );

                if ( i != null )
                {
                    instance = this.getInstance( i.getIdentifier() );
                    if ( instance != null )
                    {
                        this.objects.put( object, instance );
                    }
                }
            }

            return instance;
        }
    }

    /**
     * Gets an instance for an implementation from the list of modules.
     *
     * @param implementation The identifier of the implementation to get an instance for.
     *
     * @return A new instance for the first matching implementation or {@code null}, if no such implementation is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     * @see #getImplementation( java.lang.String )
     * @see #getDependencies(java.lang.String)
     * @see #getProperties(java.lang.String)
     * @see #getMessages(java.lang.String)
     * @see #getSpecifications(java.lang.String)
     * @see #getAnyObjects(java.lang.String)
     */
    public Instance getInstance( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Implementation i = this.getImplementation( implementation );

        if ( i != null && i.getClazz() != null )
        {
            final Instance instance = new Instance();
            instance.setIdentifier( i.getIdentifier() );
            instance.setName( i.getName() );
            instance.setClazz( i.getClazz() );
            instance.setStateless( i.isStateless() );
            instance.setDependencies( this.getDependencies( implementation ) );
            instance.setProperties( this.getProperties( implementation ) );
            instance.setMessages( this.getMessages( implementation ) );
            instance.setSpecifications( this.getSpecifications( implementation ) );
            instance.getAny().addAll( this.getAnyObjects( implementation ) );
            return instance;
        }

        return null;
    }

    /**
     * Gets an instance for an implementation from the list of modules overridden with a given dependency.
     *
     * @param implementation The identifier of the implementation to get an instance for.
     * @param dependency The dependency to use for overriding model objects of the instance.
     *
     * @return An instance for the first matching implementation with any model objects overridden using
     * {@code dependency} or {@code null}, if no such implementation is found.
     *
     * @throws NullPointerException if {@code implementation} or {@code dependency} is {@code null}.
     *
     * @see #getModule()
     * @see #getInstance( java.lang.String )
     */
    public Instance getInstance( final String implementation, final Dependency dependency )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }
        if ( dependency == null )
        {
            throw new NullPointerException( "dependency" );
        }

        Instance instance = this.getInstance( implementation );

        if ( instance != null )
        {
            final Specification dependencySpecification = this.getSpecification( dependency.getIdentifier() );

            if ( dependencySpecification != null && dependencySpecification.getScope() == null )
            {
                if ( dependency.getDependencies() != null && !dependency.getDependencies().getDependency().isEmpty() )
                {
                    final Dependencies dependencies = new Dependencies();
                    dependencies.getDependency().addAll( dependency.getDependencies().getDependency() );

                    if ( instance.getDependencies() != null )
                    {
                        for ( int i = 0, s0 = instance.getDependencies().getDependency().size(); i < s0; i++ )
                        {
                            final Dependency d = instance.getDependencies().getDependency().get( i );
                            final Dependency td = dependencies.getDependency( d.getName() );

                            if ( td == null )
                            {
                                dependencies.getDependency().add( d );
                            }
                            else
                            {
                                this.collectDependencies( d, td );
                            }
                        }
                    }

                    instance.setDependencies( dependencies );
                }

                if ( dependency.getMessages() != null && !dependency.getMessages().getMessage().isEmpty() )
                {
                    final Messages messages = new Messages();
                    messages.getMessage().addAll( dependency.getMessages().getMessage() );

                    if ( instance.getMessages() != null )
                    {
                        for ( int i = 0, s0 = instance.getMessages().getMessage().size(); i < s0; i++ )
                        {
                            final Message m = instance.getMessages().getMessage().get( i );

                            if ( messages.getMessage( m.getName() ) == null )
                            {
                                messages.getMessage().add( m );
                            }
                        }
                    }

                    instance.setMessages( messages );
                }

                if ( dependency.getProperties() != null && !dependency.getProperties().getProperty().isEmpty() )
                {
                    final Properties properties = new Properties();
                    properties.getProperty().addAll( dependency.getProperties().getProperty() );

                    if ( instance.getProperties() != null )
                    {
                        for ( int i = 0, s0 = instance.getProperties().getProperty().size(); i < s0; i++ )
                        {
                            final Property p = instance.getProperties().getProperty().get( i );

                            if ( properties.getProperty( p.getName() ) == null )
                            {
                                properties.getProperty().add( p );
                            }
                        }
                    }

                    instance.setProperties( properties );
                }
            }
        }

        return instance;
    }

    /**
     * Creates an object of a given instance from the list of modules.
     *
     * @param instance The instance to create an object of.
     * @param classLoader The class loader to use for creating the object or {@code null}, to use the bootstrap class
     * loader.
     *
     * @return A new object of {@code instance}.
     *
     * @throws NullPointerException if {@code instance}  is {@code null}.
     * @throws ModelObjectException if compiling the name of a referenced type to a {@code JavaTypeName} fails.
     * @throws InstantiationException if creating an object fails.
     *
     * @see #getModule()
     * @see Instance#getJavaClass(java.lang.ClassLoader)
     * @see Instance#getJavaConstructor(java.lang.ClassLoader)
     * @see Instance#getJavaFactoryMethodName()
     * @see Instance#getJavaFactoryMethod(java.lang.ClassLoader)
     * @see Instance#isJavaClassAssignable(java.lang.ClassLoader)
     */
    public Object createObject( final Instance instance, final ClassLoader classLoader )
        throws ModelObjectException, InstantiationException
    {
        if ( instance == null )
        {
            throw new NullPointerException( "instance" );
        }

        Object object = null;

        try
        {
            final java.lang.reflect.Constructor<?> ctor = instance.getJavaConstructor( classLoader );

            if ( ctor != null && instance.isJavaClassAssignable( classLoader ) )
            {
                object = instance.getJavaTypeName().getClass( classLoader, true ).newInstance();

                synchronized ( this.objects )
                {
                    this.objects.put( object, instance );
                }
            }
            else
            {
                java.lang.reflect.Method factoryMethod = instance.getJavaFactoryMethod( classLoader );

                if ( factoryMethod != null )
                {
                    if ( java.lang.reflect.Modifier.isStatic( factoryMethod.getModifiers() ) )
                    {
                        object = factoryMethod.invoke( null, (Object[]) null );

                        if ( object != null )
                        {
                            synchronized ( this.objects )
                            {
                                this.objects.put( object, instance );
                            }
                        }
                    }
                    else if ( ctor != null )
                    {
                        final Object o = ctor.newInstance();

                        synchronized ( this.objects )
                        {
                            this.objects.put( o, instance );
                        }

                        try
                        {
                            object = factoryMethod.invoke( o, (Object[]) null );
                        }
                        finally
                        {
                            synchronized ( this.objects )
                            {
                                this.objects.remove( o );

                                if ( object != null )
                                {
                                    this.objects.put( object, instance );
                                }
                            }
                        }
                    }
                }
            }

            if ( object == null )
            {
                throw new InstantiationException( getMessage(
                    instance.getJavaFactoryMethodName() != null
                    ? "failedCreatingObjectWithMethod" : "failedCreatingObject",
                    instance.getIdentifier(), instance.getJavaTypeName(), instance.getJavaFactoryMethodName() ) );

            }

            return object;
        }
        catch ( final java.lang.reflect.InvocationTargetException e )
        {
            final Throwable target = e.getTargetException() != null ? e.getTargetException() : e;
            throw (InstantiationException) new InstantiationException(
                getMessage( "exceptionCreatingObject", instance.getIdentifier() ) ).initCause( target );

        }
        catch ( final IllegalAccessException e )
        {
            throw (InstantiationException) new InstantiationException(
                getMessage( "exceptionCreatingObject", instance.getIdentifier() ) ).initCause( e );

        }
        catch ( final ClassNotFoundException e )
        {
            throw (InstantiationException) new InstantiationException(
                getMessage( "exceptionCreatingObject", instance.getIdentifier() ) ).initCause( e );

        }
    }

    /** @since 1.2 */
    private void collectModelObjects( final Implementation implementation, final Dependencies dependencies,
                                      final Messages messages, final Properties properties,
                                      final Specifications specifications, final List<Object> any,
                                      final java.util.Set<String> seen, final boolean includeDeclared )
    {
        if ( implementation != null && !seen.contains( implementation.getIdentifier() ) )
        {
            seen.add( implementation.getIdentifier() );

            if ( includeDeclared )
            {
                if ( dependencies != null && implementation.getDependencies() != null )
                {
                    for ( int i = 0, s0 = implementation.getDependencies().getDependency().size(); i < s0; i++ )
                    {
                        final Dependency d = implementation.getDependencies().getDependency().get( i );
                        final Dependency dependency = dependencies.getDependency( d.getName() );

                        if ( dependency == null )
                        {
                            dependencies.getDependency().add( d );
                        }
                        else
                        {
                            this.collectDependencies( d, dependency );
                        }
                    }
                }

                if ( messages != null && implementation.getMessages() != null )
                {
                    for ( int i = 0, s0 = implementation.getMessages().getMessage().size(); i < s0; i++ )
                    {
                        final Message msg = implementation.getMessages().getMessage().get( i );

                        if ( messages.getMessage( msg.getName() ) == null )
                        {
                            messages.getMessage().add( msg );
                        }
                    }

                    if ( !implementation.getMessages().getReference().isEmpty() )
                    {
                        final Module m = this.getModuleOfImplementation( implementation.getIdentifier() );

                        if ( m != null )
                        {
                            for ( int i = 0, s0 = implementation.getMessages().getReference().size(); i < s0; i++ )
                            {
                                final MessageReference ref = implementation.getMessages().getReference().get( i );

                                if ( messages.getMessage( ref.getName() ) == null )
                                {
                                    Message referenced = m.getMessages().getMessage( ref.getName() );
                                    if ( referenced != null )
                                    {
                                        referenced = referenced.clone();
                                        referenced.setDeprecated( ref.isDeprecated() );
                                        referenced.setFinal( ref.isFinal() );
                                        referenced.setOverride( ref.isOverride() );
                                        messages.getMessage().add( referenced );
                                    }
                                }
                            }
                        }
                    }
                }

                if ( properties != null && implementation.getProperties() != null )
                {
                    for ( int i = 0, s0 = implementation.getProperties().getProperty().size(); i < s0; i++ )
                    {
                        final Property p = implementation.getProperties().getProperty().get( i );

                        if ( properties.getProperty( p.getName() ) == null )
                        {
                            properties.getProperty().add( p );
                        }
                    }

                    if ( !implementation.getProperties().getReference().isEmpty() )
                    {
                        final Module m = this.getModuleOfImplementation( implementation.getIdentifier() );

                        if ( m != null )
                        {
                            for ( int i = 0, s0 = implementation.getProperties().getReference().size(); i < s0; i++ )
                            {
                                final PropertyReference ref = implementation.getProperties().getReference().get( i );

                                if ( properties.getProperty( ref.getName() ) == null )
                                {
                                    Property referenced = m.getProperties().getProperty( ref.getName() );
                                    if ( referenced != null )
                                    {
                                        referenced = referenced.clone();
                                        referenced.setDeprecated( ref.isDeprecated() );
                                        referenced.setFinal( ref.isFinal() );
                                        referenced.setOverride( ref.isOverride() );
                                        properties.getProperty().add( referenced );
                                    }
                                }
                            }
                        }
                    }
                }

                if ( specifications != null && implementation.getSpecifications() != null )
                {
                    for ( int i = 0, s0 = implementation.getSpecifications().getReference().size(); i < s0; i++ )
                    {
                        final SpecificationReference r = implementation.getSpecifications().getReference().get( i );

                        if ( specifications.getReference( r.getIdentifier() ) == null )
                        {
                            specifications.getReference().add( r );

                            final Specification s = this.getSpecification( r.getIdentifier() );
                            if ( s != null && specifications.getSpecification( s.getIdentifier() ) == null )
                            {
                                specifications.getSpecification().add( s );
                            }
                        }
                    }
                }

                if ( any != null && !implementation.getAny().isEmpty() )
                {
                    for ( int i = 0, s0 = implementation.getAny().size(); i < s0; i++ )
                    {
                        final Object o = implementation.getAny().get( i );

                        if ( o instanceof org.w3c.dom.Element )
                        {
                            if ( this.getElement( any, (org.w3c.dom.Element) o ) == null )
                            {
                                any.add( o );
                            }

                            continue;
                        }

                        if ( o instanceof javax.xml.bind.JAXBElement<?> )
                        {
                            if ( this.getElement( any, (javax.xml.bind.JAXBElement<?>) o ) == null )
                            {
                                any.add( o );
                            }

                            continue;
                        }

                        any.add( o );
                    }
                }
            }

            if ( implementation.getImplementations() != null )
            {
                for ( int i = 0, s0 = implementation.getImplementations().getReference().size(); i < s0; i++ )
                {
                    final ImplementationReference r = implementation.getImplementations().getReference().get( i );
                    this.collectModelObjects( this.getImplementation( r.getIdentifier() ), dependencies, messages,
                                              properties, specifications, any, seen, true );

                }
            }
        }
    }

    /** @since 1.2 */
    private void collectClassDeclarationModelObjects( final Implementation implementation,
                                                      final Dependencies dependencies, final Messages messages,
                                                      final Properties properties, final Specifications specifications,
                                                      final List<Object> any )
    {
        Implementation declaration = null;

        if ( implementation != null && implementation.getClazz() != null && !implementation.isClassDeclaration() )
        {
            for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
            {
                final Module m = this.getModule().get( i );

                if ( m.getImplementations() != null )
                {
                    for ( int j = 0, s1 = m.getImplementations().getImplementation().size(); j < s1; j++ )
                    {
                        final Implementation current = m.getImplementations().getImplementation().get( j );

                        if ( current.getClazz() != null && current.getClazz().equals( implementation.getClazz() )
                             && current.isClassDeclaration() )
                        {
                            declaration = current;
                            break;
                        }
                    }
                }
            }
        }

        if ( declaration != null )
        {
            this.collectModelObjects( declaration, dependencies, messages, properties, specifications, any,
                                      new java.util.HashSet<String>(), true );

        }
    }

    /** @since 1.2 */
    private void collectSpecifiedModelObjects( final Specifications specifications, final Properties properties )
    {
        for ( int i = 0, s0 = specifications.getSpecification().size(); i < s0; i++ )
        {
            final Specification s = specifications.getSpecification().get( i );

            if ( s.getProperties() != null )
            {
                for ( int j = 0, s1 = s.getProperties().getProperty().size(); j < s1; j++ )
                {
                    final Property p = s.getProperties().getProperty().get( j );

                    if ( properties.getProperty( p.getName() ) == null )
                    {
                        properties.getProperty().add( p );
                    }
                }
            }
        }
    }

    private void collectDependencies( final Dependency source, final Dependency target )
    {
        if ( source.getMessages() != null )
        {
            if ( target.getMessages() == null )
            {
                target.setMessages( new Messages() );
            }

            for ( int i = 0, s0 = source.getMessages().getMessage().size(); i < s0; i++ )
            {
                final Message m = source.getMessages().getMessage().get( i );

                if ( target.getMessages().getMessage( m.getName() ) == null )
                {
                    target.getMessages().getMessage().add( m );
                }
            }
        }

        if ( source.getProperties() != null )
        {
            if ( target.getProperties() == null )
            {
                target.setProperties( new Properties() );
            }

            for ( int i = 0, s0 = source.getProperties().getProperty().size(); i < s0; i++ )
            {
                final Property p = source.getProperties().getProperty().get( i );

                if ( target.getProperties().getProperty( p.getName() ) == null )
                {
                    target.getProperties().getProperty().add( p );
                }
            }
        }

        if ( source.getDependencies() != null )
        {
            if ( target.getDependencies() == null )
            {
                target.setDependencies( new Dependencies() );
            }

            for ( int i = 0, s0 = source.getDependencies().getDependency().size(); i < s0; i++ )
            {
                final Dependency sd = source.getDependencies().getDependency().get( i );
                final Dependency td = target.getDependencies().getDependency( sd.getName() );

                if ( td == null )
                {
                    target.getDependencies().getDependency().add( sd );
                }
                else
                {
                    this.collectDependencies( sd, td );
                }
            }
        }
    }

    private Implementation collectImplementation( final Class<?> clazz ) throws ModelObjectException
    {
        Implementation i = this.getImplementation( clazz );

        if ( i == null && clazz.getSuperclass() != null )
        {
            i = this.collectImplementation( clazz.getSuperclass() );
        }

        return i;
    }

    private org.w3c.dom.Element getElement( final List<Object> list, final org.w3c.dom.Element e )
    {
        for ( int i = 0, s0 = list.size(); i < s0; i++ )
        {
            final Object o = list.get( i );

            if ( o instanceof org.w3c.dom.Element )
            {
                final org.w3c.dom.Element current = (org.w3c.dom.Element) o;
                if ( ( e.getNamespaceURI() == null
                       ? current.getNamespaceURI() == null
                       : e.getNamespaceURI().equals( current.getNamespaceURI() ) )
                     && ( e.getLocalName() == null
                          ? current.getLocalName() == null
                          : e.getLocalName().equals( current.getLocalName() ) ) )
                {
                    return current;
                }
            }
        }

        return null;
    }

    private javax.xml.bind.JAXBElement<?> getElement( final List<Object> list, final javax.xml.bind.JAXBElement<?> e )
    {
        for ( int i = 0, s0 = list.size(); i < s0; i++ )
        {
            final Object o = list.get( i );

            if ( o instanceof javax.xml.bind.JAXBElement<?> )
            {
                final javax.xml.bind.JAXBElement<?> current = (javax.xml.bind.JAXBElement<?>) o;
                if ( e.getName().equals( current.getName() ) )
                {
                    return current;
                }
            }
        }

        return null;
    }

    private void resolveClasspath( final Module cpModule, final ClassLoader classLoader )
    {
        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getSpecifications() != null )
            {
                this.resolveClasspath( m.getSpecifications(), cpModule, classLoader );
            }

            if ( m.getImplementations() != null )
            {
                this.resolveClasspath( m.getImplementations(), cpModule, classLoader );
            }
        }
    }

    private void resolveClasspath( final SpecificationReference ref, final Module cpModule,
                                   final ClassLoader classLoader )
    {
        if ( this.getSpecification( ref.getIdentifier() ) == null )
        {
            this.resolveClasspath( ref.getIdentifier(), cpModule, classLoader );
        }
    }

    private void resolveClasspath( final Specifications specifications, final Module cpModule,
                                   final ClassLoader classLoader )
    {
        for ( int i = 0, s0 = specifications.getSpecification().size(); i < s0; i++ )
        {
            final Specification s = specifications.getSpecification().get( i );

            if ( s.getClazz() != null )
            {
                this.resolveClasspath( s, cpModule, classLoader );
            }
        }
        for ( int i = 0, s0 = specifications.getReference().size(); i < s0; i++ )
        {
            final SpecificationReference ref = specifications.getReference().get( i );
            this.resolveClasspath( ref, cpModule, classLoader );
        }
    }

    private void resolveClasspath( final Implementations implementations, final Module cpModule,
                                   final ClassLoader classLoader )
    {
        for ( int i = 0, s0 = implementations.getImplementation().size(); i < s0; i++ )
        {
            final Implementation implementation = implementations.getImplementation().get( i );

            if ( implementation.getSpecifications() != null )
            {
                this.resolveClasspath( implementation.getSpecifications(), cpModule, classLoader );
            }

            if ( implementation.getDependencies() != null )
            {
                this.resolveClasspath( implementation.getDependencies(), cpModule, classLoader );
            }
        }
    }

    private void resolveClasspath( final Dependencies dependencies, final Module cpModule,
                                   final ClassLoader classLoader )
    {
        for ( int i = 0, s0 = dependencies.getDependency().size(); i < s0; i++ )
        {
            final Dependency dependency = dependencies.getDependency().get( i );
            this.resolveClasspath( dependency, cpModule, classLoader );

            if ( dependency.getDependencies() != null )
            {
                this.resolveClasspath( dependency.getDependencies(), cpModule, classLoader );
            }
        }
    }

    private boolean resolveClasspath( final String identifier, final Module cpModule, final ClassLoader classLoader )
    {
        boolean classpathSpecification = false;
        Specification specification = cpModule.getSpecifications() == null
                                      ? null : cpModule.getSpecifications().getSpecification( identifier );

        if ( specification == null )
        {
            try
            {
                final org.jomc.jls.JavaTypeName javaTypeName = org.jomc.jls.JavaTypeName.parse( identifier );
                final Class<?> classpathSpec = javaTypeName.getClass( classLoader, false );

                if ( java.lang.reflect.Modifier.isPublic( classpathSpec.getModifiers() ) )
                {
                    classpathSpecification = true;
                    String vendor = null;
                    String version = null;

                    if ( classpathSpec.getPackage() != null )
                    {
                        vendor = classpathSpec.getPackage().getSpecificationVendor();
                        version = classpathSpec.getPackage().getSpecificationVersion();
                    }

                    specification = new Specification();
                    specification.setIdentifier( identifier );
                    specification.setClazz( javaTypeName.getName( true ) );
                    specification.setMultiplicity( Multiplicity.MANY );
                    specification.setVendor( vendor );
                    specification.setVersion( version );

                    if ( cpModule.getSpecifications() == null )
                    {
                        cpModule.setSpecifications( new Specifications() );
                    }

                    cpModule.getSpecifications().getSpecification().add( specification );

                    this.resolveClasspath( specification, cpModule, classLoader );
                }
            }
            catch ( final ClassNotFoundException e )
            {
                classpathSpecification = false;
            }
            catch ( final java.text.ParseException e )
            {
                classpathSpecification = false;
            }
        }

        return classpathSpecification;
    }

    private boolean resolveClasspath( final Specification specification, final Module cpModule,
                                      final ClassLoader classLoader )
    {
        boolean classpathImplementation = false;
        Implementation implementation =
            cpModule.getImplementations() == null ? null
            : cpModule.getImplementations().getImplementation( specification.getIdentifier() );

        if ( implementation == null )
        {
            implementation = this.getImplementation( specification.getIdentifier() );
        }

        if ( implementation == null )
        {
            String name = null;

            try
            {
                final org.jomc.jls.JavaTypeName javaTypeName =
                    org.jomc.jls.JavaTypeName.parse( specification.getClazz() );

                final Class<?> classpathImpl = javaTypeName.getClass( classLoader, false );

                if ( java.lang.reflect.Modifier.isPublic( classpathImpl.getModifiers() ) )
                {
                    if ( !java.lang.reflect.Modifier.isAbstract( classpathImpl.getModifiers() ) )
                    {
                        try
                        {
                            classpathImpl.getConstructor( NO_CLASSES );
                            name = "init";
                            classpathImplementation = true;
                        }
                        catch ( final NoSuchMethodException e )
                        {
                            classpathImplementation = false;
                        }
                    }

                    if ( !classpathImplementation )
                    {
                        final char[] c = classpathImpl.getName().substring(
                            classpathImpl.getPackage().getName().length() + 1 ).toCharArray();

                        name = String.valueOf( c );
                        c[0] = Character.toUpperCase( c[0] );

                        if ( this.checkFactoryMethod( classpathImpl, classpathImpl, "getDefault" ) )
                        {
                            name = "default";
                            classpathImplementation = true;
                        }
                        else if ( this.checkFactoryMethod( classpathImpl, classpathImpl, "getInstance" ) )
                        {
                            name = "instance";
                            classpathImplementation = true;
                        }
                        else if ( this.checkFactoryMethod( classpathImpl, classpathImpl, "get" + String.valueOf( c ) ) )
                        {
                            classpathImplementation = true;
                        }

                    }

                    if ( classpathImplementation
                         && this.getImplementation( specification.getIdentifier(), name ) == null )
                    {
                        String vendor = null;
                        String version = null;
                        if ( classpathImpl.getPackage() != null )
                        {
                            vendor = classpathImpl.getPackage().getImplementationVendor();
                            version = classpathImpl.getPackage().getImplementationVersion();
                        }

                        implementation = new Implementation();
                        implementation.setVendor( vendor );
                        implementation.setFinal( true );
                        implementation.setName( name );
                        implementation.setIdentifier( specification.getIdentifier() );
                        implementation.setClazz( javaTypeName.getName( true ) );
                        implementation.setVersion( version );

                        final Specifications implemented = new Specifications();
                        final SpecificationReference ref = new SpecificationReference();
                        ref.setIdentifier( specification.getIdentifier() );
                        ref.setVersion( specification.getVersion() );
                        implemented.getReference().add( ref );
                        implementation.setSpecifications( implemented );

                        if ( cpModule.getImplementations() == null )
                        {
                            cpModule.setImplementations( new Implementations() );
                        }

                        cpModule.getImplementations().getImplementation().add( implementation );
                    }
                }
            }
            catch ( final ClassNotFoundException e )
            {
                classpathImplementation = false;
            }
            catch ( final java.text.ParseException e )
            {
                classpathImplementation = false;
            }
        }

        return classpathImplementation;
    }

    private boolean checkFactoryMethod( final Class<?> clazz, final Class<?> type, final String methodName )
    {
        boolean factoryMethod = false;

        try
        {
            final java.lang.reflect.Method m = clazz.getMethod( methodName, (Class[]) null );
            factoryMethod = java.lang.reflect.Modifier.isStatic( m.getModifiers() )
                            && type.isAssignableFrom( m.getReturnType() );

        }
        catch ( final NoSuchMethodException e )
        {
            factoryMethod = false;
        }

        return factoryMethod;
    }

    private static String getMessage( final Throwable t )
    {
        return t != null
               ? t.getMessage() != null && t.getMessage().trim().length() > 0
                 ? t.getMessage()
                 : getMessage( t.getCause() )
               : null;

    }

    private static String getMessage( final String key, final Object... args )
    {
        return java.text.MessageFormat.format( java.util.ResourceBundle.getBundle(
            Modules.class.getName().replace( '.', '/' ), java.util.Locale.getDefault() ).
            getString( key ), args );

    }]]>
      </ci:code>
    </jaxb:bindings>
  </jaxb:bindings>
</jaxb:bindings>
