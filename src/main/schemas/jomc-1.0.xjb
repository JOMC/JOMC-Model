<?xml version="1.0" encoding="UTF-8"?>
<!--

  Copyright (c) 2009 The JOMC Project
  Copyright (c) 2005 Christian Schulte <cs@jomc.org>
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.

  THIS SOFTWARE IS PROVIDED BY THE JOMC PROJECT AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE JOMC PROJECT OR
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  $Id$

-->
<jaxb:bindings xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc"
               xmlns:jaxb="http://java.sun.com/xml/ns/jaxb"
               xmlns:xs="http://www.w3.org/2001/XMLSchema"
               xmlns:jomc="http://jomc.org/model"
               xmlns:ci="http://jaxb.dev.java.net/plugin/code-injector"
               jaxb:version="2.0">

  <jaxb:bindings schemaLocation="jomc-1.0.xsd">
    <jaxb:bindings node="xs:complexType[@name='Texts']">
      <ci:code><![CDATA[
    /**
     * Gets a text for a given language.
     *
     * @param language The language of the text to return.
     *
     * @return The text with language {@code language} or the default text, if
     * no text matching {@code language} is found.
     *
     * @throws NullPointerException if {@code language} is {@code null}.
     */
    public Text getText( final String language )
    {
        if ( language == null )
        {
            throw new NullPointerException( "language" );
        }

        Text defaultText = null;

        for ( Text t : this.getText() )
        {
            if ( t.getLanguage().equals( this.getDefaultLanguage() ) )
            {
                defaultText = t;
            }
            if ( t.getLanguage().equals( language ) )
            {
                return t;
            }
        }

        return defaultText;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specifications']">
      <ci:code><![CDATA[
    /**
     * Gets a specification for a given identifier from the list of
     * specifications.
     *
     * @param specification The identifier of the specification to return.
     *
     * @return The specification identified by {@code specification} from the
     * list or {@code null}, if no specification matching {@code specification}
     * is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getSpecification()
     */
    public Specification getSpecification( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( Specification s : this.getSpecification() )
        {
            if ( specification.equals( s.getIdentifier() ) )
            {
                return s;
            }
        }

        return null;
    }

    /**
     * Gets a specification reference for a given identifier from the list of
     * references.
     *
     * @param specification The identifier of the reference to return.
     *
     * @return The specification reference identified by {@code specification}
     * from the list or {@code null}, if no specification reference matching
     * {@code specification} is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getReference()
     */
    public SpecificationReference getReference( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( SpecificationReference r : this.getReference() )
        {
            if ( specification.equals( r.getIdentifier() ) )
            {
                return r;
            }
        }

        return null;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']">
      <ci:code><![CDATA[
    /**
     * Gets the location URI used for locating instances of this implementation.
     *
     * @return The location URI used for locating instances of this implementation or {@code null}, if instances of this
     * implementation do not need to be located.
     */
    public java.net.URI getLocationUri()
    {
        try
        {
            java.net.URI javaLocation = null;

            if ( this.getLocation() != null )
            {
                javaLocation = new java.net.URI( this.getLocation() );
            }

            return javaLocation;
        }
        catch ( java.net.URISyntaxException e )
        {
            throw new AssertionError( e );
        }
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementations']">
      <ci:code><![CDATA[
    /**
     * Gets an implementation for a given identifier from the list.
     *
     * @param implementation The identifier of the implementation to return.
     *
     * @return The implementation identified by {@code implementation} from the
     * list or {@code null}, if no implementation matching
     * {@code implementation} is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     */
    public Implementation getImplementation( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( Implementation i : this.getImplementation() )
        {
            if ( implementation.equals( i.getIdentifier() ) )
            {
                return i;
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given clazz from the list.
     *
     * @param implementation The class of the implementation to return.
     *
     * @return The implementation identified by {@code implementation} from the
     * list or {@code null}, if no implementation matching
     * {@code implementation} is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     */
    public Implementation getImplementation( final Class implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( Implementation i : this.getImplementation() )
        {
            if ( implementation.getName().equals( i.getIdentifier() ) &&
                 i.getIdentifier().equals( i.getClazz() ) )
            {
                return i;
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given name from the list.
     *
     * @param name The name of the implementation to return.
     *
     * @return The implementation named {@code name} from the list or
     * {@code null}, if no implementation matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     */
    public Implementation getImplementationByName( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( Implementation i : this.getImplementation() )
        {
            if ( name.equals( i.getName() ) )
            {
                return i;
            }
        }

        return null;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependencies']">
      <ci:code><![CDATA[
    /**
     * Gets a dependency for a given name from the list of dependencies.
     *
     * @param name The name of the dependency to return.
     *
     * @return The dependency with name {@code name} from the list or
     * {@code null}, if no dependency matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getDependency()
     */
    public Dependency getDependency( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "identifier" );
        }

        for ( Dependency d : this.getDependency() )
        {
            if ( name.equals( d.getName() ) )
            {
                return d;
            }
        }

        return null;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Properties']">
      <ci:code><![CDATA[
    /**
     * Gets a property for a given name from the list of properties.
     *
     * @param name The name of the property to return.
     *
     * @return The property with name {@code name} from the list or
     * {@code null}, if no property matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getProperty()
     */
    public Property getProperty( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( Property p : this.getProperty() )
        {
            if ( name.equals( p.getName() ) )
            {
                return p;
            }
        }

        return null;
    }

    /**
     * Gets a property reference for a given name from the list of references.
     *
     * @param name The name of the property reference to return.
     *
     * @return The property reference with name {@code name} from the list or
     * {@code null}, if no property reference matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getReference()
     */
    public PropertyReference getReference( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( PropertyReference r : this.getReference() )
        {
            if ( name.equals( r.getName() ) )
            {
                return r;
            }
        }

        return null;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']">
      <ci:code><![CDATA[
    /**
     * Gets the Java value of this property.
     *
     * @param classLoader The class loader to use for loading the Java class corresponding to the type of this property.
     *
     * @return The Java value of this property.
     *
     * @throws NullPointerException if {@code classLoader} is {@code null}.
     * @throws ClassNotFoundException if the Java class corresponding to the type of this property is not found.
     * @throws InstantiationException if instantiation of the value fails.
     */
    public Object getJavaValue( final ClassLoader classLoader ) throws ClassNotFoundException, InstantiationException
    {
        if ( classLoader == null )
        {
            throw new NullPointerException( "classLoader" );
        }

        if ( this.getAny() != null )
        {
            Object javaValue = this.getAny();
            if ( javaValue instanceof javax.xml.bind.JAXBElement )
            {
                javaValue = ( (javax.xml.bind.JAXBElement) javaValue ).getValue();
            }

            return javaValue;
        }

        Class javaType = String.class;
        if ( this.getType() != null )
        {
            if ( Boolean.TYPE.getName().equals( this.getType() ) )
            {
                javaType = Boolean.class;
            }
            else if ( Byte.TYPE.getName().equals( this.getType() ) )
            {
                javaType = Byte.class;
            }
            else if ( Character.TYPE.getName().equals( this.getType() ) )
            {
                javaType = Character.class;
            }
            else if ( Double.TYPE.getName().equals( this.getType() ) )
            {
                javaType = Double.class;
            }
            else if ( Float.TYPE.getName().equals( this.getType() ) )
            {
                javaType = Float.class;
            }
            else if ( Integer.TYPE.getName().equals( this.getType() ) )
            {
                javaType = Integer.class;
            }
            else if ( Long.TYPE.getName().equals( this.getType() ) )
            {
                javaType = Long.class;
            }
            else if ( Short.TYPE.getName().equals( this.getType() ) )
            {
                javaType = Short.class;
            }
            else
            {
                javaType = Class.forName( this.getType(), true, classLoader );
            }
        }

        try
        {
            final Object arg;
            final java.lang.reflect.Constructor ctor;

            if ( javaType == Character.class )
            {
                ctor = javaType.getConstructor( new Class[]
                    {
                        char.class
                    } );

                arg = new Character( this.getValue().charAt( 0 ) );
            }
            else
            {
                ctor = javaType.getConstructor( new Class[]
                    {
                        String.class
                    } );

                arg = this.getValue();
            }

            return ctor.newInstance( new Object[]
                {
                    arg
                } );

        }
        catch ( IllegalAccessException e )
        {
            throw (InstantiationException) new InstantiationException( e.getMessage() ).initCause( e );
        }
        catch ( java.lang.reflect.InvocationTargetException e )
        {
            throw (InstantiationException) new InstantiationException( e.getMessage() ).initCause( e );
        }
        catch ( NoSuchMethodException e )
        {
            throw (InstantiationException) new InstantiationException( e.getMessage() ).initCause( e );
        }
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Messages']">
      <ci:code><![CDATA[
    /**
     * Gets a message for a given name from the list of messages.
     *
     * @param name The name of the message to return.
     *
     * @return The message with name {@code name} from the list or {@code null},
     * if no message matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getMessage()
     */
    public Message getMessage( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( Message m : this.getMessage() )
        {
            if ( name.equals( m.getName() ) )
            {
                return m;
            }
        }

        return null;
    }

    /**
     * Gets a message reference for a given name from the list of references.
     *
     * @param name The name of the message reference to return.
     *
     * @return The message reference with name {@code name} from the list or
     * {@code null}, if no message reference matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getReference()
     */
    public MessageReference getReference( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( MessageReference r : this.getReference() )
        {
            if ( name.equals( r.getName() ) )
            {
                return r;
            }
        }

        return null;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Arguments']">
      <ci:code><![CDATA[
    /**
     * Gets an argument for a given name from the list of arguments.
     *
     * @param name The name of the argument to return.
     *
     * @return The argument with name {@code name} from the list or
     * {@code null}, if no argument matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getArgument()
     */
    public Argument getArgument( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( Argument a : this.getArgument() )
        {
            if ( name.equals( a.getName() ) )
            {
                return a;
            }
        }

        return null;
    }

    /**
     * Gets an argument for a given index from the list of arguments.
     *
     * @param index The index of the argument to return.
     *
     * @return The argument at {@code index} from the list.
     *
     * @throws IndexOutOfBoundsException if {@code index} is negative, greater
     * or equal to the size of the list of arguments.
     *
     * @see #getArgument()
     */
    public Argument getArgument( final int index )
    {
        if ( index < 0 || index >= this.getArgument().size() )
        {
            throw new IndexOutOfBoundsException( Integer.toString( index ) );
        }

        for ( Argument a : this.getArgument() )
        {
            if ( index == a.getIndex() )
            {
                return a;
            }
        }

        return null;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instances']">
      <ci:code><![CDATA[
    /**
     * Gets an instance for a given identifier from the list of instances.
     *
     * @param identifier The identifier of the instance to return.
     *
     * @return The instance identified by {@code identifier} from the list or
     * {@code null}, if no instance matching {@code identifier} is found.
     *
     * @throws NullPointerException if {@code identifier} is {@code null}.
     *
     * @see #getInstance()
     */
    public Instance getInstance( final String identifier )
    {
        if ( identifier == null )
        {
            throw new NullPointerException( "identifier" );
        }

        for ( Instance i : this.getInstance() )
        {
            if ( i.getIdentifier().equals( identifier ) )
            {
                return i;
            }
        }

        return null;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']">
      <ci:code><![CDATA[
    /** Maps dependency names to dependency objects. */
    @javax.xml.bind.annotation.XmlTransient private java.util.Map<String, Object> dependencyObjects;

    /** Maps property names to property objects. */
    @javax.xml.bind.annotation.XmlTransient private java.util.Map<String, Object> propertyObjects;

    /** The classloader of the instance. */
    @javax.xml.bind.annotation.XmlTransient private ClassLoader classLoader;

    /**
     * Gets the classloader of the instance.
     *
     * @return The classloader of the instance.
     */
    public ClassLoader getClassLoader()
    {
        return this.classLoader;
    }

    /**
     * Sets the classloader of the instance.
     *
     * @param value The new classloader of the instance.
     */
    public void setClassLoader( final ClassLoader value )
    {
        this.classLoader = value;
    }

    /**
     * Gets a mapping of dependency names to objects bound to the instance.
     *
     * @return A mapping of dependency names to objects bound to the instance.
     */
    public java.util.Map<String, Object> getDependencyObjects()
    {
        if ( this.dependencyObjects == null )
        {
            this.dependencyObjects = new java.util.HashMap<String, Object>();
        }

        return this.dependencyObjects;
    }

    /**
     * Gets a mapping of property names to objects bound to the instance.
     *
     * @return A mapping of property names to objects bound to the instance.
     */
    public java.util.Map<String, Object> getPropertyObjects()
    {
        if ( this.propertyObjects == null )
        {
            this.propertyObjects = new java.util.HashMap<String, Object>();
        }

        return this.propertyObjects;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Modules']">
      <ci:code><![CDATA[
    /**
     * Gets a module for a given name from this list of modules.
     *
     * @param name The name of the module to return.
     *
     * @return The module with name {@code name} from the list or {@code null},
     * if no module matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getModule()
     */
    public Module getModule( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getName().equals( name ) )
            {
                return m;
            }
        }

        return null;
    }

    /**
     * Gets all specifications declared in this list of modules.
     *
     * @return All specifications declared in the list or {@code null}, if no
     * specifications are declared.
     *
     * @see #getModule()
     */
    public Specifications getSpecifications()
    {
        final Specifications specifications = new Specifications();
        for ( Module m : this.getModule() )
        {
            if ( m.getSpecifications() != null )
            {
                specifications.getSpecification().addAll( m.getSpecifications().getSpecification() );
            }
        }

        return specifications.getSpecification().isEmpty() ? null : specifications;
    }

    /**
     * Gets all implementations declared in this list of modules.
     *
     * @return All implementations declared in the list or {@code null}, if no
     * implementations are declared.
     *
     * @see #getModule()
     */
    public Implementations getImplementations()
    {
        final Implementations implementations = new Implementations();
        for ( Module m : this.getModule() )
        {
            if ( m.getImplementations() != null )
            {
                implementations.getImplementation().addAll( m.getImplementations().getImplementation() );
            }
        }

        return implementations.getImplementation().isEmpty() ? null : implementations;
    }

    /**
     * Gets the module declaring a given specification from this list of modules.
     *
     * @param specification The identifier of the specification whose declaring module to return.
     *
     * @return The module declaring {@code specification} from the list or {@code null}, if no module
     * is found declaring {@code specification}.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getModule()
     */
    public Module getModuleOfSpecification( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getSpecifications() != null )
            {
                for ( Specification s : m.getSpecifications().getSpecification() )
                {
                    if ( specification.equals( s.getIdentifier() ) )
                    {
                        return m;
                    }
                }
            }
        }

        return null;
    }

    /**
     * Gets the module declaring a given implementation from this list of modules.
     *
     * @param implementation The identifier of the implementation whose declaring module to return.
     *
     * @return The module declaring {@code implementation} from the list or {@code null}, if no module
     * is found declaring {@code implementation}.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Module getModuleOfImplementation( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getImplementations() != null )
            {
                for ( Implementation i : m.getImplementations().getImplementation() )
                {
                    if ( implementation.equals( i.getIdentifier() ) )
                    {
                        return m;
                    }
                }
            }
        }

        return null;
    }

    /**
     * Gets a specification for a given identifier from this list of modules.
     *
     * @param specification The identifier of the specification to return.
     *
     * @return The specification identified by {@code specification} from the list or {@code null},
     * if no specification matching {@code specification} is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getModule()
     */
    public Specification getSpecification( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getSpecifications() != null )
            {
                final Specification s = m.getSpecifications().getSpecification( specification );
                if ( s != null )
                {
                    return s;
                }
            }
        }

        return null;
    }

    /**
     * Gets all specifications an implementation implements from this list of modules.
     *
     * @param implementation The identifier of the implementation to get all implemented specifications of.
     *
     * @return List of all specifications implemented by {@code implementation} from the list or {@code null}, if no
     * implementation matching {@code implementation} is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Specifications getSpecifications( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Specifications specs = new Specifications();
        this.collectSpecifications( implementation, specs );
        return specs.getSpecification().isEmpty() && specs.getReference().isEmpty() ? null : specs;
    }

    private void collectSpecifications( final String implementation, final Specifications specifications )
    {
        final Implementation i = this.getImplementation( implementation );

        if ( i != null )
        {
            if ( i.getParent() != null )
            {
                this.collectSpecifications( i.getParent(), specifications );
            }

            if ( i.getSpecifications() != null )
            {
                for ( SpecificationReference r : i.getSpecifications().getReference() )
                {
                    if ( specifications.getReference( r.getIdentifier() ) == null )
                    {
                        specifications.getReference().add( r );

                        final Specification s = this.getSpecification( r.getIdentifier() );
                        if ( s != null && specifications.getSpecification( s.getIdentifier() ) == null )
                        {
                            specifications.getSpecification().add( s );
                        }
                    }
                }
            }
        }
    }

    /**
     * Gets an implementation for a given identifier from this list of modules.
     *
     * @param implementation The identifier of the implementation to return.
     *
     * @return The implementation identified by {@code implementation} from the list or {@code null},
     * if no implementation matching {@code implementation} is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Implementation getImplementation( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getImplementations() != null )
            {
                final Implementation i = m.getImplementations().getImplementation( implementation );
                if ( i != null )
                {
                    return i;
                }
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given class from this list of modules.
     *
     * @param implementation The class of the implementation to return.
     *
     * @return The implementation identified by {@code implementation} from the list or {@code null},
     * if no implementation matching {@code implementation} is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Implementation getImplementation( final Class implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getImplementations() != null )
            {
                final Implementation i = m.getImplementations().getImplementation( implementation );
                if ( i != null )
                {
                    return i;
                }
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given name implementing a given specification from this list of
     * modules.
     *
     * @param specification The identifier of the specification to return an implementation of.
     * @param name The name of the implementation to return.
     *
     * @return The implementation with name {@code name} implementing the specification identified by
     * {@code specification} from the list or {@code null}, if no such implementation is found.
     *
     * @throws NullPointerException if {@code specification} or {@code name} is {@code null}.
     *
     * @see #getModule()
     */
    public Implementation getImplementation( final String specification, final String name )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        final Implementations implementations = this.getImplementations( specification );
        if ( implementations != null )
        {
            return implementations.getImplementationByName( name );
        }

        return null;
    }

    /**
     * Gets all dependencies of an implementation from this list of modules.
     *
     * @param implementation The identifier of the implementation to get all dependencies of.
     *
     * @return List of all dependencies of {@code implementation} from the list or {@code null},
     * if no dependencies are found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Dependencies getDependencies( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Dependencies dependencies = new Dependencies();
        this.collectDependencies( implementation, dependencies );
        java.util.Collections.sort( dependencies.getDependency(), new java.util.Comparator<Dependency>()
        {

            public int compare( final Dependency o1, final Dependency o2 )
            {
                return o1.getName().compareTo( o2.getName() );
            }

        } );

        return dependencies.getDependency().isEmpty() ? null : dependencies;
    }

    private void collectDependencies( final String implementation, final Dependencies dependencies )
    {
        final Implementation i = this.getImplementation( implementation );

        if ( i != null )
        {
            if ( i.getDependencies() != null )
            {
                for ( Dependency d : i.getDependencies().getDependency() )
                {
                    if ( dependencies.getDependency( d.getName() ) == null )
                    {
                        dependencies.getDependency().add( d );
                    }
                }
            }

            if ( i.getParent() != null )
            {
                this.collectDependencies( i.getParent(), dependencies );
            }
        }
    }

    /**
     * Gets all properties of an implementation from this list of modules.
     *
     * @param implementation The identifier of the implementation to get all properties of.
     *
     * @return List of all properties of {@code implementation} from the list or {@code null},
     * if no properties are found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Properties getProperties( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Properties properties = new Properties();
        this.collectProperties( implementation, properties );
        final Properties specified = this.getSpecifiedProperties( implementation );

        if ( properties != null && specified != null )
        {
            for ( Property p : specified.getProperty() )
            {
                if ( properties.getProperty( p.getName() ) == null )
                {
                    properties.getProperty().add( p );
                }
            }
        }

        java.util.Collections.sort( properties.getProperty(), new java.util.Comparator<Property>()
        {

            public int compare( final Property o1, final Property o2 )
            {
                return o1.getName().compareTo( o2.getName() );
            }

        } );

        return properties.getProperty().isEmpty() ? null : properties;
    }

    private void collectProperties( final String implementation, final Properties properties )
    {
        final Implementation i = this.getImplementation( implementation );

        if ( i != null )
        {
            if ( i.getProperties() != null )
            {
                for ( Property p : i.getProperties().getProperty() )
                {
                    if ( properties.getProperty( p.getName() ) == null )
                    {
                        properties.getProperty().add( p );
                    }
                }
                if ( !i.getProperties().getReference().isEmpty() )
                {
                    final Module m = this.getModuleOfImplementation( i.getIdentifier() );

                    if ( m != null )
                    {
                        for ( PropertyReference ref : i.getProperties().getReference() )
                        {
                            if ( properties.getProperty( ref.getName() ) == null )
                            {
                                properties.getProperty().add( m.getProperties().getProperty( ref.getName() ) );
                            }
                        }
                    }
                }
            }

            if ( i.getParent() != null )
            {
                this.collectProperties( i.getParent(), properties );
            }
        }
    }

    /**
     * Gets all properties specified for an implementation from this list of modules.
     *
     * @param implementation The identifier of the implementation to return specified properties of.
     *
     * @return List of all properties specified for {@code implementation} from the list or {@code null},
     * if no properties are found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Properties getSpecifiedProperties( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Properties properties = new Properties();
        final Specifications specs = this.getSpecifications( implementation );

        if ( specs != null )
        {
            for ( Specification s : specs.getSpecification() )
            {
                if ( s.getProperties() != null )
                {
                    properties.getProperty().addAll( s.getProperties().getProperty() );
                }
            }
        }

        java.util.Collections.sort( properties.getProperty(), new java.util.Comparator<Property>()
        {

            public int compare( final Property o1, final Property o2 )
            {
                return o1.getName().compareTo( o2.getName() );
            }

        } );

        return properties.getProperty().isEmpty() ? null : properties;
    }

    /**
     * Gets all messages of an implementation from this list of modules.
     *
     * @param implementation The identifier of the implementation to get all messages of.
     *
     * @return List of messages of {@code implementation} from the list or {@code null},
     * if no messages are found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Messages getMessages( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Messages msgs = new Messages();
        this.collectMessages( implementation, msgs );

        java.util.Collections.sort( msgs.getMessage(), new java.util.Comparator<Message>()
        {

            public int compare( final Message o1, final Message o2 )
            {
                return o1.getName().compareTo( o2.getName() );
            }

        } );

        return msgs.getMessage().isEmpty() ? null : msgs;
    }

    private void collectMessages( final String implementation, final Messages messages )
    {
        final Implementation i = this.getImplementation( implementation );

        if ( i != null )
        {
            if ( i.getMessages() != null )
            {
                for ( Message msg : i.getMessages().getMessage() )
                {
                    if ( messages.getMessage( msg.getName() ) == null )
                    {
                        messages.getMessage().add( msg );
                    }
                }
                if ( !i.getMessages().getReference().isEmpty() )
                {
                    final Module m = this.getModuleOfImplementation( i.getIdentifier() );

                    if ( m != null )
                    {
                        for ( MessageReference ref : i.getMessages().getReference() )
                        {
                            if ( messages.getMessage( ref.getName() ) == null )
                            {
                                messages.getMessage().add( m.getMessages().getMessage( ref.getName() ) );
                            }
                        }
                    }
                }
            }

            if ( i.getParent() != null )
            {
                this.collectMessages( i.getParent(), messages );
            }
        }
    }

    /**
     * Gets all implementations implementing a given specification from this list of modules.
     *
     * @param specification The identifier of the specification to return implementations of.
     *
     * @return All implementations implementing the specification identified by {@code specification}
     * from the list or {@code null}, if no implementation implementing {@code specification} is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getModule()
     */
    public Implementations getImplementations( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        final Implementations implementations = new Implementations();
        for ( Module m : this.getModule() )
        {
            if ( m.getImplementations() != null )
            {
                for ( Implementation i : m.getImplementations().getImplementation() )
                {
                    final Specifications specs = this.getSpecifications( i.getIdentifier() );

                    if ( specs != null )
                    {
                        for ( Specification s : specs.getSpecification() )
                        {
                            if ( specification.equals( s.getIdentifier() ) )
                            {
                                implementations.getImplementation().add( i );
                            }
                        }
                    }
                }
            }
        }

        return implementations.getImplementation().size() > 0 ? implementations : null;
    }

    /**
     * Merges this list of modules to a single module.
     *
     * @return A module holding all model objects from the list.
     */
    public Module getMergedModule()
    {
        final Modules copy = this.clone();
        final Module mergedModule = new Module();

        for ( Module module : copy.getModule() )
        {
            final java.util.Set<String> referencedMessages = new java.util.HashSet<String>();
            final java.util.Set<String> referencedProperties = new java.util.HashSet<String>();

            if ( module.getImplementations() != null )
            {
                for ( Implementation i : module.getImplementations().getImplementation() )
                {
                    if ( mergedModule.getImplementations() == null )
                    {
                        mergedModule.setImplementations( new Implementations() );
                    }

                    if ( i.getMessages() != null && !i.getMessages().getReference().isEmpty() )
                    {
                        for ( java.util.Iterator<MessageReference> it = i.getMessages().getReference().iterator();
                              it.hasNext(); )
                        {
                            final String messageName = it.next().getName();
                            i.getMessages().getMessage().add( module.getMessages().getMessage( messageName ) );
                            referencedMessages.add( messageName );
                            it.remove();
                        }
                    }

                    if ( i.getProperties() != null && !i.getProperties().getReference().isEmpty() )
                    {
                        for ( java.util.Iterator<PropertyReference> it = i.getProperties().getReference().iterator();
                              it.hasNext(); )
                        {
                            final String propertyName = it.next().getName();
                            i.getProperties().getProperty().add(
                                module.getProperties().getProperty( propertyName ) );

                            referencedProperties.add( propertyName );
                            it.remove();
                        }
                    }

                    mergedModule.getImplementations().getImplementation().add( i );
                }
            }

            if ( module.getSpecifications() != null )
            {
                if ( mergedModule.getSpecifications() == null )
                {
                    mergedModule.setSpecifications( new Specifications() );
                }

                for ( Specification s : module.getSpecifications().getSpecification() )
                {
                    if ( s.getProperties() != null && !s.getProperties().getReference().isEmpty() )
                    {
                        for ( java.util.Iterator<PropertyReference> it = s.getProperties().getReference().iterator();
                              it.hasNext(); )
                        {
                            final String propertyName = it.next().getName();
                            s.getProperties().getProperty().add(
                                module.getProperties().getProperty( propertyName ) );

                            referencedProperties.add( propertyName );
                            it.remove();
                        }
                    }

                    mergedModule.getSpecifications().getSpecification().add( s );
                }
            }

            for ( String messageName : referencedMessages )
            {
                for ( java.util.Iterator<Message> it = module.getMessages().getMessage().iterator(); it.hasNext(); )
                {
                    if ( messageName.equals( it.next().getName() ) )
                    {
                        it.remove();
                        break;
                    }
                }
            }

            for ( String propertyName : referencedProperties )
            {
                for ( java.util.Iterator<Property> it = module.getProperties().getProperty().iterator(); it.hasNext(); )
                {
                    if ( propertyName.equals( it.next().getName() ) )
                    {
                        it.remove();
                        break;
                    }
                }
            }

            if ( module.getProperties() != null && !module.getProperties().getProperty().isEmpty() )
            {
                if ( mergedModule.getProperties() == null )
                {
                    mergedModule.setProperties( new Properties() );
                }

                mergedModule.getProperties().getProperty().addAll( module.getProperties().getProperty() );
            }

            if ( module.getMessages() != null && !module.getMessages().getMessage().isEmpty() )
            {
                if ( mergedModule.getMessages() == null )
                {
                    mergedModule.setMessages( new Messages() );
                }

                mergedModule.getMessages().getMessage().addAll( module.getMessages().getMessage() );
            }
        }

        return mergedModule;
    }
]]></ci:code>
    </jaxb:bindings>
  </jaxb:bindings>
</jaxb:bindings>
