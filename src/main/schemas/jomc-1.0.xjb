<?xml version="1.0" encoding="UTF-8"?>
<!--

  Copyright (c) 2009 The JOMC Project
  Copyright (c) 2005 Christian Schulte <cs@jomc.org>
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.

  THIS SOFTWARE IS PROVIDED BY THE JOMC PROJECT AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE JOMC PROJECT OR
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  $Id$

-->
<jaxb:bindings xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc"
               xmlns:jaxb="http://java.sun.com/xml/ns/jaxb"
               xmlns:xs="http://www.w3.org/2001/XMLSchema"
               xmlns:jomc="http://jomc.org/model"
               xmlns:ci="http://jaxb.dev.java.net/plugin/code-injector"
               jaxb:version="2.0">

  <jaxb:bindings schemaLocation="jomc-1.0.xsd">
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Text']/xs:simpleContent/xs:extension/xs:attribute[@name='language']">
      <jaxb:property>
        <jaxb:javadoc>The language key of this text.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Texts']">
      <ci:code><![CDATA[
    /**
     * Gets a text for a given language.
     *
     * @param language The language of the text to return.
     *
     * @return The text with language {@code language} or the default text, if
     * no text matching {@code language} is found.
     *
     * @throws NullPointerException if {@code language} is {@code null}.
     */
    public Text getText( final String language )
    {
        if ( language == null )
        {
            throw new NullPointerException( "language" );
        }

        Text defaultText = null;

        for ( Text t : this.getText() )
        {
            if ( t.getLanguage().equals( this.getDefaultLanguage() ) )
            {
                defaultText = t;
            }
            if ( t.getLanguage().equals( language ) )
            {
                return t;
            }
        }

        return defaultText;
    }
]]>
      </ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Texts']/xs:attribute[@name='defaultLanguage']">
      <jaxb:property>
        <jaxb:javadoc>Default text of this list.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='ModelObject']/xs:sequence/xs:element[@ref='jomc:documentation']">
      <jaxb:property>
        <jaxb:javadoc>Documentation of this object or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ModelObject']/xs:sequence/xs:element[@ref='jomc:authors']">
      <jaxb:property>
        <jaxb:javadoc>Authors of this object or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ModelObject']/xs:attribute[@name='modelVersion']">
      <jaxb:property>
        <jaxb:javadoc>Model version of this object.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ModelObject']/xs:attribute[@name='createDate']">
      <jaxb:property>
        <jaxb:javadoc>The date this object got created or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ModelObject']/xs:attribute[@name='deprecated']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this object is deprecated.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:specifications']">
      <jaxb:property>
        <jaxb:javadoc>Specifications of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:implementations']">
      <jaxb:property>
        <jaxb:javadoc>Implementations of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:properties']">
      <jaxb:property>
        <jaxb:javadoc>Properties of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:messages']">
      <jaxb:property>
        <jaxb:javadoc>Messages of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>Name of this module.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>Version of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:attribute[@name='vendor']">
      <jaxb:property>
        <jaxb:javadoc>Vendor of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Specifications']">
      <ci:code><![CDATA[
    /**
     * Gets a specification for a given identifier from the list of
     * specifications.
     *
     * @param specification The identifier of the specification to return.
     *
     * @return The specification identified by {@code specification} from the
     * list or {@code null}, if no specification matching {@code specification}
     * is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getSpecification()
     */
    public Specification getSpecification( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( Specification s : this.getSpecification() )
        {
            if ( specification.equals( s.getIdentifier() ) )
            {
                return s;
            }
        }

        return null;
    }

    /**
     * Gets a specification for a given class from the list of specifications.
     *
     * @param specification The class of the specification to return.
     *
     * @return The specification identified by {@code specification} from the list or {@code null}, if no specification
     * matching {@code specification} is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getSpecification()
     */
    public Specification getSpecification( final Class specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( Specification s : this.getSpecification() )
        {
            if ( s.isClassDeclaration() && specification.getName().equals( s.getClazz() ) )
            {
                return s;
            }
        }

        return null;
    }

    /**
     * Gets a specification reference for a given identifier from the list of
     * references.
     *
     * @param specification The identifier of the reference to return.
     *
     * @return The specification reference identified by {@code specification}
     * from the list or {@code null}, if no specification reference matching
     * {@code specification} is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getReference()
     */
    public SpecificationReference getReference( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( SpecificationReference r : this.getReference() )
        {
            if ( specification.equals( r.getIdentifier() ) )
            {
                return r;
            }
        }

        return null;
    }
]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:properties']">
      <jaxb:property>
        <jaxb:javadoc>Properties of this specification or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='identifier']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of this specification.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='class']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of the class providing the programming interface of this specification or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='vendor']">
      <jaxb:property>
        <jaxb:javadoc>The vendor of this specification or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>The version of this specification or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='multiplicity']">
      <jaxb:property>
        <jaxb:javadoc>The implementation multiplicity of this specification. A multiplicity equal to {@link Multiplicity#ONE} specifies that no more than one implementation of the specification is allowed to exist among a set of modules (including none). A multiplicity equal to {@link Multiplicity#MANY} specifies that many implementations are allowed to exist among a set of modules (including none).</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='scope']">
      <jaxb:property>
        <jaxb:javadoc>Scope instances of implementations of this specification apply to or {@code null} if instances of implementations of this specification are not bound to any scope (multiton).</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='classDeclaration']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this specification declares the class given by property {@code clazz}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='SpecificationReference']/xs:complexContent/xs:extension/xs:attribute[@name='identifier']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of the referenced specification.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='SpecificationReference']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>The version of the referenced specification or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='SpecificationReference']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this specification reference is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='SpecificationReference']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this specification reference is intended to override a super specification reference.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Implementations']">
      <ci:code><![CDATA[
    /**
     * Gets an implementation for a given identifier from the list.
     *
     * @param implementation The identifier of the implementation to return.
     *
     * @return The implementation identified by {@code implementation} from the
     * list or {@code null}, if no implementation matching
     * {@code implementation} is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getImplementation()
     */
    public Implementation getImplementation( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( Implementation i : this.getImplementation() )
        {
            if ( implementation.equals( i.getIdentifier() ) )
            {
                return i;
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given class from the list.
     *
     * @param implementation The class of the implementation to return.
     *
     * @return The implementation identified by {@code implementation} from the
     * list or {@code null}, if no implementation matching
     * {@code implementation} is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getImplementation()
     */
    public Implementation getImplementation( final Class implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( Implementation i : this.getImplementation() )
        {
            if ( i.isClassDeclaration() && implementation.getName().equals( i.getClazz() ) )
            {
                return i;
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given name from the list.
     *
     * @param name The name of the implementation to return.
     *
     * @return The implementation named {@code name} from the list or
     * {@code null}, if no implementation matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getImplementation()
     */
    public Implementation getImplementationByName( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( Implementation i : this.getImplementation() )
        {
            if ( name.equals( i.getName() ) )
            {
                return i;
            }
        }

        return null;
    }

    /**
     * Gets an implementation reference for a given identifier from the list of
     * references.
     *
     * @param implementation The identifier of the reference to return.
     *
     * @return The implementation reference identified by {@code implementation}
     * from the list or {@code null}, if no implementation reference matching
     * {@code implementation} is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getReference()
     */
    public ImplementationReference getReference( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( ImplementationReference r : this.getReference() )
        {
            if ( implementation.equals( r.getIdentifier() ) )
            {
                return r;
            }
        }

        return null;
    }
]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:specifications']">
      <jaxb:property>
        <jaxb:javadoc>References to specifications implemented by this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:implementations']">
      <jaxb:property>
        <jaxb:javadoc>References to implementations this implementation inherits from or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:dependencies']">
      <jaxb:property>
        <jaxb:javadoc>Dependencies of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:properties']">
      <jaxb:property>
        <jaxb:javadoc>Properties of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:messages']">
      <jaxb:property>
        <jaxb:javadoc>Messages of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='identifier']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of this implementation.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>The name of this implementation.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='class']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of the class providing instances of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='location']">
      <jaxb:property>
        <jaxb:javadoc>An URI of the location providing instances of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='vendor']">
      <jaxb:property>
        <jaxb:javadoc>The vendor of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>The version of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this implementation is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='stateless']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if instances of this implementation do not retain state across operations.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='abstract']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this implementation is abstract.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='classDeclaration']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this implementation declares the class given by property {@code clazz}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']">
      <ci:code><![CDATA[
    /**
     * Gets the location URI used for locating instances of this implementation.
     *
     * @return The location URI used for locating instances of this implementation or {@code null}, if instances of this
     * implementation do not need to be located.
     *
     * @see #getLocation()
     */
    public java.net.URI getLocationUri()
    {
        try
        {
            java.net.URI javaLocation = null;

            if ( this.getLocation() != null )
            {
                javaLocation = new java.net.URI( this.getLocation() );
            }

            return javaLocation;
        }
        catch ( final java.net.URISyntaxException e )
        {
            throw new AssertionError( e );
        }
    }
]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='ImplementationReference']/xs:complexContent/xs:extension/xs:attribute[@name='identifier']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of the referenced implementation.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ImplementationReference']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>The version of the referenced implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ImplementationReference']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this implementation reference is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ImplementationReference']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this implementation reference is intended to override a super implementation reference.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Dependencies']">
      <ci:code><![CDATA[
    /**
     * Gets a dependency for a given name from the list of dependencies.
     *
     * @param name The name of the dependency to return.
     *
     * @return The dependency with name {@code name} from the list or
     * {@code null}, if no dependency matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getDependency()
     */
    public Dependency getDependency( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "identifier" );
        }

        for ( Dependency d : this.getDependency() )
        {
            if ( name.equals( d.getName() ) )
            {
                return d;
            }
        }

        return null;
    }
]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:properties']">
      <jaxb:property>
        <jaxb:javadoc>Properties of this dependency or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:attribute[@name='implementationName']">
      <jaxb:property>
        <jaxb:javadoc>Name of the selected implementation of the specification of this dependency or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>Name of this dependency.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:attribute[@name='bound']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if instances of this dependency are bound to the declaring implementation.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:attribute[@name='optional']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this dependency is optional.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Properties']">
      <ci:code><![CDATA[
    /**
     * Gets a property for a given name from the list of properties.
     *
     * @param name The name of the property to return.
     *
     * @return The property with name {@code name} from the list or
     * {@code null}, if no property matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getProperty()
     */
    public Property getProperty( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( Property p : this.getProperty() )
        {
            if ( name.equals( p.getName() ) )
            {
                return p;
            }
        }

        return null;
    }

    /**
     * Gets a property reference for a given name from the list of references.
     *
     * @param name The name of the property reference to return.
     *
     * @return The property reference with name {@code name} from the list or
     * {@code null}, if no property reference matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getReference()
     */
    public PropertyReference getReference( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( PropertyReference r : this.getReference() )
        {
            if ( name.equals( r.getName() ) )
            {
                return r;
            }
        }

        return null;
    }
]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:sequence/xs:any">
      <jaxb:property>
        <jaxb:javadoc>Object value of this property or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>Name of this property.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:attribute[@name='type']">
      <jaxb:property>
        <jaxb:javadoc>Type of this property or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:attribute[@name='value']">
      <jaxb:property>
        <jaxb:javadoc>String value of this property or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this property is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this property is intended to override a super property.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']">
      <ci:code><![CDATA[
    /**
     * Gets the Java value of the property.
     * <p>The Java value of the property is computed based on the following rules:
     * <ol>
     * <li>If property {@code any} is set, the Java value is computed based on the object returned by method
     * {@code getAny()} by possibly unwrapping any {@code JAXBElement} instances. If that object declares a
     * <blockquote><pre>public Object getJavaValue( ClassLoader )</pre></blockquote> method, the value returned by this
     * method is the object returned by a call to that method using reflection. If that object does not declare such a
     * method, the value returned by this method is that (possibly unwrapped) object.</li>
     * <li>If property {@code value} is set, the Java value is computed based on the values of properties {@code type}
     * and {@code value}. If property {@code type} is not set or equals {@code java.lang.String}, the value returned
     * by this method is the string value returned by method {@code getValue()}. If property {@code type} equals a name
     * of a Java primitive type, an instance of the wrapper class corresponding to that primitive type name is returned
     * instantiated by passing the value of property {@code value} to the public constructor taking a single
     * {@code java.lang.String} argument of that wrapper class. For all other values of property {@code type} an
     * instance of a class with a name equal to the value of property {@code type} is returned instantiated by passing
     * the value of property {@code value} to the public constructor taking a single {@code java.lang.String} argument
     * of that class.</li>
     * <li>If properties {@code any} and {@code value} are both {@code null}, this method returns {@code null}.</li>
     * </ol></p>
     *
     * @param classLoader The class loader to use for getting the Java value; {@code null} to use the platform's
     * bootstrap class loader.
     *
     * @return The Java value of the property or {@code null}.
     *
     * @throws ModelException if getting the Java value of the property fails.
     */
    public Object getJavaValue( final ClassLoader classLoader ) throws ModelException
    {
        try
        {
            if ( this.getAny() != null )
            {
                if ( this.getType() == null )
                {
                    throw new ModelException( this.getMessage( "mandatoryType", this.getName() ) );
                }

                String typeName = this.getType();
                final int idx = typeName.indexOf( "<" );
                if ( idx != -1 )
                {
                    typeName = typeName.substring( 0, idx );
                }

                final Class javaType = Class.forName( typeName, true, classLoader );
                final Object anyObject = this.getAny() instanceof JAXBElement
                                         ? ( (JAXBElement) this.getAny() ).getValue() : this.getAny();

                return this.getJavaValue( classLoader, anyObject, javaType );
            }

            Class javaType = String.class;
            boolean primitive = false;

            if ( this.getType() != null )
            {
                if ( Boolean.TYPE.getName().equals( this.getType() ) )
                {
                    javaType = Boolean.class;
                    primitive = true;
                }
                else if ( Byte.TYPE.getName().equals( this.getType() ) )
                {
                    javaType = Byte.class;
                    primitive = true;
                }
                else if ( Character.TYPE.getName().equals( this.getType() ) )
                {
                    javaType = Character.class;
                    primitive = true;
                }
                else if ( Double.TYPE.getName().equals( this.getType() ) )
                {
                    javaType = Double.class;
                    primitive = true;
                }
                else if ( Float.TYPE.getName().equals( this.getType() ) )
                {
                    javaType = Float.class;
                    primitive = true;
                }
                else if ( Integer.TYPE.getName().equals( this.getType() ) )
                {
                    javaType = Integer.class;
                    primitive = true;
                }
                else if ( Long.TYPE.getName().equals( this.getType() ) )
                {
                    javaType = Long.class;
                    primitive = true;
                }
                else if ( Short.TYPE.getName().equals( this.getType() ) )
                {
                    javaType = Short.class;
                    primitive = true;
                }
                else
                {
                    String typeName = this.getType();
                    final int idx = typeName.indexOf( "<" );
                    if ( idx != -1 )
                    {
                        typeName = typeName.substring( 0, idx );
                    }

                    javaType = Class.forName( typeName, true, classLoader );
                }
            }

            if ( this.getValue() == null && primitive )
            {
                throw new ModelException( this.getMessage(
                    "mandatoryPrimitiveValue", this.getName(), this.getType() ) );

            }

            return this.getJavaValue( javaType, this.getValue() );
        }
        catch ( final ClassNotFoundException e )
        {
            throw new ModelException( this.getMessage( "classNotFound", this.getName(), this.getType() ), e );
        }
    }

    private Object getJavaValue( final ClassLoader classLoader, final Object any, final Class returnType )
        throws ModelException
    {
        if ( any != null )
        {
            final String methodName = "getJavaValue";

            try
            {
                final java.lang.reflect.Method m = any.getClass().getMethod( methodName, ClassLoader.class );
                final Object result = m.invoke( any, classLoader );

                if ( result != null && !returnType.isAssignableFrom( result.getClass() ) )
                {
                    throw new ModelException( this.getMessage(
                        "illegalMethodInvocationResult", methodName, any.getClass().getName(),
                        result.getClass().getName(), returnType.getName() ) );

                }

                return result;
            }
            catch ( final IllegalAccessException e )
            {
                throw new ModelException( this.getMessage(
                    "methodAccessDenied", methodName, any.getClass().getName() ), e );

            }
            catch ( final IllegalArgumentException e )
            {
                throw new AssertionError( e );
            }
            catch ( final InvocationTargetException e )
            {
                throw new ModelException( this.getMessage(
                    "methodInvocationFailure", methodName, any.getClass().getName() ), e );

            }
            catch ( final SecurityException e )
            {
                throw new ModelException( this.getMessage(
                    "methodAccessDenied", methodName, any.getClass().getName() ), e );

            }
            catch ( final NoSuchMethodException e )
            {
                // Optional method not provided.
            }
        }

        return any;
    }

    private Object getJavaValue( final Class type, final String value ) throws ModelException
    {
        if ( value != null )
        {
            try
            {
                if ( type == Character.class )
                {
                    if ( value.length() != 1 )
                    {
                        throw new ModelException( this.getMessage( "illegalValue", value, Character.class.getName() ) );
                    }

                    return type.getConstructor( new Class[]
                        {
                            char.class
                        } ).newInstance( new Object[]
                        {
                            value.charAt( 0 )
                        } );

                }
                else if ( type == String.class )
                {
                    return value;
                }
                else
                {
                    return type.getConstructor( new Class[]
                        {
                            String.class
                        } ).newInstance( value );

                }
            }
            catch ( final InstantiationException e )
            {
                throw new ModelException( this.getMessage( "instantiationException", type.getName() ), e );
            }
            catch ( final IllegalAccessException e )
            {
                throw new ModelException( this.getMessage( "constructorAccessDenied", type.getName() ), e );
            }
            catch ( final IllegalArgumentException e )
            {
                throw new AssertionError( e );
            }
            catch ( final InvocationTargetException e )
            {
                throw new ModelException( this.getMessage( "constructorInvocationFailure", type.getName() ), e );
            }
            catch ( final NoSuchMethodException e )
            {
                throw new ModelException( this.getMessage( "constructorNotFound", type.getName() ), e );
            }
        }

        return value;
    }

    private String getMessage( final String key, final Object... arguments )
    {
        return java.text.MessageFormat.format( java.util.ResourceBundle.getBundle(
            Property.class.getName().replace( '.', '/' ), java.util.Locale.getDefault() ).getString( key ), arguments );

    }
]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='PropertyReference']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>The name of the referenced property.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='PropertyReference']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this property reference is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='PropertyReference']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this property reference is intended to override a super property reference.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Messages']">
      <ci:code><![CDATA[
    /**
     * Gets a message for a given name from the list of messages.
     *
     * @param name The name of the message to return.
     *
     * @return The message with name {@code name} from the list or {@code null},
     * if no message matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getMessage()
     */
    public Message getMessage( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( Message m : this.getMessage() )
        {
            if ( name.equals( m.getName() ) )
            {
                return m;
            }
        }

        return null;
    }

    /**
     * Gets a message reference for a given name from the list of references.
     *
     * @param name The name of the message reference to return.
     *
     * @return The message reference with name {@code name} from the list or
     * {@code null}, if no message reference matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getReference()
     */
    public MessageReference getReference( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( MessageReference r : this.getReference() )
        {
            if ( name.equals( r.getName() ) )
            {
                return r;
            }
        }

        return null;
    }
]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Message']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:template']">
      <jaxb:property>
        <jaxb:javadoc>The localizable template of this message.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Message']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:arguments']">
      <jaxb:property>
        <jaxb:javadoc>The format arguments of this message or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Message']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>The name of this message.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Message']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this message is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Message']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this message is intended to override a super message.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='MessageReference']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>The name of the referenced message.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='MessageReference']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this message reference is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='MessageReference']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this message reference is intended to override a super message reference.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Arguments']">
      <ci:code><![CDATA[
    /**
     * Gets an argument for a given name from the list of arguments.
     *
     * @param name The name of the argument to return.
     *
     * @return The argument with name {@code name} from the list or
     * {@code null}, if no argument matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getArgument()
     */
    public Argument getArgument( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( Argument a : this.getArgument() )
        {
            if ( name.equals( a.getName() ) )
            {
                return a;
            }
        }

        return null;
    }

    /**
     * Gets an argument for a given index from the list of arguments.
     *
     * @param index The index of the argument to return.
     *
     * @return The argument at {@code index} from the list.
     *
     * @throws IndexOutOfBoundsException if {@code index} is negative, greater
     * or equal to the size of the list of arguments.
     *
     * @see #getArgument()
     */
    public Argument getArgument( final int index )
    {
        if ( index < 0 || index >= this.getArgument().size() )
        {
            throw new IndexOutOfBoundsException( Integer.toString( index ) );
        }

        for ( Argument a : this.getArgument() )
        {
            if ( index == a.getIndex() )
            {
                return a;
            }
        }

        return null;
    }
]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Argument']/xs:complexContent/xs:extension/xs:attribute[@name='index']">
      <jaxb:property>
        <jaxb:javadoc>Index of this argument.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Argument']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>Name of this argument.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Argument']/xs:complexContent/xs:extension/xs:attribute[@name='type']">
      <jaxb:property>
        <jaxb:javadoc>Type of this argument.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Instances']">
      <ci:code><![CDATA[
    /**
     * Gets an instance for a given identifier from the list of instances.
     *
     * @param identifier The identifier of the instance to return.
     *
     * @return The instance identified by {@code identifier} from the list or
     * {@code null}, if no instance matching {@code identifier} is found.
     *
     * @throws NullPointerException if {@code identifier} is {@code null}.
     *
     * @see #getInstance()
     */
    public Instance getInstance( final String identifier )
    {
        if ( identifier == null )
        {
            throw new NullPointerException( "identifier" );
        }

        for ( Instance i : this.getInstance() )
        {
            if ( i.getIdentifier().equals( identifier ) )
            {
                return i;
            }
        }

        return null;
    }
]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:specifications']">
      <jaxb:property>
        <jaxb:javadoc>Specifications implemented by this instance or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:dependencies']">
      <jaxb:property>
        <jaxb:javadoc>Dependencies of this instance or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:properties']">
      <jaxb:property>
        <jaxb:javadoc>Properties of this instance or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:messages']">
      <jaxb:property>
        <jaxb:javadoc>Messages of this instance or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:attribute[@name='identifier']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of this instance.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>The name of the implementation of the specifications implemented by this instance.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:attribute[@name='class']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of the class of this instance.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:attribute[@name='stateless']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this instance does not retain state across operations.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']">
      <ci:code><![CDATA[
    /** Maps dependency names to dependency objects. */
    @javax.xml.bind.annotation.XmlTransient private java.util.Map<String, Object> dependencyObjects;

    /** Maps property names to property objects. */
    @javax.xml.bind.annotation.XmlTransient private java.util.Map<String, Object> propertyObjects;

    /**
     * Gets a mapping of dependency names to objects bound to the instance.
     *
     * @return A mapping of dependency names to objects bound to the instance.
     */
    public java.util.Map<String, Object> getDependencyObjects()
    {
        if ( this.dependencyObjects == null )
        {
            this.dependencyObjects = new java.util.HashMap<String, Object>();
        }

        return this.dependencyObjects;
    }

    /**
     * Gets a mapping of property names to objects bound to the instance.
     *
     * @return A mapping of property names to objects bound to the instance.
     */
    public java.util.Map<String, Object> getPropertyObjects()
    {
        if ( this.propertyObjects == null )
        {
            this.propertyObjects = new java.util.HashMap<String, Object>();
        }

        return this.propertyObjects;
    }
]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Person']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>Name of this person.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Person']/xs:complexContent/xs:extension/xs:attribute[@name='mail']">
      <jaxb:property>
        <jaxb:javadoc>Mail address of this person or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Author']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>The version created by this author or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:simpleType[@name='ArgumentType']/xs:restriction/xs:enumeration[@value='Number']">
      <jaxb:typesafeEnumMember name="NUMBER">
        <jaxb:javadoc>Argument of type {@code java.lang.Number}.</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <jaxb:bindings node="xs:simpleType[@name='ArgumentType']/xs:restriction/xs:enumeration[@value='Date']">
      <jaxb:typesafeEnumMember name="DATE">
        <jaxb:javadoc>Argument of type {@code java.util.Date}.</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <jaxb:bindings node="xs:simpleType[@name='ArgumentType']/xs:restriction/xs:enumeration[@value='Time']">
      <jaxb:typesafeEnumMember name="TIME">
        <jaxb:javadoc>Argument of type {@code java.util.Date}.</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <jaxb:bindings node="xs:simpleType[@name='ArgumentType']/xs:restriction/xs:enumeration[@value='Text']">
      <jaxb:typesafeEnumMember name="TEXT">
        <jaxb:javadoc>Argument of type {@code java.lang.String}.</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:simpleType[@name='Multiplicity']/xs:restriction/xs:enumeration[@value='One']">
      <jaxb:typesafeEnumMember name="ONE">
        <jaxb:javadoc>A multiplicity equal to {@code ONE} specifies that no more than one implementation of the specification is allowed to exist among a set of modules (including none).</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <jaxb:bindings node="xs:simpleType[@name='Multiplicity']/xs:restriction/xs:enumeration[@value='Many']">
      <jaxb:typesafeEnumMember name="MANY">
        <jaxb:javadoc>A multiplicity equal to {@code MANY} specifies that many implementations of the specification are allowed to exist among a set of modules (including none).</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Modules']">
      <ci:code><![CDATA[

    /**
     * Constant for the default name of the classpath module.
     * @see #getClasspathModuleName()
     */
    private static final String DEFAULT_CLASSPATH_MODULE_NAME = "Java Classpath";

    /** Default classpath module name. */
    private static volatile String defaultClasspathModuleName;

    /** Empty {@code Class} array. */
    private static final Class[] NO_CLASSES =
    {
    };

    /** Maps objects to {@code Instance}s. */
    @javax.xml.bind.annotation.XmlTransient private java.util.Map<Object,Instance> objects = new org.jomc.util.WeakIdentityHashMap();

    /**
     * Creates a new {@code Modules} instance taking a map backing the instance.
     *
     * @param objects The map backing the instance.
     */
    public Modules( final java.util.Map<Object, Instance> objects )
    {
        if ( objects == null )
        {
            throw new NullPointerException( "objects" );
        }

        this.objects = objects;
    }

    /**
     * Creates a new {@code Modules} instance by deeply copying a given {@code Modules} instance taking a map backing
     * the instance.
     *
     * @param o The instance to copy.
     * @param objects The map backing the instance.
     *
     * @throws NullPointerException if {@code o} or {@code objects} is {@code null}.
     */
    public Modules( final Modules o, final java.util.Map<Object, Instance> objects )
    {
        super( o );
        if ( o == null )
        {
            throw new NullPointerException( "Cannot create a copy of 'Modules' from 'null'." );
        }
        if ( objects == null )
        {
            throw new NullPointerException( "objects" );
        }

        copyModule( o.getModule(), getModule() );
        this.objects = objects;
    }

    /**
     * Gets the default classpath module name.
     * <p>The default classpath module name is controlled by system property
     * {@code org.jomc.model.Modules.defaultClasspathModuleName} holding the default classpath module name. If that
     * property is not set, the {@code Java Classpath} default is returned.</p>
     *
     * @return The default classpath module name.
     *
     * @see #getClasspathModule(java.lang.String, java.lang.ClassLoader)
     */
    public static String getDefaultClasspathModuleName()
    {
        if ( defaultClasspathModuleName == null )
        {
            defaultClasspathModuleName = System.getProperty( "org.jomc.model.Modules.defaultClasspathModuleName",
                                                             DEFAULT_CLASSPATH_MODULE_NAME );

        }

        return defaultClasspathModuleName;
    }

    /**
     * Sets the default classpath module name.
     *
     * @param value The new default classpath module name or {@code null},
     */
    public static void setDefaultClasspathModuleName( final String value )
    {
        defaultClasspathModuleName = value;
    }

    /**
     * Gets a module holding model objects resolved by inspecting a given class loader.
     * <p>This method searches this list of modules for unresolved references and tries to resolve each unresolved
     * reference by inspecting the given class loader.</p>
     *
     * @param moduleName The name of the module to return.
     * @param classLoader The class loader to use for resolving entities or {@code null} to resolve entities using the
     * bootstrap class loader.
     *
     * @return A module holding model objects resolved by inspecting the given class loader or {@code null} if nothing
     * is resolved.
     *
     * @throws NullPointerException if {@code moduleName} is {@code null}.
     *
     * @see #getDefaultClasspathModuleName()
     * @see #getModule()
     */
    public Module getClasspathModule( final String moduleName, final ClassLoader classLoader )
    {
        if ( moduleName == null )
        {
            throw new NullPointerException( "moduleName," );
        }

        final Module classpathModule = new Module();
        classpathModule.setVersion( System.getProperty( "java.specification.version" ) );
        classpathModule.setName( moduleName );

        this.resolveClasspath( classpathModule, classLoader );

        final boolean resolved = ( classpathModule.getSpecifications() != null &&
                                   !classpathModule.getSpecifications().getSpecification().isEmpty() ) ||
                                 ( classpathModule.getImplementations() != null &&
                                   !classpathModule.getImplementations().getImplementation().isEmpty() );

        return resolved ? classpathModule : null;
    }

    /**
     * Gets a module for a given name from this list of modules.
     *
     * @param name The name of the module to return.
     *
     * @return The module with name {@code name} from the list or {@code null},
     * if no module matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getModule()
     */
    public Module getModule( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getName().equals( name ) )
            {
                return m;
            }
        }

        return null;
    }

    /**
     * Gets all specifications declared in this list of modules.
     *
     * @return All specifications declared in the list or {@code null}, if no
     * specifications are declared.
     *
     * @see #getModule()
     */
    public Specifications getSpecifications()
    {
        final Specifications specifications = new Specifications();
        for ( Module m : this.getModule() )
        {
            if ( m.getSpecifications() != null )
            {
                specifications.getSpecification().addAll( m.getSpecifications().getSpecification() );
            }
        }

        return specifications.getSpecification().isEmpty() ? null : specifications;
    }

    /**
     * Gets all implementations declared in this list of modules.
     *
     * @return All implementations declared in the list or {@code null}, if no
     * implementations are declared.
     *
     * @see #getModule()
     */
    public Implementations getImplementations()
    {
        final Implementations implementations = new Implementations();
        for ( Module m : this.getModule() )
        {
            if ( m.getImplementations() != null )
            {
                implementations.getImplementation().addAll( m.getImplementations().getImplementation() );
            }
        }

        return implementations.getImplementation().isEmpty() ? null : implementations;
    }

    /**
     * Gets the module declaring a given specification from this list of modules.
     *
     * @param specification The identifier of the specification whose declaring module to return.
     *
     * @return The module declaring {@code specification} from the list or {@code null}, if no module
     * is found declaring {@code specification}.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getModule()
     */
    public Module getModuleOfSpecification( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getSpecifications() != null && m.getSpecifications().getSpecification( specification ) != null )
            {
                return m;
            }
        }

        return null;
    }

    /**
     * Gets the module declaring a given implementation from this list of modules.
     *
     * @param implementation The identifier of the implementation whose declaring module to return.
     *
     * @return The module declaring {@code implementation} from the list or {@code null}, if no module
     * is found declaring {@code implementation}.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Module getModuleOfImplementation( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getImplementations() != null && m.getImplementations().getImplementation( implementation ) != null )
            {
                return m;
            }
        }

        return null;
    }

    /**
     * Gets a specification for a given identifier from this list of modules.
     *
     * @param specification The identifier of the specification to return.
     *
     * @return The specification identified by {@code specification} from the list or {@code null},
     * if no specification matching {@code specification} is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getModule()
     */
    public Specification getSpecification( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getSpecifications() != null )
            {
                final Specification s = m.getSpecifications().getSpecification( specification );
                if ( s != null )
                {
                    return s;
                }
            }
        }

        return null;
    }

    /**
     * Gets a specification for a given class from this list of modules.
     *
     * @param specification The class of the specification to return.
     *
     * @return The specification identified by {@code specification} from the list or {@code null},
     * if no specification matching {@code specification} is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getModule()
     */
    public Specification getSpecification( final Class specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getSpecifications() != null )
            {
                final Specification s = m.getSpecifications().getSpecification( specification );
                if ( s != null )
                {
                    return s;
                }
            }
        }

        return null;
    }

    /**
     * Gets all specifications an implementation implements from this list of modules.
     *
     * @param implementation The identifier of the implementation to get all implemented specifications of.
     *
     * @return List of all specifications implemented by {@code implementation} from the list or {@code null}, if no
     * implementation matching {@code implementation} is found or if that implementation does not implement any
     * specification.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Specifications getSpecifications( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Specifications specs = new Specifications();
        this.collectSpecifications( this.getImplementation( implementation ), specs, new Implementations(), true );

        Implementation declaration = null;
        final Implementation impl = this.getImplementation( implementation );

        if ( impl != null && impl.getClazz() != null && !impl.getIdentifier().equals( impl.getClazz() ) )
        {
            for ( Module m : this.getModule() )
            {
                if ( m.getImplementations() != null )
                {
                    for ( Implementation i : m.getImplementations().getImplementation() )
                    {
                        if ( i.getClazz() != null && i.getClazz().equals( i.getIdentifier() ) &&
                             i.getClazz().equals( impl.getClazz() ) )
                        {
                            declaration = i;
                            break;
                        }
                    }
                }
            }
        }

        if ( declaration != null )
        {
            final Specifications declaredSpecifications = this.getSpecifications( declaration.getIdentifier() );
            if ( declaredSpecifications != null )
            {
                for ( SpecificationReference r : declaredSpecifications.getReference() )
                {
                    if ( specs.getReference( r.getIdentifier() ) == null )
                    {
                        specs.getReference().add( r );
                        final Specification s = declaredSpecifications.getSpecification( r.getIdentifier() );
                        if ( s != null )
                        {
                            specs.getSpecification().add( s );
                        }
                    }
                }
            }
        }

        java.util.Collections.sort( specs.getSpecification(), new java.util.Comparator<Specification>()
        {

            public int compare( final Specification o1, final Specification o2 )
            {
                return o1.getIdentifier().compareTo( o2.getIdentifier() );
            }

        } );

        java.util.Collections.sort( specs.getReference(), new java.util.Comparator<SpecificationReference>()
        {

            public int compare( final SpecificationReference o1, final SpecificationReference o2 )
            {
                return o1.getIdentifier().compareTo( o2.getIdentifier() );
            }

        } );

        return specs.getSpecification().isEmpty() && specs.getReference().isEmpty() ? null : specs;
    }

    /**
     * Gets an implementation for a given identifier from this list of modules.
     *
     * @param implementation The identifier of the implementation to return.
     *
     * @return The implementation identified by {@code implementation} from the list or {@code null},
     * if no implementation matching {@code implementation} is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Implementation getImplementation( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getImplementations() != null )
            {
                final Implementation i = m.getImplementations().getImplementation( implementation );
                if ( i != null )
                {
                    return i;
                }
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given class from this list of modules.
     *
     * @param implementation The class of the implementation to return.
     *
     * @return The implementation identified by {@code implementation} from the list or {@code null},
     * if no implementation matching {@code implementation} is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Implementation getImplementation( final Class implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getImplementations() != null )
            {
                final Implementation i = m.getImplementations().getImplementation( implementation );
                if ( i != null )
                {
                    return i;
                }
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given object from this list of modules.
     *
     * @param object The object of the implementation to return.
     *
     * @return The implementation identified by {@code object} from the list or {@code null},
     * if no implementation matching {@code object} is found.
     *
     * @throws NullPointerException if {@code object} is {@code null}.
     *
     * @see #getModule()
     */
    public Implementation getImplementation( final Object object )
    {
        return this.collectImplementation( object.getClass() );
    }

    /**
     * Gets an implementation for a given name implementing a given specification from this list of
     * modules.
     *
     * @param specification The identifier of the specification to return an implementation of.
     * @param name The name of the implementation to return.
     *
     * @return The implementation with name {@code name} implementing the specification identified by
     * {@code specification} from the list or {@code null}, if no such implementation is found.
     *
     * @throws NullPointerException if {@code specification} or {@code name} is {@code null}.
     *
     * @see #getModule()
     */
    public Implementation getImplementation( final String specification, final String name )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        final Implementations implementations = this.getImplementations( specification );
        if ( implementations != null )
        {
            return implementations.getImplementationByName( name );
        }

        return null;
    }

    /**
     * Gets all dependencies of an implementation from this list of modules.
     *
     * @param implementation The identifier of the implementation to get all dependencies of.
     *
     * @return List of all dependencies of {@code implementation} from the list or {@code null},
     * if no dependencies are found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Dependencies getDependencies( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Dependencies dependencies = new Dependencies();
        this.collectDependencies( this.getImplementation( implementation ), dependencies, new Implementations(), true );

        Implementation declaration = null;
        final Implementation impl = this.getImplementation( implementation );

        if ( impl != null && impl.getClazz() != null && !impl.getIdentifier().equals( impl.getClazz() ) )
        {
            for ( Module m : this.getModule() )
            {
                if ( m.getImplementations() != null )
                {
                    for ( Implementation i : m.getImplementations().getImplementation() )
                    {
                        if ( i.getClazz() != null && i.getClazz().equals( i.getIdentifier() ) &&
                             i.getClazz().equals( impl.getClazz() ) )
                        {
                            declaration = i;
                            break;
                        }
                    }
                }
            }
        }

        if ( declaration != null )
        {
            final Dependencies declaredDependencies = this.getDependencies( declaration.getIdentifier() );
            if ( declaredDependencies != null )
            {
                for ( Dependency d : declaredDependencies.getDependency() )
                {
                    if ( dependencies.getDependency( d.getName() ) == null )
                    {
                        dependencies.getDependency().add( d );
                    }
                }
            }
        }

        java.util.Collections.sort( dependencies.getDependency(), new java.util.Comparator<Dependency>()
        {

            public int compare( final Dependency o1, final Dependency o2 )
            {
                return o1.getName().compareTo( o2.getName() );
            }

        } );

        return dependencies.getDependency().isEmpty() ? null : dependencies;
    }

    /**
     * Gets all properties of an implementation from this list of modules.
     *
     * @param implementation The identifier of the implementation to get all properties of.
     *
     * @return List of all properties of {@code implementation} from the list or {@code null},
     * if no properties are found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Properties getProperties( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Properties properties = new Properties();
        this.collectProperties( this.getImplementation( implementation ), properties, new Implementations(), true );

        Implementation declaration = null;
        final Implementation impl = this.getImplementation( implementation );

        if ( impl != null && impl.getClazz() != null && !impl.getIdentifier().equals( impl.getClazz() ) )
        {
            for ( Module m : this.getModule() )
            {
                if ( m.getImplementations() != null )
                {
                    for ( Implementation i : m.getImplementations().getImplementation() )
                    {
                        if ( i.getClazz() != null && i.getClazz().equals( i.getIdentifier() ) &&
                             i.getClazz().equals( impl.getClazz() ) )
                        {
                            declaration = i;
                            break;
                        }
                    }
                }
            }
        }

        if ( declaration != null )
        {
            final Properties declaredProperties = this.getProperties( declaration.getIdentifier() );
            if ( declaredProperties != null )
            {
                for ( Property p : declaredProperties.getProperty() )
                {
                    if ( properties.getProperty( p.getName() ) == null )
                    {
                        properties.getProperty().add( p );
                    }
                }
            }
        }

        final Properties specified = this.getSpecifiedProperties( implementation );

        if ( specified != null )
        {
            for ( Property p : specified.getProperty() )
            {
                if ( properties.getProperty( p.getName() ) == null )
                {
                    properties.getProperty().add( p );
                }
            }
        }

        java.util.Collections.sort( properties.getProperty(), new java.util.Comparator<Property>()
        {

            public int compare( final Property o1, final Property o2 )
            {
                return o1.getName().compareTo( o2.getName() );
            }

        } );

        return properties.getProperty().isEmpty() ? null : properties;
    }

    /**
     * Gets all properties specified for an implementation from this list of modules.
     *
     * @param implementation The identifier of the implementation to return specified properties of.
     *
     * @return List of all properties specified for {@code implementation} from the list or {@code null},
     * if no properties are found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Properties getSpecifiedProperties( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Properties properties = new Properties();
        final Specifications specs = this.getSpecifications( implementation );

        if ( specs != null )
        {
            for ( Specification s : specs.getSpecification() )
            {
                if ( s.getProperties() != null )
                {
                    properties.getProperty().addAll( s.getProperties().getProperty() );
                }
            }
        }

        java.util.Collections.sort( properties.getProperty(), new java.util.Comparator<Property>()
        {

            public int compare( final Property o1, final Property o2 )
            {
                return o1.getName().compareTo( o2.getName() );
            }

        } );

        return properties.getProperty().isEmpty() ? null : properties;
    }

    /**
     * Gets all messages of an implementation from this list of modules.
     *
     * @param implementation The identifier of the implementation to get all messages of.
     *
     * @return List of all messages of {@code implementation} from the list or {@code null},
     * if no messages are found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Messages getMessages( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Messages msgs = new Messages();
        this.collectMessages( this.getImplementation( implementation ), msgs, new Implementations(), true );

        Implementation declaration = null;
        final Implementation impl = this.getImplementation( implementation );

        if ( impl != null && impl.getClazz() != null && !impl.getIdentifier().equals( impl.getClazz() ) )
        {
            for ( Module m : this.getModule() )
            {
                if ( m.getImplementations() != null )
                {
                    for ( Implementation i : m.getImplementations().getImplementation() )
                    {
                        if ( i.getClazz() != null && i.getClazz().equals( i.getIdentifier() ) &&
                             i.getClazz().equals( impl.getClazz() ) )
                        {
                            declaration = i;
                            break;
                        }
                    }
                }
            }
        }

        if ( declaration != null )
        {
            final Messages declaredMessages = this.getMessages( declaration.getIdentifier() );
            if ( declaredMessages != null )
            {
                for ( Message m : declaredMessages.getMessage() )
                {
                    if ( msgs.getMessage( m.getName() ) == null )
                    {
                        msgs.getMessage().add( m );
                    }
                }
            }
        }

        java.util.Collections.sort( msgs.getMessage(), new java.util.Comparator<Message>()
        {

            public int compare( final Message o1, final Message o2 )
            {
                return o1.getName().compareTo( o2.getName() );
            }

        } );

        return msgs.getMessage().isEmpty() ? null : msgs;
    }

    /**
     * Gets all implementations implementing a given specification from this list of modules.
     *
     * @param specification The identifier of the specification to return all implementations of.
     *
     * @return All implementations implementing the specification identified by {@code specification}
     * from the list or {@code null}, if no implementation implementing {@code specification} is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getModule()
     */
    public Implementations getImplementations( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        final Implementations implementations = new Implementations();
        for ( Module m : this.getModule() )
        {
            if ( m.getImplementations() != null )
            {
                for ( Implementation i : m.getImplementations().getImplementation() )
                {
                    final Specifications specs = this.getSpecifications( i.getIdentifier() );

                    if ( specs != null )
                    {
                        for ( Specification s : specs.getSpecification() )
                        {
                            if ( specification.equals( s.getIdentifier() ) )
                            {
                                implementations.getImplementation().add( i );
                            }
                        }
                    }
                }
            }
        }

        return implementations.getImplementation().size() > 0 ? implementations : null;
    }

    /**
     * Merges this list of modules to a single module.
     *
     * @return A module holding all model objects from the list.
     */
    public Module getMergedModule()
    {
        final Modules copy = this.clone();
        final Module mergedModule = new Module();

        for ( Module m : copy.getModule() )
        {
            final java.util.Set<String> referencedMessages = new java.util.HashSet<String>();
            final java.util.Set<String> referencedProperties = new java.util.HashSet<String>();

            if ( m.getImplementations() != null )
            {
                for ( Implementation i : m.getImplementations().getImplementation() )
                {
                    if ( mergedModule.getImplementations() == null )
                    {
                        mergedModule.setImplementations( new Implementations() );
                    }

                    if ( i.getMessages() != null && !i.getMessages().getReference().isEmpty() )
                    {
                        for ( java.util.Iterator<MessageReference> it = i.getMessages().getReference().iterator();
                              it.hasNext(); )
                        {
                            final String messageName = it.next().getName();
                            i.getMessages().getMessage().add( m.getMessages().getMessage( messageName ) );
                            referencedMessages.add( messageName );
                            it.remove();
                        }
                    }

                    if ( i.getProperties() != null && !i.getProperties().getReference().isEmpty() )
                    {
                        for ( java.util.Iterator<PropertyReference> it = i.getProperties().getReference().iterator();
                              it.hasNext(); )
                        {
                            final String propertyName = it.next().getName();
                            i.getProperties().getProperty().add( m.getProperties().getProperty( propertyName ) );
                            referencedProperties.add( propertyName );
                            it.remove();
                        }
                    }

                    mergedModule.getImplementations().getImplementation().add( i );
                }
            }

            if ( m.getSpecifications() != null )
            {
                if ( mergedModule.getSpecifications() == null )
                {
                    mergedModule.setSpecifications( new Specifications() );
                }

                for ( Specification s : m.getSpecifications().getSpecification() )
                {
                    if ( s.getProperties() != null && !s.getProperties().getReference().isEmpty() )
                    {
                        for ( java.util.Iterator<PropertyReference> it = s.getProperties().getReference().iterator();
                              it.hasNext(); )
                        {
                            final String propertyName = it.next().getName();
                            s.getProperties().getProperty().add( m.getProperties().getProperty( propertyName ) );
                            referencedProperties.add( propertyName );
                            it.remove();
                        }
                    }

                    mergedModule.getSpecifications().getSpecification().add( s );
                }
            }

            for ( String messageName : referencedMessages )
            {
                for ( java.util.Iterator<Message> it = m.getMessages().getMessage().iterator(); it.hasNext(); )
                {
                    if ( messageName.equals( it.next().getName() ) )
                    {
                        it.remove();
                        break;
                    }
                }
            }

            for ( String propertyName : referencedProperties )
            {
                for ( java.util.Iterator<Property> it = m.getProperties().getProperty().iterator(); it.hasNext(); )
                {
                    if ( propertyName.equals( it.next().getName() ) )
                    {
                        it.remove();
                        break;
                    }
                }
            }

            if ( m.getProperties() != null && !m.getProperties().getProperty().isEmpty() )
            {
                if ( mergedModule.getProperties() == null )
                {
                    mergedModule.setProperties( new Properties() );
                }

                mergedModule.getProperties().getProperty().addAll( m.getProperties().getProperty() );
            }

            if ( m.getMessages() != null && !m.getMessages().getMessage().isEmpty() )
            {
                if ( mergedModule.getMessages() == null )
                {
                    mergedModule.setMessages( new Messages() );
                }

                mergedModule.getMessages().getMessage().addAll( m.getMessages().getMessage() );
            }
        }

        return mergedModule;
    }

    /**
     * Gets the instance of an object from this list of modules.
     *
     * @param object The object to get the instance of.
     *
     * @return The instance of {@code object} from the list or {@code null} if no such instance is found.
     *
     * @throws NullPointerException if {@code object} is {@code null}.
     *
     * @see #getModule()
     * @see #createObject(org.jomc.model.Instance instance, java.lang.ClassLoader classLoader)
     */
    public Instance getInstance( final Object object )
    {
        if ( object == null )
        {
            throw new NullPointerException( "object" );
        }

        synchronized ( this.objects )
        {
            Instance instance = (Instance) this.objects.get( object );

            if ( instance == null )
            {
                final Implementation i = this.getImplementation( object );

                if ( i != null )
                {
                    instance = this.getInstance( i.getIdentifier() );
                    if ( instance != null )
                    {
                        this.objects.put( object, instance );
                    }
                }
            }

            return instance;
        }
    }

    /**
     * Gets an instance for an implementation from this list of modules.
     *
     * @param implementation The identifier of the implementation to get an instance for.
     *
     * @return An instance for the implementation identified by {@code implementation} from the list or {@code null}, if
     * no such instance is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Instance getInstance( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Implementation i = this.getImplementation( implementation );

        if ( i != null && i.getClazz() != null )
        {
            final Instance instance = new Instance();
            instance.setIdentifier( i.getIdentifier() );
            instance.setName( i.getName() );
            instance.setClazz( i.getClazz() );
            instance.setStateless( i.isStateless() );
            instance.setDependencies( this.getDependencies( implementation ) );
            instance.setProperties( this.getProperties( implementation ) );
            instance.setMessages( this.getMessages( implementation ) );
            instance.setSpecifications( this.getSpecifications( implementation ) );
            this.collectAny( i, instance.getAny(), new Implementations(), true );
            return instance;
        }

        return null;
    }

    /**
     * Gets an instance for an implementation from this list of modules overridden with a given dependency.
     *
     * @param implementation The identifier of the implementation to get an instance for.
     * @param dependency The dependency to use for overriding model objects of the instance.
     *
     * @return An instance for the implementation identified by {@code implementation} from the list with any model
     * objects overridden using {@code dependency} or {@code null}, if no such instance is found.
     *
     * @throws NullPointerException if {@code implementation} or {@code dependency} is {@code null}.
     *
     * @see #getModule()
     */
    public Instance getInstance( final String implementation, final Dependency dependency )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }
        if ( dependency == null )
        {
            throw new NullPointerException( "dependency" );
        }

        Instance instance = this.getInstance( implementation );

        if ( instance != null )
        {
            final Specification dependencySpecification = this.getSpecification( dependency.getIdentifier() );
            if ( dependencySpecification != null && dependencySpecification.getScope() == null &&
                 dependency.getProperties() != null && !dependency.getProperties().getProperty().isEmpty() )
            {
                instance = new Instance( instance );
                final Properties properties = new Properties();
                properties.getProperty().addAll( dependency.getProperties().getProperty() );

                if ( instance.getProperties() != null )
                {
                    for ( Property p : instance.getProperties().getProperty() )
                    {
                        if ( properties.getProperty( p.getName() ) == null )
                        {
                            properties.getProperty().add( p );
                        }
                    }
                }

                instance.setProperties( properties );
            }
        }

        return instance;
    }

    /**
     * Creates an object for a given instance from this list of modules.
     *
     * @param instance The instance to create an object of.
     * @param classLoader The class loader to use for creating the object or {@code null} to use the bootstrap class
     * loader.
     *
     * @return A new object of {@code instance} from the list or {@code null} if no such object is found.
     *
     * @throws NullPointerException if {@code instance}  is {@code null},
     * @throws InstantiationException if creating an object fails.
     *
     * @see #getModule()
     */
    public Object createObject( final Instance instance, final ClassLoader classLoader ) throws InstantiationException
    {
        if ( instance == null )
        {
            throw new NullPointerException( "instance" );
        }

        Object object = null;

        try
        {
            final Class clazz = Class.forName( instance.getClazz(), true, classLoader );

            if ( java.lang.reflect.Modifier.isPublic( clazz.getModifiers() ) )
            {
                java.lang.reflect.Constructor ctor = null;

                if ( !java.lang.reflect.Modifier.isAbstract( clazz.getModifiers() ) )
                {
                    try
                    {
                        ctor = clazz.getConstructor( NO_CLASSES );
                    }
                    catch ( final NoSuchMethodException e )
                    {
                        ctor = null;
                    }
                }

                boolean assignable = true;
                if ( instance.getSpecifications() != null )
                {
                    for ( Specification s : instance.getSpecifications().getSpecification() )
                    {
                        if ( s.getClazz() != null )
                        {
                            final Class specClass = Class.forName( s.getClazz(), true, classLoader );
                            if ( !specClass.isAssignableFrom( clazz ) )
                            {
                                assignable = false;
                                break;
                            }
                        }
                    }
                }

                if ( ctor != null && assignable )
                {
                    synchronized ( this.objects )
                    {
                        object = clazz.newInstance();
                        this.objects.put( object, instance );
                    }
                }
                else
                {
                    java.lang.reflect.Method factoryMethod = null;
                    String methodName = null;

                    char[] c = instance.getName().toCharArray();
                    c[0] = Character.toUpperCase( c[0] );
                    methodName = "get" + String.valueOf( c );

                    boolean javaIdentifier = Character.isJavaIdentifierStart( c[0] );
                    if ( javaIdentifier )
                    {
                        for ( int idx = c.length - 1; idx > 0; idx-- )
                        {
                            if ( !Character.isJavaIdentifierPart( c[idx] ) )
                            {
                                javaIdentifier = false;
                                break;
                            }
                        }
                    }

                    if ( javaIdentifier )
                    {
                        try
                        {
                            factoryMethod = clazz.getMethod( methodName, (Class[]) null );
                        }
                        catch ( NoSuchMethodException e )
                        {
                            factoryMethod = null;
                        }
                    }

                    if ( factoryMethod == null )
                    {
                        try
                        {
                            factoryMethod = clazz.getMethod( "getObject", (Class[]) null );
                        }
                        catch ( NoSuchMethodException e )
                        {
                            factoryMethod = null;
                        }
                    }

                    if ( factoryMethod == null )
                    {
                        throw new InstantiationException( this.getMessage( "failedCreatingObject", new Object[]
                            {
                                instance.getIdentifier(), clazz.getName(), methodName
                            } ) );

                    }

                    if ( java.lang.reflect.Modifier.isStatic( factoryMethod.getModifiers() ) )
                    {
                        synchronized ( this.objects )
                        {
                            object = factoryMethod.invoke( null, (Object[]) null );
                            if ( object != null )
                            {
                                this.objects.put( object, instance );
                            }
                        }
                    }
                    else if ( ctor != null )
                    {
                        synchronized ( this.objects )
                        {
                            final Object o = ctor.newInstance();
                            this.objects.put( o, instance );
                            object = factoryMethod.invoke( o, (Object[]) null );
                            this.objects.remove( o );
                            if ( object != null )
                            {
                                this.objects.put( object, instance );
                            }
                        }
                    }
                    else
                    {
                        throw new InstantiationException( this.getMessage( "failedCreatingObject", new Object[]
                            {
                                instance.getIdentifier(), clazz.getName(), methodName
                            } ) );

                    }
                }
            }

            return object;
        }
        catch ( final java.lang.reflect.InvocationTargetException e )
        {
            throw (InstantiationException) new InstantiationException().initCause(
                e.getTargetException() != null ? e.getTargetException() : e );

        }
        catch ( final IllegalAccessException e )
        {
            throw (InstantiationException) new InstantiationException().initCause( e );
        }
        catch ( final ClassNotFoundException e )
        {
            throw (InstantiationException) new InstantiationException().initCause( e );
        }
    }

    void collectSpecifications( final Implementation implementation, final Specifications specifications,
                                final Implementations seen, final boolean includeDeclared )
    {
        if ( implementation != null )
        {
            if ( seen.getImplementation( implementation.getIdentifier() ) == null )
            {
                seen.getImplementation().add( implementation );

                if ( includeDeclared && implementation.getSpecifications() != null )
                {
                    for ( SpecificationReference r : implementation.getSpecifications().getReference() )
                    {
                        if ( specifications.getReference( r.getIdentifier() ) == null )
                        {
                            specifications.getReference().add( r );

                            final Specification s = this.getSpecification( r.getIdentifier() );
                            if ( s != null && specifications.getSpecification( s.getIdentifier() ) == null )
                            {
                                specifications.getSpecification().add( s );
                            }
                        }
                    }
                }

                if ( implementation.getImplementations() != null )
                {
                    for ( ImplementationReference r : implementation.getImplementations().getReference() )
                    {
                        this.collectSpecifications(
                            this.getImplementation( r.getIdentifier() ), specifications, seen, true );

                    }
                }
            }
        }
    }

    void collectDependencies( final Implementation implementation, final Dependencies dependencies,
                              final Implementations seen, final boolean includeDeclared )
    {
        if ( implementation != null )
        {
            if ( seen.getImplementation( implementation.getIdentifier() ) == null )
            {
                seen.getImplementation().add( implementation );

                if ( includeDeclared && implementation.getDependencies() != null )
                {
                    for ( Dependency d : implementation.getDependencies().getDependency() )
                    {
                        final Dependency dependency = dependencies.getDependency( d.getName() );

                        if ( dependency != null )
                        {
                            if ( d.getProperties() != null )
                            {
                                if ( dependency.getProperties() == null )
                                {
                                    dependency.setProperties( new Properties() );
                                }

                                for ( Property p : d.getProperties().getProperty() )
                                {
                                    if ( dependency.getProperties().getProperty( p.getName() ) == null )
                                    {
                                        dependency.getProperties().getProperty().add( p );
                                    }
                                }
                            }
                        }
                        else
                        {
                            dependencies.getDependency().add( d );
                        }
                    }
                }

                if ( implementation.getImplementations() != null )
                {
                    for ( ImplementationReference r : implementation.getImplementations().getReference() )
                    {
                        this.collectDependencies(
                            this.getImplementation( r.getIdentifier() ), dependencies, seen, true );

                    }
                }
            }
        }
    }

    void collectProperties( final Implementation implementation, final Properties properties,
                            final Implementations seen, final boolean includeDeclared )
    {
        if ( implementation != null )
        {
            if ( seen.getImplementation( implementation.getIdentifier() ) == null )
            {
                seen.getImplementation().add( implementation );

                if ( includeDeclared && implementation.getProperties() != null )
                {
                    for ( Property p : implementation.getProperties().getProperty() )
                    {
                        if ( properties.getProperty( p.getName() ) == null )
                        {
                            properties.getProperty().add( p );
                        }
                    }
                    if ( !implementation.getProperties().getReference().isEmpty() )
                    {
                        final Module m = this.getModuleOfImplementation( implementation.getIdentifier() );

                        if ( m != null )
                        {
                            for ( PropertyReference ref : implementation.getProperties().getReference() )
                            {
                                if ( properties.getProperty( ref.getName() ) == null )
                                {
                                    Property referenced = m.getProperties().getProperty( ref.getName() );
                                    if ( referenced != null )
                                    {
                                        referenced = new Property( referenced );
                                        referenced.setDeprecated( ref.isDeprecated() );
                                        referenced.setFinal( ref.isFinal() );
                                        referenced.setOverride( ref.isOverride() );
                                        properties.getProperty().add( referenced );
                                    }
                                }
                            }
                        }
                    }
                }

                if ( implementation.getImplementations() != null )
                {
                    for ( ImplementationReference r : implementation.getImplementations().getReference() )
                    {
                        this.collectProperties( this.getImplementation( r.getIdentifier() ), properties, seen, true );
                    }
                }
            }
        }
    }

    void collectMessages( final Implementation implementation, final Messages messages,
                          final Implementations seen, boolean includeDeclared )
    {
        if ( implementation != null )
        {
            if ( seen.getImplementation( implementation.getIdentifier() ) == null )
            {
                seen.getImplementation().add( implementation );

                if ( includeDeclared && implementation.getMessages() != null )
                {
                    for ( Message msg : implementation.getMessages().getMessage() )
                    {
                        if ( messages.getMessage( msg.getName() ) == null )
                        {
                            messages.getMessage().add( msg );
                        }
                    }
                    if ( !implementation.getMessages().getReference().isEmpty() )
                    {
                        final Module m = this.getModuleOfImplementation( implementation.getIdentifier() );

                        if ( m != null )
                        {
                            for ( MessageReference ref : implementation.getMessages().getReference() )
                            {
                                if ( messages.getMessage( ref.getName() ) == null )
                                {
                                    Message referenced = m.getMessages().getMessage( ref.getName() );
                                    if ( referenced != null )
                                    {
                                        referenced = new Message( referenced );
                                        referenced.setDeprecated( ref.isDeprecated() );
                                        referenced.setFinal( ref.isFinal() );
                                        referenced.setOverride( ref.isOverride() );
                                        messages.getMessage().add( referenced );
                                    }
                                }
                            }
                        }
                    }
                }

                if ( implementation.getImplementations() != null )
                {
                    for ( ImplementationReference r : implementation.getImplementations().getReference() )
                    {
                        this.collectMessages( this.getImplementation( r.getIdentifier() ), messages, seen, true );
                    }
                }
            }
        }
    }

    void collectAny( final Implementation implementation, final List<Object> any, final Implementations seen,
                     final boolean includeDeclared )
    {
        if ( implementation != null )
        {
            if ( seen.getImplementation( implementation.getIdentifier() ) == null )
            {
                seen.getImplementation().add( implementation );

                if ( includeDeclared && !implementation.getAny().isEmpty() )
                {
                    for ( Object o : implementation.getAny() )
                    {
                        if ( o instanceof org.w3c.dom.Element )
                        {
                            if ( this.getElement( any, (org.w3c.dom.Element) o ) == null )
                            {
                                any.add( o );
                            }

                            continue;
                        }

                        if ( o instanceof javax.xml.bind.JAXBElement )
                        {
                            if ( this.getElement( any, (javax.xml.bind.JAXBElement) o ) == null )
                            {
                                any.add( o );
                            }

                            continue;
                        }

                        any.add( o );
                    }
                }

                if ( implementation.getImplementations() != null )
                {
                    for ( ImplementationReference r : implementation.getImplementations().getReference() )
                    {
                        this.collectAny( this.getImplementation( r.getIdentifier() ), any, seen, true );
                    }
                }
            }
        }
    }

    private Implementation collectImplementation( final Class clazz )
    {
        Implementation i = this.getImplementation( clazz );
        if ( i == null && clazz.getSuperclass() != null )
        {
            i = this.collectImplementation( clazz.getSuperclass() );
        }

        return i;
    }

    private org.w3c.dom.Element getElement( final List<Object> list, final org.w3c.dom.Element e )
    {
        for ( Object o : list )
        {
            if ( o instanceof org.w3c.dom.Element )
            {
                final org.w3c.dom.Element current = (org.w3c.dom.Element) o;
                if ( ( e.getNamespaceURI() == null
                       ? current.getNamespaceURI() == null
                       : e.getNamespaceURI().equals( current.getNamespaceURI() ) ) &&
                     ( e.getLocalName() == null
                       ? current.getLocalName() == null
                       : e.getLocalName().equals( current.getLocalName() ) ) )
                {
                    return current;
                }
            }
        }

        return null;
    }

    private javax.xml.bind.JAXBElement getElement( final List<Object> list, final javax.xml.bind.JAXBElement e )
    {
        for ( Object o : list )
        {
            if ( o instanceof javax.xml.bind.JAXBElement )
            {
                final javax.xml.bind.JAXBElement current = (javax.xml.bind.JAXBElement) o;
                if ( e.getName().equals( current.getName() ) )
                {
                    return current;
                }
            }
        }

        return null;
    }

    private void resolveClasspath( final Module cpModule, final ClassLoader classLoader )
    {
        for ( Module m : this.getModule() )
        {
            if ( m.getSpecifications() != null )
            {
                this.resolveClasspath( m.getSpecifications(), cpModule, classLoader );
            }

            if ( m.getImplementations() != null )
            {
                this.resolveClasspath( m.getImplementations(), cpModule, classLoader );
            }
        }
    }

    private void resolveClasspath( final SpecificationReference ref, final Module cpModule,
                                   final ClassLoader classLoader )
    {
        if ( this.getSpecification( ref.getIdentifier() ) == null )
        {
            this.resolveClasspath( ref.getIdentifier(), cpModule, classLoader );
        }
    }

    private void resolveClasspath( final Specifications references, final Module cpModule,
                                   final ClassLoader classLoader )
    {
        for ( SpecificationReference ref : references.getReference() )
        {
            this.resolveClasspath( ref, cpModule, classLoader );
        }
    }

    private void resolveClasspath( final Implementations implementations, final Module cpModule,
                                   final ClassLoader classLoader )
    {
        for ( Implementation implementation : implementations.getImplementation() )
        {
            if ( implementation.getSpecifications() != null )
            {
                this.resolveClasspath( implementation.getSpecifications(), cpModule, classLoader );
            }

            if ( implementation.getDependencies() != null )
            {
                this.resolveClasspath( implementation.getDependencies(), cpModule, classLoader );
            }
        }
    }

    private void resolveClasspath( final Dependencies dependencies, final Module cpModule,
                                   final ClassLoader classLoader )
    {
        for ( Dependency dependency : dependencies.getDependency() )
        {
            this.resolveClasspath( dependency, cpModule, classLoader );
        }
    }

    private boolean resolveClasspath( final String identifier, final Module cpModule, final ClassLoader classLoader )
    {
        boolean classpathSpecification = false;
        Specification specification = cpModule.getSpecifications() == null
                                      ? null : cpModule.getSpecifications().getSpecification( identifier );

        if ( specification == null )
        {
            try
            {
                final Class classpathSpec = Class.forName( identifier, true, classLoader );
                if ( java.lang.reflect.Modifier.isPublic( classpathSpec.getModifiers() ) )
                {
                    classpathSpecification = true;
                    String vendor = null;
                    String version = null;

                    if ( classpathSpec.getPackage() != null )
                    {
                        vendor = classpathSpec.getPackage().getSpecificationVendor();
                        version = classpathSpec.getPackage().getSpecificationVersion();
                    }

                    specification = new Specification();
                    specification.setIdentifier( identifier );
                    specification.setClazz( classpathSpec.getName() );
                    specification.setMultiplicity( Multiplicity.MANY );
                    specification.setVendor( vendor );
                    specification.setVersion( version );

                    if ( cpModule.getSpecifications() == null )
                    {
                        cpModule.setSpecifications( new Specifications() );
                    }

                    cpModule.getSpecifications().getSpecification().add( specification );

                    this.resolveClasspath( specification, cpModule, classLoader );
                }
            }
            catch ( final ClassNotFoundException e )
            {
                classpathSpecification = false;
            }
        }

        return classpathSpecification;
    }

    private boolean resolveClasspath( final Specification specification, final Module cpModule,
                                      final ClassLoader classLoader )
    {
        boolean classpathImplementation = false;
        Implementation implementation =
            cpModule.getImplementations() == null ? null
            : cpModule.getImplementations().getImplementation( specification.getIdentifier() );

        if ( implementation == null )
        {
            String name = null;

            try
            {
                final Class classpathImpl = Class.forName( specification.getClazz(), true, classLoader );

                if ( java.lang.reflect.Modifier.isPublic( classpathImpl.getModifiers() ) )
                {
                    if ( !java.lang.reflect.Modifier.isAbstract( classpathImpl.getModifiers() ) )
                    {
                        try
                        {
                            classpathImpl.getConstructor( NO_CLASSES );
                            name = "init";
                            classpathImplementation = true;
                        }
                        catch ( final NoSuchMethodException e )
                        {
                            classpathImplementation = false;
                        }
                    }

                    if ( !classpathImplementation )
                    {
                        final char[] c = classpathImpl.getName().substring(
                            classpathImpl.getPackage().getName().length() + 1 ).toCharArray();

                        name = String.valueOf( c );
                        c[0] = Character.toUpperCase( c[0] );

                        if ( this.checkFactoryMethod( classpathImpl, classpathImpl, "getDefault" ) )
                        {
                            name = "default";
                            classpathImplementation = true;
                        }
                        else if ( this.checkFactoryMethod( classpathImpl, classpathImpl, "getInstance" ) )
                        {
                            name = "instance";
                            classpathImplementation = true;
                        }
                        else if ( this.checkFactoryMethod( classpathImpl, classpathImpl, "get" + String.valueOf( c ) ) )
                        {
                            classpathImplementation = true;
                        }

                    }

                    if ( classpathImplementation )
                    {
                        String vendor = null;
                        String version = null;
                        if ( classpathImpl.getPackage() != null )
                        {
                            vendor = classpathImpl.getPackage().getImplementationVendor();
                            version = classpathImpl.getPackage().getImplementationVersion();
                        }

                        implementation = new Implementation();
                        implementation.setVendor( vendor );
                        implementation.setFinal( true );
                        implementation.setName( name );
                        implementation.setIdentifier( specification.getIdentifier() );
                        implementation.setClazz( classpathImpl.getName() );
                        implementation.setVersion( version );

                        final Specifications implemented = new Specifications();
                        final SpecificationReference ref = new SpecificationReference();
                        ref.setIdentifier( specification.getIdentifier() );
                        ref.setVersion( specification.getVersion() );
                        implemented.getReference().add( ref );
                        implementation.setSpecifications( implemented );

                        if ( cpModule.getImplementations() == null )
                        {
                            cpModule.setImplementations( new Implementations() );
                        }

                        cpModule.getImplementations().getImplementation().add( implementation );
                    }
                }
            }
            catch ( final ClassNotFoundException e )
            {
                classpathImplementation = false;
            }
        }

        return classpathImplementation;
    }

    private boolean checkFactoryMethod( final Class clazz, final Class type, final String methodName )
    {
        boolean factoryMethod = false;

        try
        {
            final java.lang.reflect.Method m = clazz.getMethod( methodName, (Class[]) null );
            factoryMethod = java.lang.reflect.Modifier.isStatic( m.getModifiers() ) &&
                            type.isAssignableFrom( m.getReturnType() );

        }
        catch ( final NoSuchMethodException e )
        {
            factoryMethod = false;
        }

        return factoryMethod;
    }

    private String getMessage( final String key, final Object args )
    {
        return new java.text.MessageFormat( java.util.ResourceBundle.getBundle(
            Modules.class.getName().replace( '.', '/' ), java.util.Locale.getDefault() ).
            getString( key ) ).format( args );

    }
]]>
      </ci:code>
    </jaxb:bindings>
  </jaxb:bindings>
</jaxb:bindings>
