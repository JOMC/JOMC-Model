<?xml version="1.0" encoding="UTF-8"?>
<!--

  Copyright (C) 2009 The JOMC Project
  Copyright (C) 2005 Christian Schulte <schulte2005@users.sourceforge.net>
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    o Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    o Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.

  THIS SOFTWARE IS PROVIDED BY THE JOMC PROJECT AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE JOMC PROJECT OR
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  $Id$

-->
<jaxb:bindings xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc"
               xmlns:jaxb="http://java.sun.com/xml/ns/jaxb"
               xmlns:xs="http://www.w3.org/2001/XMLSchema"
               xmlns:jomc="http://jomc.org/model"
               xmlns:ci="http://jaxb.dev.java.net/plugin/code-injector"
               version="2.0">

  <jaxb:bindings schemaLocation="jomc-1.2.xsd">
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Text']/xs:simpleContent/xs:extension/xs:attribute[@name='language']">
      <jaxb:property>
        <jaxb:javadoc>The language key of this text.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Text']/xs:simpleContent/xs:extension/xs:attribute[@name='type']">
      <jaxb:property>
        <jaxb:javadoc>The Multipurpose Internet Mail Extension (MIME) type, as defined in RFC 2045 and 2046.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Texts']">
      <ci:code><![CDATA[
    /**
     * Gets a text for a given language.
     *
     * @param language The language of the text to return.
     *
     * @return The text with language {@code language} or the default text, if no text matching {@code language} is
     * found.
     *
     * @throws NullPointerException if {@code language} is {@code null}.
     */
    public Text getText( final String language )
    {
        if ( language == null )
        {
            throw new NullPointerException( "language" );
        }

        Text defaultText = null;

        for ( int i = 0, s0 = this.getText().size(); i < s0; i++ )
        {
            final Text t = this.getText().get( i );

            if ( t.getLanguage().equals( this.getDefaultLanguage() ) )
            {
                defaultText = t;
            }
            if ( t.getLanguage().equals( language ) )
            {
                return t;
            }
        }

        return defaultText;
    }]]>
      </ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Texts']/xs:attribute[@name='defaultLanguage']">
      <jaxb:property>
        <jaxb:javadoc>Default text of this list.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='ModelObject']/xs:sequence/xs:element[@ref='jomc:documentation']">
      <jaxb:property>
        <jaxb:javadoc>Documentation of this object or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ModelObject']/xs:sequence/xs:element[@ref='jomc:authors']">
      <jaxb:property>
        <jaxb:javadoc>Authors of this object or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ModelObject']/xs:attribute[@name='modelVersion']">
      <jaxb:property>
        <jaxb:javadoc>Model version of this object.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ModelObject']/xs:attribute[@name='createDate']">
      <jaxb:property>
        <jaxb:javadoc>The date this object got created or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ModelObject']/xs:attribute[@name='deprecated']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this object is deprecated.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ModelObject']">
      <ci:code><![CDATA[
    /** Public identifier of the object management and configuration model. */
    public static final String MODEL_PUBLIC_ID = "http://jomc.org/model";

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from a given list of objects.
     *
     * @param any The list to search.
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} list or
     * {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code any}, {@code namespaceURI} or {@code localPart} is {@code null}.
     * @throws IllegalStateException if {@code any} contains more than one matching element.
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElement(java.util.List, java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    protected javax.xml.bind.JAXBElement getAnyElement( final java.util.List<Object> any, final String namespaceURI,
                                                        final String localPart )
    {
        if ( any == null )
        {
            throw new NullPointerException( "any" );
        }
        if ( namespaceURI == null )
        {
            throw new NullPointerException( "namespaceURI" );
        }
        if ( localPart == null )
        {
            throw new NullPointerException( "localPart" );
        }

        javax.xml.bind.JAXBElement<?> anyElement = null;

        for ( int i = 0, s0 = any.size(); i < s0; i++ )
        {
            final Object o = any.get( i );

            if ( o instanceof javax.xml.bind.JAXBElement<?> )
            {
                final javax.xml.bind.JAXBElement<?> e = (javax.xml.bind.JAXBElement<?>) o;

                if ( namespaceURI.equals( e.getName().getNamespaceURI() )
                     && localPart.equals( e.getName().getLocalPart() ) )
                {
                    if ( anyElement == null )
                    {
                        anyElement = e;
                    }
                    else
                    {
                        throw new IllegalStateException( getMessage( "nonUniqueElement", this.getClass().getName(),
                                                                     namespaceURI, localPart ) );

                    }
                }
            }
        }

        return anyElement;
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from a given list of
     * objects.
     *
     * @param any The list to search.
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} list - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code any}, {@code namespaceURI} or {@code localPart} is {@code null}.
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElements(java.util.List, java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    protected java.util.List<javax.xml.bind.JAXBElement> getAnyElements( final java.util.List<Object> any,
                                                                         final String namespaceURI,
                                                                         final String localPart )
    {
        if ( any == null )
        {
            throw new NullPointerException( "any" );
        }
        if ( namespaceURI == null )
        {
            throw new NullPointerException( "namespaceURI" );
        }
        if ( localPart == null )
        {
            throw new NullPointerException( "localPart" );
        }

        final java.util.List<javax.xml.bind.JAXBElement> anyElements =
            new java.util.ArrayList<javax.xml.bind.JAXBElement>( any.size() );

        for ( int i = 0, s0 = any.size(); i < s0; i++ )
        {
            final Object o = any.get( i );

            if ( o instanceof javax.xml.bind.JAXBElement<?> )
            {
                final javax.xml.bind.JAXBElement<?> e = (javax.xml.bind.JAXBElement<?>) o;

                if ( namespaceURI.equals( e.getName().getNamespaceURI() )
                     && localPart.equals( e.getName().getLocalPart() ) )
                {
                    anyElements.add( e );
                }
            }
        }

        return java.util.Collections.unmodifiableList( anyElements );
    }

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from a given list of objects.
     *
     * @param any The list to search.
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} list or
     * {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code any}, {@code namespaceURI}, {@code localPart} or {@code type} is
     * {@code null}.
     * @throws IllegalStateException if {@code any} contains more than one matching element.
     *
     * @since 1.1
     */
    protected <T> javax.xml.bind.JAXBElement<T> getAnyElement( final java.util.List<Object> any,
                                                               final String namespaceURI,
                                                               final String localPart,
                                                               final Class<T> type )
    {
        if ( any == null )
        {
            throw new NullPointerException( "any" );
        }
        if ( namespaceURI == null )
        {
            throw new NullPointerException( "namespaceURI" );
        }
        if ( localPart == null )
        {
            throw new NullPointerException( "localPart" );
        }
        if ( type == null )
        {
            throw new NullPointerException( "type" );
        }

        javax.xml.bind.JAXBElement<?> anyElement = null;

        for ( int i = 0, s0 = any.size(); i < s0; i++ )
        {
            final Object o = any.get( i );

            if ( o instanceof javax.xml.bind.JAXBElement<?> )
            {
                final javax.xml.bind.JAXBElement<?> e = (javax.xml.bind.JAXBElement<?>) o;

                if ( namespaceURI.equals( e.getName().getNamespaceURI() )
                     && localPart.equals( e.getName().getLocalPart() ) )
                {
                    if ( anyElement == null )
                    {
                        anyElement = e;
                    }
                    else
                    {
                        throw new IllegalStateException( getMessage( "nonUniqueElement", this.getClass().getName(),
                                                                     namespaceURI, localPart ) );

                    }
                }
            }
        }

        if ( anyElement != null && anyElement.getValue() != null && anyElement.getValue().getClass().equals( type ) )
        {
            @SuppressWarnings( "unchecked" ) final javax.xml.bind.JAXBElement<T> e =
                (javax.xml.bind.JAXBElement<T>) anyElement;

            return e;
        }

        return null;
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from a given list of
     * objects.
     *
     * @param any The list to search.
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} list - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code any}, {@code namespaceURI}, {@code localPart} or {@code type} is
     * {@code null}.
     *
     * @since 1.1
     */
    protected <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final java.util.List<Object> any,
                                                                                final String namespaceURI,
                                                                                final String localPart,
                                                                                final Class<T> type )
    {
        if ( any == null )
        {
            throw new NullPointerException( "any" );
        }
        if ( namespaceURI == null )
        {
            throw new NullPointerException( "namespaceURI" );
        }
        if ( localPart == null )
        {
            throw new NullPointerException( "localPart" );
        }
        if ( type == null )
        {
            throw new NullPointerException( "type" );
        }

        final java.util.List<javax.xml.bind.JAXBElement<T>> anyElements =
            new java.util.ArrayList<javax.xml.bind.JAXBElement<T>>( any.size() );

        for ( int i = 0, s0 = any.size(); i < s0; i++ )
        {
            final Object o = any.get( i );

            if ( o instanceof javax.xml.bind.JAXBElement<?> )
            {
                final javax.xml.bind.JAXBElement<?> e = (javax.xml.bind.JAXBElement<?>) o;

                if ( namespaceURI.equals( e.getName().getNamespaceURI() )
                     && localPart.equals( e.getName().getLocalPart() )
                     && e.getValue() != null && e.getValue().getClass().equals( type ) )
                {
                    @SuppressWarnings( "unchecked" ) final javax.xml.bind.JAXBElement<T> anyElement =
                        (javax.xml.bind.JAXBElement<T>) e;

                    anyElements.add( anyElement );
                }
            }
        }

        return java.util.Collections.unmodifiableList( anyElements );
    }

    /**
     * Gets a single object matching a class from a given list of objects.
     *
     * @param any The list to search.
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} list or {@code null} if no such instance is found.
     *
     * @throws NullPointerException if {@code any} or {@code clazz} is {@code null}.
     * @throws IllegalStateException if {@code any} contains more than one matching object.
     */
    protected <T> T getAnyObject( final java.util.List<Object> any, final Class<T> clazz )
    {
        if ( any == null )
        {
            throw new NullPointerException( "any" );
        }
        if ( clazz == null )
        {
            throw new NullPointerException( "clazz" );
        }

        T anyObject = null;

        for ( int i = 0, s0 = any.size(); i < s0; i++ )
        {
            Object o = any.get( i );

            if ( o instanceof javax.xml.bind.JAXBElement<?> )
            {
                o = ( (javax.xml.bind.JAXBElement<?>) o ).getValue();
            }

            if ( clazz.equals( o.getClass() ) )
            {
                if ( anyObject == null )
                {
                    @SuppressWarnings( "unchecked" ) final T object = (T) o;
                    anyObject = object;
                }
                else
                {
                    throw new IllegalStateException( getMessage( "nonUniqueObject", this.getClass().getName(),
                                                                 clazz.getName() ) );

                }
            }
        }

        return anyObject;
    }

    /**
     * Gets a list containing all objects matching a class from a given list of objects.
     *
     * @param any The list to search.
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} list - an empty list if no
     * such objects are found.
     *
     * @throws NullPointerException if {@code any} or {@code clazz} is {@code null}.
     */
    protected <T> java.util.List<T> getAnyObjects( final java.util.List<Object> any, final Class<T> clazz )
    {
        if ( any == null )
        {
            throw new NullPointerException( "any" );
        }
        if ( clazz == null )
        {
            throw new NullPointerException( "namespaceURI" );
        }

        final java.util.List<T> anyElements = new java.util.ArrayList<T>( any.size() );

        for ( int i = 0, s0 = any.size(); i < s0; i++ )
        {
            Object o = any.get( i );

            if ( o instanceof javax.xml.bind.JAXBElement<?> )
            {
                o = ( (javax.xml.bind.JAXBElement<?>) o ).getValue();
            }

            if ( clazz.equals( o.getClass() ) )
            {
                @SuppressWarnings( "unchecked" ) final T object = (T) o;
                anyElements.add( object );
            }
        }

        return java.util.Collections.unmodifiableList( anyElements );
    }

    private static String getMessage( final String key, final Object... args )
    {
        return java.text.MessageFormat.format( java.util.ResourceBundle.getBundle(
            ModelObject.class.getName().replace( '.', '/' ), java.util.Locale.getDefault() ).
            getString( key ), args );

    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:specifications']">
      <jaxb:property>
        <jaxb:javadoc>Specifications of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:implementations']">
      <jaxb:property>
        <jaxb:javadoc>Implementations of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:properties']">
      <jaxb:property>
        <jaxb:javadoc>Properties of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:messages']">
      <jaxb:property>
        <jaxb:javadoc>Messages of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>Name of this module.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>Version of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']/xs:complexContent/xs:extension/xs:attribute[@name='vendor']">
      <jaxb:property>
        <jaxb:javadoc>Vendor of this module or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Module']">
      <ci:code><![CDATA[
    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI} or {@code localPart} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String)
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElement(java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    public javax.xml.bind.JAXBElement getAnyElement( final String namespaceURI, final String localPart )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI} or {@code localPart} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String)
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElements(java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    public java.util.List<javax.xml.bind.JAXBElement> getAnyElements( final String namespaceURI,
                                                                      final String localPart )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart );
    }

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> javax.xml.bind.JAXBElement<T> getAnyElement( final String namespaceURI, final String localPart,
                                                            final Class<T> type )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final String namespaceURI,
                                                                             final String localPart,
                                                                             final Class<T> type )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a single object matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} property of the instance or {@code null} if no such
     * instance is found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching object.
     *
     * @see #getAnyObject(java.util.List, java.lang.Class)
     */
    public <T> T getAnyObject( final Class<T> clazz )
    {
        return this.getAnyObject( this.getAny(), clazz );
    }

    /**
     * Gets a list containing all objects matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} property of the instance -
     * an empty list if no such objects are found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     *
     * @see #getAnyObjects(java.util.List, java.lang.Class)
     */
    public <T> java.util.List<T> getAnyObjects( final Class<T> clazz )
    {
        return this.getAnyObjects( this.getAny(), clazz );
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Specifications']">
      <ci:code><![CDATA[
    /**
     * Gets a specification for a given identifier from the list of specifications.
     *
     * @param specification The identifier of the specification to return.
     *
     * @return The specification identified by {@code specification} from the list or {@code null}, if no specification
     * matching {@code specification} is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getSpecification()
     */
    public Specification getSpecification( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( int i = 0, s0 = this.getSpecification().size(); i < s0; i++ )
        {
            final Specification s = this.getSpecification().get( i );

            if ( specification.equals( s.getIdentifier() ) )
            {
                return s;
            }
        }

        return null;
    }

    /**
     * Gets a specification for a given class from the list of specifications.
     *
     * @param specification The class of the specification to return.
     *
     * @return The specification identified by {@code specification} from the list or {@code null}, if no specification
     * matching {@code specification} is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getSpecification()
     */
    public Specification getSpecification( final Class<?> specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( int i = 0, s0 = this.getSpecification().size(); i < s0; i++ )
        {
            final Specification s = this.getSpecification().get( i );

            if ( s.isClassDeclaration() && specification.getName().equals( s.getClazz() ) )
            {
                return s;
            }
        }

        return null;
    }

    /**
     * Gets a specification reference for a given identifier from the list of references.
     *
     * @param specification The identifier of the reference to return.
     *
     * @return The specification reference identified by {@code specification} from the list or {@code null}, if no
     * specification reference matching {@code specification} is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getReference()
     */
    public SpecificationReference getReference( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( int i = 0, s0 = this.getReference().size(); i < s0; i++ )
        {
            final SpecificationReference r = this.getReference().get( i );

            if ( specification.equals( r.getIdentifier() ) )
            {
                return r;
            }
        }

        return null;
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:properties']">
      <jaxb:property>
        <jaxb:javadoc>Properties of this specification or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='identifier']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of this specification.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='class']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of the class providing the programming interface of this specification or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='vendor']">
      <jaxb:property>
        <jaxb:javadoc>The vendor of this specification or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>The version of this specification or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='multiplicity']">
      <jaxb:property>
        <jaxb:javadoc>The implementation multiplicity of this specification. A multiplicity equal to {@link Multiplicity#ONE} specifies that no more than one implementation of the specification is allowed to exist among a set of modules (including none). A multiplicity equal to {@link Multiplicity#MANY} specifies that many implementations are allowed to exist among a set of modules (including none).</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='scope']">
      <jaxb:property>
        <jaxb:javadoc>Scope instances of implementations of this specification apply to or {@code null} if instances of implementations of this specification are not bound to any scope (multiton).</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']/xs:complexContent/xs:extension/xs:attribute[@name='classDeclaration']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this specification declares the class given by property {@code clazz}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specification']">
      <ci:code><![CDATA[
    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI} or {@code localPart} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String)
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElement(java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    public javax.xml.bind.JAXBElement getAnyElement( final String namespaceURI, final String localPart )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI} or {@code localPart} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String)
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElements(java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    public java.util.List<javax.xml.bind.JAXBElement> getAnyElements( final String namespaceURI,
                                                                      final String localPart )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart );
    }

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> javax.xml.bind.JAXBElement<T> getAnyElement( final String namespaceURI, final String localPart,
                                                            final Class<T> type )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final String namespaceURI,
                                                                             final String localPart,
                                                                             final Class<T> type )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a single object matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} property of the instance or {@code null} if no such
     * instance is found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching object.
     *
     * @see #getAnyObject(java.util.List, java.lang.Class)
     */
    public <T> T getAnyObject( final Class<T> clazz )
    {
        return this.getAnyObject( this.getAny(), clazz );
    }

    /**
     * Gets a list containing all objects matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} property of the instance -
     * an empty list if no such objects are found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     *
     * @see #getAnyObjects(java.util.List, java.lang.Class)
     */
    public <T> java.util.List<T> getAnyObjects( final Class<T> clazz )
    {
        return this.getAnyObjects( this.getAny(), clazz );
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='SpecificationReference']/xs:complexContent/xs:extension/xs:attribute[@name='identifier']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of the referenced specification.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='SpecificationReference']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>The version of the referenced specification or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='SpecificationReference']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this specification reference is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='SpecificationReference']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this specification reference is intended to override a super specification reference.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Implementations']">
      <ci:code><![CDATA[
    /**
     * Gets an implementation for a given identifier from the list.
     *
     * @param implementation The identifier of the implementation to return.
     *
     * @return The implementation identified by {@code implementation} from the list or {@code null}, if no
     * implementation matching {@code implementation} is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getImplementation()
     */
    public Implementation getImplementation( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( int i = 0, s0 = this.getImplementation().size(); i < s0; i++ )
        {
            final Implementation current = this.getImplementation().get( i );

            if ( implementation.equals( current.getIdentifier() ) )
            {
                return current;
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given class from the list.
     *
     * @param implementation The class of the implementation to return.
     *
     * @return The implementation identified by {@code implementation} from the list or {@code null}, if no
     * implementation matching {@code implementation} is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getImplementation()
     */
    public Implementation getImplementation( final Class<?> implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( int i = 0, s0 = this.getImplementation().size(); i < s0; i++ )
        {
            final Implementation current = this.getImplementation().get( i );

            if ( current.isClassDeclaration() && implementation.getName().equals( current.getClazz() ) )
            {
                return current;
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given name from the list.
     *
     * @param name The name of the implementation to return.
     *
     * @return The implementation named {@code name} from the list or {@code null}, if no implementation matching
     * {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getImplementation()
     */
    public Implementation getImplementationByName( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( int i = 0, s0 = this.getImplementation().size(); i < s0; i++ )
        {
            final Implementation current = this.getImplementation().get( i );

            if ( name.equals( current.getName() ) )
            {
                return current;
            }
        }

        return null;
    }

    /**
     * Gets an implementation reference for a given identifier from the list of references.
     *
     * @param implementation The identifier of the reference to return.
     *
     * @return The implementation reference identified by {@code implementation} from the list or {@code null}, if no
     * implementation reference matching {@code implementation} is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getReference()
     */
    public ImplementationReference getReference( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( int i = 0, s0 = this.getReference().size(); i < s0; i++ )
        {
            final ImplementationReference r = this.getReference().get( i );

            if ( implementation.equals( r.getIdentifier() ) )
            {
                return r;
            }
        }

        return null;
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:specifications']">
      <jaxb:property>
        <jaxb:javadoc>References to specifications implemented by this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:implementations']">
      <jaxb:property>
        <jaxb:javadoc>References to implementations this implementation inherits from or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:dependencies']">
      <jaxb:property>
        <jaxb:javadoc>Dependencies of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:properties']">
      <jaxb:property>
        <jaxb:javadoc>Properties of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:messages']">
      <jaxb:property>
        <jaxb:javadoc>Messages of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='identifier']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of this implementation.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>The name of this implementation.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='class']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of the class providing instances of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='location']">
      <jaxb:property>
        <jaxb:javadoc>An URI of the location providing instances of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='vendor']">
      <jaxb:property>
        <jaxb:javadoc>The vendor of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>The version of this implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this implementation is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='stateless']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if instances of this implementation do not retain state across operations.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='abstract']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this implementation is abstract.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']/xs:complexContent/xs:extension/xs:attribute[@name='classDeclaration']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this implementation declares the class given by property {@code clazz}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementation']">
      <ci:code><![CDATA[
    /**
     * Gets the location URI used for locating instances of this implementation.
     *
     * @return The location URI used for locating instances of this implementation or {@code null}, if instances of this
     * implementation do not need to be located.
     *
     * @see #getLocation()
     */
    public java.net.URI getLocationUri()
    {
        try
        {
            java.net.URI javaLocation = null;

            if ( this.getLocation() != null )
            {
                javaLocation = new java.net.URI( this.getLocation() );
            }

            return javaLocation;
        }
        catch ( final java.net.URISyntaxException e )
        {
            throw new AssertionError( e );
        }
    }

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI} or {@code localPart} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String)
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElement(java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    public javax.xml.bind.JAXBElement getAnyElement( final String namespaceURI, final String localPart )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI} or {@code localPart} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String)
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElements(java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    public java.util.List<javax.xml.bind.JAXBElement> getAnyElements( final String namespaceURI,
                                                                      final String localPart )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart );
    }

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> javax.xml.bind.JAXBElement<T> getAnyElement( final String namespaceURI, final String localPart,
                                                            final Class<T> type )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final String namespaceURI,
                                                                             final String localPart,
                                                                             final Class<T> type )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a single object matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} property of the instance or {@code null} if no such
     * instance is found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching object.
     *
     * @see #getAnyObject(java.util.List, java.lang.Class)
     */
    public <T> T getAnyObject( final Class<T> clazz )
    {
        return this.getAnyObject( this.getAny(), clazz );
    }

    /**
     * Gets a list containing all objects matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} property of the instance -
     * an empty list if no such objects are found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     *
     * @see #getAnyObjects(java.util.List, java.lang.Class)
     */
    public <T> java.util.List<T> getAnyObjects( final Class<T> clazz )
    {
        return this.getAnyObjects( this.getAny(), clazz );
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='ImplementationReference']/xs:complexContent/xs:extension/xs:attribute[@name='identifier']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of the referenced implementation.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ImplementationReference']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>The version of the referenced implementation or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ImplementationReference']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this implementation reference is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='ImplementationReference']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this implementation reference is intended to override a super implementation reference.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Dependencies']">
      <ci:code><![CDATA[
    /**
     * Gets a dependency for a given name from the list of dependencies.
     *
     * @param name The name of the dependency to return.
     *
     * @return The dependency with name {@code name} from the list or {@code null}, if no dependency matching
     * {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getDependency()
     */
    public Dependency getDependency( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "identifier" );
        }

        for ( int i = 0, s0 = this.getDependency().size(); i < s0; i++ )
        {
            final Dependency d = this.getDependency().get( i );

            if ( name.equals( d.getName() ) )
            {
                return d;
            }
        }

        return null;
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:dependencies']">
      <jaxb:property>
        <jaxb:javadoc>Dependencies of this dependency or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:messages']">
      <jaxb:property>
        <jaxb:javadoc>Messages of this dependency or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:properties']">
      <jaxb:property>
        <jaxb:javadoc>Properties of this dependency or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:attribute[@name='implementationName']">
      <jaxb:property>
        <jaxb:javadoc>Name of the selected implementation of the specification of this dependency or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>Name of this dependency.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:attribute[@name='bound']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if instances of this dependency are bound to the declaring implementation.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']/xs:complexContent/xs:extension/xs:attribute[@name='optional']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this dependency is optional.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependency']">
      <ci:code><![CDATA[
    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI} or {@code localPart} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String)
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElement(java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    public javax.xml.bind.JAXBElement getAnyElement( final String namespaceURI, final String localPart )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI} or {@code localPart} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String)
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElements(java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    public java.util.List<javax.xml.bind.JAXBElement> getAnyElements( final String namespaceURI,
                                                                      final String localPart )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart );
    }

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> javax.xml.bind.JAXBElement<T> getAnyElement( final String namespaceURI, final String localPart,
                                                            final Class<T> type )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final String namespaceURI,
                                                                             final String localPart,
                                                                             final Class<T> type )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a single object matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} property of the instance or {@code null} if no such
     * instance is found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching object.
     *
     * @see #getAnyObject(java.util.List, java.lang.Class)
     */
    public <T> T getAnyObject( final Class<T> clazz )
    {
        return this.getAnyObject( this.getAny(), clazz );
    }

    /**
     * Gets a list containing all objects matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} property of the instance -
     * an empty list if no such objects are found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     *
     * @see #getAnyObjects(java.util.List, java.lang.Class)
     */
    public <T> java.util.List<T> getAnyObjects( final Class<T> clazz )
    {
        return this.getAnyObjects( this.getAny(), clazz );
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Properties']">
      <ci:code><![CDATA[
    /**
     * Gets a property for a given name from the list of properties.
     *
     * @param name The name of the property to return.
     *
     * @return The property with name {@code name} from the list or {@code null}, if no property matching {@code name}
     * is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getProperty()
     */
    public Property getProperty( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( int i = 0, s0 = this.getProperty().size(); i < s0; i++ )
        {
            final Property p = this.getProperty().get( i );

            if ( name.equals( p.getName() ) )
            {
                return p;
            }
        }

        return null;
    }

    /**
     * Gets a property reference for a given name from the list of references.
     *
     * @param name The name of the property reference to return.
     *
     * @return The property reference with name {@code name} from the list or {@code null}, if no property reference
     * matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getReference()
     */
    public PropertyReference getReference( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( int i = 0, s0 = this.getReference().size(); i < s0; i++ )
        {
            final PropertyReference r = this.getReference().get( i );

            if ( name.equals( r.getName() ) )
            {
                return r;
            }
        }

        return null;
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:sequence/xs:any">
      <jaxb:property>
        <jaxb:javadoc>Object value of this property or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>Name of this property.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:attribute[@name='type']">
      <jaxb:property>
        <jaxb:javadoc>Type of this property or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:attribute[@name='value']">
      <jaxb:property>
        <jaxb:javadoc>String value of this property or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this property is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this property is intended to override a super property.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']">
      <ci:code><![CDATA[
    /**
     * Gets the Java value of the property.
     * <p>The Java value of the property is computed based on the following rules:
     * <ol>
     * <li>If property {@code any} is set, the Java value is computed based on the object returned by method
     * {@code getAny()} by possibly unwrapping any {@code JAXBElement} instances. If that object declares a
     * <blockquote><pre>public Object getJavaValue( ClassLoader )</pre></blockquote> method, the value returned by this
     * method is the object returned by a call to that method using reflection. If that object does not declare such a
     * method, the value returned by this method is that (possibly unwrapped) object.</li>
     * <li>If property {@code value} is set, the Java value is computed based on the values of properties {@code type}
     * and {@code value}. If property {@code type} is not set or equals {@code java.lang.String}, the value returned
     * by this method is the string value returned by method {@code getValue()}. If property {@code type} equals a name
     * of a Java primitive type, an instance of the wrapper class corresponding to that primitive type name is returned
     * instantiated by passing the value of property {@code value} to the public constructor taking a single
     * {@code java.lang.String} argument of that wrapper class. For all other values of property {@code type} an
     * instance of a class with a name equal to the value of property {@code type} is returned instantiated by passing
     * the value of property {@code value} to the public constructor taking a single {@code java.lang.String} argument
     * of that class.</li>
     * <li>If properties {@code any} and {@code value} are both {@code null}, this method returns {@code null}.</li>
     * </ol></p>
     *
     * @param classLoader The class loader to use for getting the Java value; {@code null} to use the platform's
     * bootstrap class loader.
     *
     * @return The Java value of the property or {@code null}.
     *
     * @throws PropertyException if getting the Java value of the property fails unexpectedly.
     */
    public Object getJavaValue( final ClassLoader classLoader ) throws PropertyException
    {
        try
        {
            if ( this.getAny() != null )
            {
                if ( this.getType() == null )
                {
                    throw new PropertyException( getMessage( "mandatoryType", this.getName() ) );
                }

                String typeName = this.getType();
                final int idx = typeName.indexOf( "<" );
                if ( idx != -1 )
                {
                    typeName = typeName.substring( 0, idx );
                }

                final Class<?> javaType = Class.forName( typeName, true, classLoader );
                final Object anyObject = this.getAny() instanceof JAXBElement
                                         ? ( (JAXBElement) this.getAny() ).getValue() : this.getAny();

                return this.getJavaValue( classLoader, anyObject, javaType );
            }

            Class<?> javaType = String.class;
            boolean primitive = false;

            if ( this.getType() != null )
            {
                if ( Boolean.TYPE.getName().equals( this.getType() ) )
                {
                    javaType = Boolean.class;
                    primitive = true;
                }
                else if ( Byte.TYPE.getName().equals( this.getType() ) )
                {
                    javaType = Byte.class;
                    primitive = true;
                }
                else if ( Character.TYPE.getName().equals( this.getType() ) )
                {
                    javaType = Character.class;
                    primitive = true;
                }
                else if ( Double.TYPE.getName().equals( this.getType() ) )
                {
                    javaType = Double.class;
                    primitive = true;
                }
                else if ( Float.TYPE.getName().equals( this.getType() ) )
                {
                    javaType = Float.class;
                    primitive = true;
                }
                else if ( Integer.TYPE.getName().equals( this.getType() ) )
                {
                    javaType = Integer.class;
                    primitive = true;
                }
                else if ( Long.TYPE.getName().equals( this.getType() ) )
                {
                    javaType = Long.class;
                    primitive = true;
                }
                else if ( Short.TYPE.getName().equals( this.getType() ) )
                {
                    javaType = Short.class;
                    primitive = true;
                }
                else
                {
                    String typeName = this.getType();
                    final int idx = typeName.indexOf( "<" );
                    if ( idx != -1 )
                    {
                        typeName = typeName.substring( 0, idx );
                    }

                    javaType = Class.forName( typeName, true, classLoader );
                }
            }

            if ( this.getValue() == null && primitive )
            {
                throw new PropertyException( getMessage( "mandatoryPrimitiveValue", this.getName(), this.getType() ) );
            }

            return this.getJavaValue( javaType, this.getValue() );
        }
        catch ( final ClassNotFoundException e )
        {
            throw new PropertyException( getMessage( "classNotFound", this.getName(), this.getType() ), e );
        }
    }

    private Object getJavaValue( final ClassLoader classLoader, final Object any, final Class<?> returnType )
        throws PropertyException
    {
        if ( any != null )
        {
            final String methodName = "getJavaValue";

            try
            {
                final java.lang.reflect.Method m = any.getClass().getMethod( methodName, ClassLoader.class );
                final Object result = m.invoke( any, classLoader );

                if ( result != null && !returnType.isAssignableFrom( result.getClass() ) )
                {
                    throw new PropertyException( getMessage( "illegalMethodInvocationResult", methodName,
                                                             any.getClass().getName(), result.getClass().getName(),
                                                             returnType.getName() ) );

                }

                return result;
            }
            catch ( final IllegalAccessException e )
            {
                throw new PropertyException( getMessage( "methodAccessDenied", methodName,
                                                         any.getClass().getName() ), e );

            }
            catch ( final IllegalArgumentException e )
            {
                throw new AssertionError( e );
            }
            catch ( final InvocationTargetException e )
            {
                throw new PropertyException( getMessage( "methodInvocationFailure", methodName,
                                                         any.getClass().getName() ), e );

            }
            catch ( final SecurityException e )
            {
                throw new PropertyException( getMessage( "methodAccessDenied", methodName,
                                                         any.getClass().getName() ), e );

            }
            catch ( final NoSuchMethodException e )
            {
                // Optional method not provided.
            }
        }

        return any;
    }

    private Object getJavaValue( final Class<?> type, final String value ) throws PropertyException
    {
        if ( value != null )
        {
            try
            {
                if ( type == Character.class )
                {
                    if ( value.length() != 1 )
                    {
                        throw new PropertyException( getMessage( "illegalValue", value, Character.class.getName() ) );
                    }

                    return type.getConstructor( new Class[]
                        {
                            char.class
                        } ).newInstance( new Object[]
                        {
                            value.charAt( 0 )
                        } );

                }
                else if ( type == String.class )
                {
                    return value;
                }
                else
                {
                    return type.getConstructor( new Class[]
                        {
                            String.class
                        } ).newInstance( value );

                }
            }
            catch ( final InstantiationException e )
            {
                throw new PropertyException( getMessage( "instantiationException", type.getName() ), e );
            }
            catch ( final IllegalAccessException e )
            {
                throw new PropertyException( getMessage( "constructorAccessDenied", type.getName() ), e );
            }
            catch ( final IllegalArgumentException e )
            {
                throw new AssertionError( e );
            }
            catch ( final InvocationTargetException e )
            {
                throw new PropertyException( getMessage( "constructorInvocationFailure", type.getName() ), e );
            }
            catch ( final NoSuchMethodException e )
            {
                throw new PropertyException( getMessage( "constructorNotFound", type.getName() ), e );
            }
        }

        return value;
    }

    private static String getMessage( final String key, final Object... arguments )
    {
        return java.text.MessageFormat.format( java.util.ResourceBundle.getBundle(
            Property.class.getName().replace( '.', '/' ), java.util.Locale.getDefault() ).getString( key ), arguments );

    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='PropertyReference']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>The name of the referenced property.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='PropertyReference']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this property reference is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='PropertyReference']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this property reference is intended to override a super property reference.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Messages']">
      <ci:code><![CDATA[
    /**
     * Gets a message for a given name from the list of messages.
     *
     * @param name The name of the message to return.
     *
     * @return The message with name {@code name} from the list or {@code null}, if no message matching {@code name} is
     * found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getMessage()
     */
    public Message getMessage( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( int i = 0, s0 = this.getMessage().size(); i < s0; i++ )
        {
            final Message m = this.getMessage().get( i );

            if ( name.equals( m.getName() ) )
            {
                return m;
            }
        }

        return null;
    }

    /**
     * Gets a message reference for a given name from the list of references.
     *
     * @param name The name of the message reference to return.
     *
     * @return The message reference with name {@code name} from the list or {@code null}, if no message reference
     * matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getReference()
     */
    public MessageReference getReference( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( int i = 0, s0 = this.getReference().size(); i < s0; i++ )
        {
            final MessageReference r = this.getReference().get( i );

            if ( name.equals( r.getName() ) )
            {
                return r;
            }
        }

        return null;
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Message']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:template']">
      <jaxb:property>
        <jaxb:javadoc>The localizable template of this message.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Message']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:arguments']">
      <jaxb:property>
        <jaxb:javadoc>The format arguments of this message or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Message']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>The name of this message.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Message']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this message is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Message']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this message is intended to override a super message.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Message']">
      <ci:code><![CDATA[
    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI} or {@code localPart} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String)
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElement(java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    public javax.xml.bind.JAXBElement getAnyElement( final String namespaceURI, final String localPart )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI} or {@code localPart} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String)
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElements(java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    public java.util.List<javax.xml.bind.JAXBElement> getAnyElements( final String namespaceURI,
                                                                      final String localPart )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart );
    }

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> javax.xml.bind.JAXBElement<T> getAnyElement( final String namespaceURI, final String localPart,
                                                            final Class<T> type )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final String namespaceURI,
                                                                             final String localPart,
                                                                             final Class<T> type )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a single object matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} property of the instance or {@code null} if no such
     * instance is found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching object.
     *
     * @see #getAnyObject(java.util.List, java.lang.Class)
     */
    public <T> T getAnyObject( final Class<T> clazz )
    {
        return this.getAnyObject( this.getAny(), clazz );
    }

    /**
     * Gets a list containing all objects matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} property of the instance -
     * an empty list if no such objects are found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     *
     * @see #getAnyObjects(java.util.List, java.lang.Class)
     */
    public <T> java.util.List<T> getAnyObjects( final Class<T> clazz )
    {
        return this.getAnyObjects( this.getAny(), clazz );
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='MessageReference']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>The name of the referenced message.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='MessageReference']/xs:complexContent/xs:extension/xs:attribute[@name='final']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this message reference is the final node in an inheritance hierarchy.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='MessageReference']/xs:complexContent/xs:extension/xs:attribute[@name='override']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this message reference is intended to override a super message reference.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Arguments']">
      <ci:code><![CDATA[
    /**
     * Gets an argument for a given name from the list of arguments.
     *
     * @param name The name of the argument to return.
     *
     * @return The argument with name {@code name} from the list or {@code null}, if no argument matching {@code name}
     * is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getArgument()
     */
    public Argument getArgument( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( int i = 0, s0 = this.getArgument().size(); i < s0; i++ )
        {
            final Argument a = this.getArgument().get( i );

            if ( name.equals( a.getName() ) )
            {
                return a;
            }
        }

        return null;
    }

    /**
     * Gets an argument for a given index from the list of arguments.
     *
     * @param index The index of the argument to return.
     *
     * @return The argument at {@code index} from the list.
     *
     * @throws IndexOutOfBoundsException if {@code index} is negative, greater or equal to the size of the list of
     * arguments.
     *
     * @see #getArgument()
     */
    public Argument getArgument( final int index )
    {
        if ( index < 0 || index >= this.getArgument().size() )
        {
            throw new IndexOutOfBoundsException( Integer.toString( index ) );
        }

        for ( int i = 0, s0 = this.getArgument().size(); i < s0; i++ )
        {
            final Argument a = this.getArgument().get( i );

            if ( index == a.getIndex() )
            {
                return a;
            }
        }

        return null;
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Argument']/xs:complexContent/xs:extension/xs:attribute[@name='index']">
      <jaxb:property>
        <jaxb:javadoc>Index of this argument.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Argument']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>Name of this argument.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Argument']/xs:complexContent/xs:extension/xs:attribute[@name='type']">
      <jaxb:property>
        <jaxb:javadoc>Type of this argument.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Argument']">
      <ci:code><![CDATA[
    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI} or {@code localPart} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String)
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElement(java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    public javax.xml.bind.JAXBElement getAnyElement( final String namespaceURI, final String localPart )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI} or {@code localPart} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String)
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElements(java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    public java.util.List<javax.xml.bind.JAXBElement> getAnyElements( final String namespaceURI,
                                                                      final String localPart )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart );
    }

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> javax.xml.bind.JAXBElement<T> getAnyElement( final String namespaceURI, final String localPart,
                                                            final Class<T> type )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final String namespaceURI,
                                                                             final String localPart,
                                                                             final Class<T> type )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a single object matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} property of the instance or {@code null} if no such
     * instance is found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching object.
     *
     * @see #getAnyObject(java.util.List, java.lang.Class)
     */
    public <T> T getAnyObject( final Class<T> clazz )
    {
        return this.getAnyObject( this.getAny(), clazz );
    }

    /**
     * Gets a list containing all objects matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} property of the instance -
     * an empty list if no such objects are found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     *
     * @see #getAnyObjects(java.util.List, java.lang.Class)
     */
    public <T> java.util.List<T> getAnyObjects( final Class<T> clazz )
    {
        return this.getAnyObjects( this.getAny(), clazz );
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Instances']">
      <ci:code><![CDATA[
    /**
     * Gets an instance for a given identifier from the list of instances.
     *
     * @param identifier The identifier of the instance to return.
     *
     * @return The instance identified by {@code identifier} from the list or {@code null}, if no instance matching
     * {@code identifier} is found.
     *
     * @throws NullPointerException if {@code identifier} is {@code null}.
     *
     * @see #getInstance()
     */
    public Instance getInstance( final String identifier )
    {
        if ( identifier == null )
        {
            throw new NullPointerException( "identifier" );
        }

        for ( int i = 0, s0 = this.getInstance().size(); i < s0; i++ )
        {
            final Instance current = this.getInstance().get( i );

            if ( identifier.equals( current.getIdentifier() ) )
            {
                return current;
            }
        }

        return null;
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:specifications']">
      <jaxb:property>
        <jaxb:javadoc>Specifications implemented by this instance or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:dependencies']">
      <jaxb:property>
        <jaxb:javadoc>Dependencies of this instance or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:properties']">
      <jaxb:property>
        <jaxb:javadoc>Properties of this instance or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:sequence/xs:element[@ref='jomc:messages']">
      <jaxb:property>
        <jaxb:javadoc>Messages of this instance or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:attribute[@name='identifier']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of this instance.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>The name of the implementation of the specifications implemented by this instance.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:attribute[@name='class']">
      <jaxb:property>
        <jaxb:javadoc>The identifier of the class of this instance.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']/xs:complexContent/xs:extension/xs:attribute[@name='stateless']">
      <jaxb:property>
        <jaxb:javadoc>{@code true} if this instance does not retain state across operations.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instance']">
      <ci:code><![CDATA[
    /** Maps dependency names to dependency objects. */
    @javax.xml.bind.annotation.XmlTransient private java.util.Map<String, Object> dependencyObjects;

    /** Maps property names to property objects. */
    @javax.xml.bind.annotation.XmlTransient private java.util.Map<String, Object> propertyObjects;

    /**
     * Gets a mapping of dependency names to objects bound to the instance.
     *
     * @return A mapping of dependency names to objects bound to the instance.
     */
    public java.util.Map<String, Object> getDependencyObjects()
    {
        if ( this.dependencyObjects == null )
        {
            this.dependencyObjects = new java.util.HashMap<String, Object>();
        }

        return this.dependencyObjects;
    }

    /**
     * Gets a mapping of property names to objects bound to the instance.
     *
     * @return A mapping of property names to objects bound to the instance.
     */
    public java.util.Map<String, Object> getPropertyObjects()
    {
        if ( this.propertyObjects == null )
        {
            this.propertyObjects = new java.util.HashMap<String, Object>();
        }

        return this.propertyObjects;
    }

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI} or {@code localPart} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String)
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElement(java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    public javax.xml.bind.JAXBElement getAnyElement( final String namespaceURI, final String localPart )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI} or {@code localPart} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String)
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElements(java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    public java.util.List<javax.xml.bind.JAXBElement> getAnyElements( final String namespaceURI,
                                                                      final String localPart )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart );
    }

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> javax.xml.bind.JAXBElement<T> getAnyElement( final String namespaceURI, final String localPart,
                                                            final Class<T> type )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final String namespaceURI,
                                                                             final String localPart,
                                                                             final Class<T> type )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a single object matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} property of the instance or {@code null} if no such
     * instance is found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching object.
     *
     * @see #getAnyObject(java.util.List, java.lang.Class)
     */
    public <T> T getAnyObject( final Class<T> clazz )
    {
        return this.getAnyObject( this.getAny(), clazz );
    }

    /**
     * Gets a list containing all objects matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} property of the instance -
     * an empty list if no such objects are found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     *
     * @see #getAnyObjects(java.util.List, java.lang.Class)
     */
    public <T> java.util.List<T> getAnyObjects( final Class<T> clazz )
    {
        return this.getAnyObjects( this.getAny(), clazz );
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Person']/xs:complexContent/xs:extension/xs:attribute[@name='name']">
      <jaxb:property>
        <jaxb:javadoc>Name of this person.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Person']/xs:complexContent/xs:extension/xs:attribute[@name='mail']">
      <jaxb:property>
        <jaxb:javadoc>Mail address of this person or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Person']">
      <ci:code><![CDATA[
    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI} or {@code localPart} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String)
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElement(java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    public javax.xml.bind.JAXBElement getAnyElement( final String namespaceURI, final String localPart )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI} or {@code localPart} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String)
     *
     * @deprecated As of JOMC 1.1, please use method {@link #getAnyElements(java.lang.String, java.lang.String, java.lang.Class)}.
     */
    @Deprecated
    public java.util.List<javax.xml.bind.JAXBElement> getAnyElements( final String namespaceURI,
                                                                      final String localPart )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart );
    }

    /**
     * Gets a single {@code JAXBElement} matching a namespace URI and local part from the {@code any} property of the
     * instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement} to return.
     * @param localPart The local part of the {@code JAXBElement} to return.
     * @param type The class of the type the element is bound to.
     * @param <T> The type the element is bound to.
     *
     * @return The {@code JAXBElement} matching {@code namespaceURI} and {@code localPart} from the {@code any} property
     * of the instance or {@code null} if no such element is found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching element.
     *
     * @see #getAnyElement(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> javax.xml.bind.JAXBElement<T> getAnyElement( final String namespaceURI, final String localPart,
                                                            final Class<T> type )
    {
        return this.getAnyElement( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a list containing all {@code JAXBElement}s matching a namespace URI and local part from the {@code any}
     * property of the instance.
     *
     * @param namespaceURI The namespace URI of the {@code JAXBElement}s to return.
     * @param localPart The local part of the {@code JAXBElement}s to return.
     * @param type The class of the type the elements are bound to.
     * @param <T> The type the elements are bound to.
     *
     * @return An unmodifiable list of all {@code JAXBElement}s matching {@code namespaceURI} and {@code localPart} from
     * the {@code any} property of the instance - an empty list if no such elements are found.
     *
     * @throws NullPointerException if {@code namespaceURI}, {@code localPart} or {@code type} is {@code null}.
     *
     * @see #getAnyElements(java.util.List, java.lang.String, java.lang.String, java.lang.Class)
     *
     * @since 1.1
     */
    public <T> java.util.List<javax.xml.bind.JAXBElement<T>> getAnyElements( final String namespaceURI,
                                                                             final String localPart,
                                                                             final Class<T> type )
    {
        return this.getAnyElements( this.getAny(), namespaceURI, localPart, type );
    }

    /**
     * Gets a single object matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return an instance of.
     * @param <T> The type of the object to return.
     *
     * @return The instance of {@code clazz} from the {@code any} property of the instance or {@code null} if no such
     * instance is found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     * @throws IllegalStateException if the {@code any} property contains more than one matching object.
     *
     * @see #getAnyObject(java.util.List, java.lang.Class)
     */
    public <T> T getAnyObject( final Class<T> clazz )
    {
        return this.getAnyObject( this.getAny(), clazz );
    }

    /**
     * Gets a list containing all objects matching a given class from the {@code any} property of the instance.
     *
     * @param clazz The class to return all instances of.
     * @param <T> The type of the objects to return.
     *
     * @return An unmodifiable list of all instances of {@code clazz} from the {@code any} property of the instance -
     * an empty list if no such objects are found.
     *
     * @throws NullPointerException if {@code clazz} is {@code null}.
     *
     * @see #getAnyObjects(java.util.List, java.lang.Class)
     */
    public <T> java.util.List<T> getAnyObjects( final Class<T> clazz )
    {
        return this.getAnyObjects( this.getAny(), clazz );
    }]]>
      </ci:code>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Author']/xs:complexContent/xs:extension/xs:attribute[@name='version']">
      <jaxb:property>
        <jaxb:javadoc>The version created by this author or {@code null}.</jaxb:javadoc>
      </jaxb:property>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:simpleType[@name='ArgumentType']/xs:restriction/xs:enumeration[@value='Number']">
      <jaxb:typesafeEnumMember name="NUMBER">
        <jaxb:javadoc>Argument of type {@code java.lang.Number}.</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <jaxb:bindings node="xs:simpleType[@name='ArgumentType']/xs:restriction/xs:enumeration[@value='Date']">
      <jaxb:typesafeEnumMember name="DATE">
        <jaxb:javadoc>Argument of type {@code java.util.Date}.</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <jaxb:bindings node="xs:simpleType[@name='ArgumentType']/xs:restriction/xs:enumeration[@value='Time']">
      <jaxb:typesafeEnumMember name="TIME">
        <jaxb:javadoc>Argument of type {@code java.util.Date}.</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <jaxb:bindings node="xs:simpleType[@name='ArgumentType']/xs:restriction/xs:enumeration[@value='Text']">
      <jaxb:typesafeEnumMember name="TEXT">
        <jaxb:javadoc>Argument of type {@code java.lang.String}.</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:simpleType[@name='Multiplicity']/xs:restriction/xs:enumeration[@value='One']">
      <jaxb:typesafeEnumMember name="ONE">
        <jaxb:javadoc>A multiplicity equal to {@code ONE} specifies that no more than one implementation of the specification is allowed to exist among a set of modules (including none).</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <jaxb:bindings node="xs:simpleType[@name='Multiplicity']/xs:restriction/xs:enumeration[@value='Many']">
      <jaxb:typesafeEnumMember name="MANY">
        <jaxb:javadoc>A multiplicity equal to {@code MANY} specifies that many implementations of the specification are allowed to exist among a set of modules (including none).</jaxb:javadoc>
      </jaxb:typesafeEnumMember>
    </jaxb:bindings>
    <!-- *********************************************************************************************************** -->
    <jaxb:bindings node="xs:complexType[@name='Modules']">
      <ci:code><![CDATA[
    /**
     * Constant for the default name of the classpath module.
     * @see #getDefaultClasspathModuleName()
     */
    private static final String DEFAULT_CLASSPATH_MODULE_NAME = "Java Classpath";

    /** Default classpath module name. */
    private static volatile String defaultClasspathModuleName;

    /** Empty {@code Class} array. */
    private static final Class<?>[] NO_CLASSES =
    {
    };

    /** Maps objects to {@code Instance}s. */
    @javax.xml.bind.annotation.XmlTransient private java.util.Map<Object, Instance> objects =
        new org.jomc.util.WeakIdentityHashMap();

    /**
     * Creates a new {@code Modules} instance taking a map backing the instance.
     *
     * @param objects The map backing the instance.
     */
    public Modules( final java.util.Map<Object, Instance> objects )
    {
        super();

        if ( objects == null )
        {
            throw new NullPointerException( "objects" );
        }

        this.objects = objects;
    }

    /**
     * Creates a new {@code Modules} instance by deeply copying a given {@code Modules} instance taking a map backing
     * the instance.
     *
     * @param o The instance to copy.
     * @param objects The map backing the instance.
     *
     * @throws NullPointerException if {@code o} or {@code objects} is {@code null}.
     */
    public Modules( final Modules o, final java.util.Map<Object, Instance> objects )
    {
        super( o );
        if ( o == null )
        {
            throw new NullPointerException( "Cannot create a copy of 'Modules' from 'null'." );
        }
        if ( objects == null )
        {
            throw new NullPointerException( "objects" );
        }

        copyModule( o.getModule(), getModule() );
        this.objects = objects;
    }

    /**
     * Gets the default classpath module name.
     * <p>The default classpath module name is controlled by system property
     * {@code org.jomc.model.Modules.defaultClasspathModuleName} holding the default classpath module name. If that
     * property is not set, the {@code Java Classpath} default is returned.</p>
     *
     * @return The default classpath module name.
     *
     * @see #getClasspathModule(java.lang.String, java.lang.ClassLoader)
     */
    public static String getDefaultClasspathModuleName()
    {
        if ( defaultClasspathModuleName == null )
        {
            defaultClasspathModuleName = System.getProperty( "org.jomc.model.Modules.defaultClasspathModuleName",
                                                             DEFAULT_CLASSPATH_MODULE_NAME );

        }

        return defaultClasspathModuleName;
    }

    /**
     * Sets the default classpath module name.
     *
     * @param value The new default classpath module name or {@code null},
     */
    public static void setDefaultClasspathModuleName( final String value )
    {
        defaultClasspathModuleName = value;
    }

    /**
     * Gets a module holding model objects resolved by inspecting a given class loader.
     * <p>This method searches this list of modules for unresolved references and tries to resolve each unresolved
     * reference by inspecting the given class loader.</p>
     *
     * @param moduleName The name of the module to return.
     * @param classLoader The class loader to use for resolving entities or {@code null} to resolve entities using the
     * bootstrap class loader.
     *
     * @return A module holding model objects resolved by inspecting the given class loader or {@code null} if nothing
     * is resolved.
     *
     * @throws NullPointerException if {@code moduleName} is {@code null}.
     *
     * @see #getDefaultClasspathModuleName()
     * @see #getModule()
     */
    public Module getClasspathModule( final String moduleName, final ClassLoader classLoader )
    {
        if ( moduleName == null )
        {
            throw new NullPointerException( "moduleName," );
        }

        final Module classpathModule = new Module();
        classpathModule.setVersion( System.getProperty( "java.specification.version" ) );
        classpathModule.setName( moduleName );

        this.resolveClasspath( classpathModule, classLoader );

        final boolean resolved = ( classpathModule.getSpecifications() != null
                                   && !classpathModule.getSpecifications().getSpecification().isEmpty() )
                                 || ( classpathModule.getImplementations() != null
                                      && !classpathModule.getImplementations().getImplementation().isEmpty() );

        return resolved ? classpathModule : null;
    }

    /**
     * Gets a module for a given name from this list of modules.
     *
     * @param name The name of the module to return.
     *
     * @return The module with name {@code name} from the list or {@code null}, if no module matching {@code name} is
     * found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     *
     * @see #getModule()
     */
    public Module getModule( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getName().equals( name ) )
            {
                return m;
            }
        }

        return null;
    }

    /**
     * Gets all specifications declared in this list of modules.
     *
     * @return All specifications declared in the list or {@code null}, if no specifications are declared.
     *
     * @see #getModule()
     */
    public Specifications getSpecifications()
    {
        final Specifications specifications = new Specifications();

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getSpecifications() != null )
            {
                specifications.getSpecification().addAll( m.getSpecifications().getSpecification() );
            }
        }

        return specifications.getSpecification().isEmpty() ? null : specifications;
    }

    /**
     * Gets all implementations declared in this list of modules.
     *
     * @return All implementations declared in the list or {@code null}, if no implementations are declared.
     *
     * @see #getModule()
     */
    public Implementations getImplementations()
    {
        final Implementations implementations = new Implementations();

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getImplementations() != null )
            {
                implementations.getImplementation().addAll( m.getImplementations().getImplementation() );
            }
        }

        return implementations.getImplementation().isEmpty() ? null : implementations;
    }

    /**
     * Gets the module declaring a given specification from this list of modules.
     *
     * @param specification The identifier of the specification whose declaring module to return.
     *
     * @return The module declaring {@code specification} from the list or {@code null}, if no module is found declaring
     * {@code specification}.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getModule()
     */
    public Module getModuleOfSpecification( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getSpecifications() != null && m.getSpecifications().getSpecification( specification ) != null )
            {
                return m;
            }
        }

        return null;
    }

    /**
     * Gets the module declaring a given implementation from this list of modules.
     *
     * @param implementation The identifier of the implementation whose declaring module to return.
     *
     * @return The module declaring {@code implementation} from the list or {@code null}, if no module is found
     * declaring {@code implementation}.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Module getModuleOfImplementation( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getImplementations() != null && m.getImplementations().getImplementation( implementation ) != null )
            {
                return m;
            }
        }

        return null;
    }

    /**
     * Gets a specification for a given identifier from this list of modules.
     *
     * @param specification The identifier of the specification to return.
     *
     * @return The specification identified by {@code specification} from the list or {@code null}, if no specification
     * matching {@code specification} is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getModule()
     */
    public Specification getSpecification( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getSpecifications() != null )
            {
                final Specification s = m.getSpecifications().getSpecification( specification );

                if ( s != null )
                {
                    return s;
                }
            }
        }

        return null;
    }

    /**
     * Gets a specification for a given class from this list of modules.
     *
     * @param specification The class of the specification to return.
     *
     * @return The specification identified by {@code specification} from the list or {@code null}, if no specification
     * matching {@code specification} is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getModule()
     */
    public Specification getSpecification( final Class<?> specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getSpecifications() != null )
            {
                final Specification s = m.getSpecifications().getSpecification( specification );

                if ( s != null )
                {
                    return s;
                }
            }
        }

        return null;
    }

    /**
     * Gets all specifications an implementation implements from this list of modules.
     *
     * @param implementation The identifier of the implementation to get all implemented specifications of.
     *
     * @return List of all specifications implemented by {@code implementation} from the list or {@code null}, if no
     * implementation matching {@code implementation} is found or if that implementation does not implement any
     * specification.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Specifications getSpecifications( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Specifications specs = new Specifications();
        final Implementation impl = this.getImplementation( implementation );

        this.collectSpecifications( impl, specs, new Implementations(), true );

        Implementation declaration = null;
        if ( impl != null && impl.getClazz() != null && !impl.isClassDeclaration() )
        {
            for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
            {
                final Module m = this.getModule().get( i );

                if ( m.getImplementations() != null )
                {
                    for ( int j = 0, s1 = m.getImplementations().getImplementation().size(); j < s1; j++ )
                    {
                        final Implementation current = m.getImplementations().getImplementation().get( j );

                        if ( current.getClazz() != null && current.getClazz().equals( impl.getClazz() )
                             && current.isClassDeclaration() )
                        {
                            declaration = current;
                            break;
                        }
                    }
                }
            }
        }

        if ( declaration != null )
        {
            final Specifications declaredSpecifications = this.getSpecifications( declaration.getIdentifier() );

            if ( declaredSpecifications != null )
            {
                for ( int i = 0, s0 = declaredSpecifications.getReference().size(); i < s0; i++ )
                {
                    final SpecificationReference r = declaredSpecifications.getReference().get( i );

                    if ( specs.getReference( r.getIdentifier() ) == null )
                    {
                        specs.getReference().add( r );

                        final Specification s = declaredSpecifications.getSpecification( r.getIdentifier() );

                        if ( s != null )
                        {
                            specs.getSpecification().add( s );
                        }
                    }
                }
            }
        }

        java.util.Collections.sort( specs.getSpecification(), new java.util.Comparator<Specification>()
        {

            public int compare( final Specification o1, final Specification o2 )
            {
                return o1.getIdentifier().compareTo( o2.getIdentifier() );
            }

        } );

        java.util.Collections.sort( specs.getReference(), new java.util.Comparator<SpecificationReference>()
        {

            public int compare( final SpecificationReference o1, final SpecificationReference o2 )
            {
                return o1.getIdentifier().compareTo( o2.getIdentifier() );
            }

        } );

        return specs.getSpecification().isEmpty() && specs.getReference().isEmpty() ? null : specs;
    }

    /**
     * Gets an implementation for a given identifier from this list of modules.
     *
     * @param implementation The identifier of the implementation to return.
     *
     * @return The implementation identified by {@code implementation} from the list or {@code null}, if no
     * implementation matching {@code implementation} is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Implementation getImplementation( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getImplementations() != null )
            {
                final Implementation current = m.getImplementations().getImplementation( implementation );

                if ( current != null )
                {
                    return current;
                }
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given class from this list of modules.
     *
     * @param implementation The class of the implementation to return.
     *
     * @return The implementation identified by {@code implementation} from the list or {@code null}, if no
     * implementation matching {@code implementation} is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Implementation getImplementation( final Class<?> implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getImplementations() != null )
            {
                final Implementation current = m.getImplementations().getImplementation( implementation );

                if ( current != null )
                {
                    return current;
                }
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given object from this list of modules.
     *
     * @param object The object of the implementation to return.
     *
     * @return The implementation identified by {@code object} from the list or {@code null}, if no implementation
     * matching {@code object} is found.
     *
     * @throws NullPointerException if {@code object} is {@code null}.
     *
     * @see #getModule()
     */
    public Implementation getImplementation( final Object object )
    {
        return this.collectImplementation( object.getClass() );
    }

    /**
     * Gets an implementation for a given name implementing a given specification from this list of
     * modules.
     *
     * @param specification The identifier of the specification to return an implementation of.
     * @param name The name of the implementation to return.
     *
     * @return The implementation with name {@code name} implementing the specification identified by
     * {@code specification} from the list or {@code null}, if no such implementation is found.
     *
     * @throws NullPointerException if {@code specification} or {@code name} is {@code null}.
     *
     * @see #getModule()
     */
    public Implementation getImplementation( final String specification, final String name )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        final Implementations implementations = this.getImplementations( specification );
        if ( implementations != null )
        {
            return implementations.getImplementationByName( name );
        }

        return null;
    }

    /**
     * Gets all dependencies of an implementation from this list of modules.
     *
     * @param implementation The identifier of the implementation to get all dependencies of.
     *
     * @return List of all dependencies of {@code implementation} from the list or {@code null}, if no dependencies are
     * found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Dependencies getDependencies( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Dependencies dependencies = new Dependencies();
        final Implementation impl = this.getImplementation( implementation );
        this.collectDependencies( impl, dependencies, new Implementations(), true );

        Implementation declaration = null;

        if ( impl != null && impl.getClazz() != null && !impl.isClassDeclaration() )
        {
            for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
            {
                final Module m = this.getModule().get( i );

                if ( m.getImplementations() != null )
                {
                    for ( int j = 0, s1 = m.getImplementations().getImplementation().size(); j < s1; j++ )
                    {
                        final Implementation current = m.getImplementations().getImplementation().get( j );

                        if ( current.getClazz() != null && current.getClazz().equals( impl.getClazz() )
                             && current.isClassDeclaration() )
                        {
                            declaration = current;
                            break;
                        }
                    }
                }
            }
        }

        if ( declaration != null )
        {
            final Dependencies declaredDependencies = this.getDependencies( declaration.getIdentifier() );

            if ( declaredDependencies != null )
            {
                for ( int i = 0, s0 = declaredDependencies.getDependency().size(); i < s0; i++ )
                {
                    final Dependency d = declaredDependencies.getDependency().get( i );

                    if ( dependencies.getDependency( d.getName() ) == null )
                    {
                        dependencies.getDependency().add( d );
                    }
                }
            }
        }

        java.util.Collections.sort( dependencies.getDependency(), new java.util.Comparator<Dependency>()
        {

            public int compare( final Dependency o1, final Dependency o2 )
            {
                return o1.getName().compareTo( o2.getName() );
            }

        } );

        return dependencies.getDependency().isEmpty() ? null : dependencies;
    }

    /**
     * Gets all properties of an implementation from this list of modules.
     *
     * @param implementation The identifier of the implementation to get all properties of.
     *
     * @return List of all properties of {@code implementation} from the list or {@code null}, if no properties are
     * found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Properties getProperties( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Properties properties = new Properties();
        final Implementation impl = this.getImplementation( implementation );
        this.collectProperties( impl, properties, new Implementations(), true );

        Implementation declaration = null;

        if ( impl != null && impl.getClazz() != null && !impl.isClassDeclaration() )
        {
            for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
            {
                final Module m = this.getModule().get( i );

                if ( m.getImplementations() != null )
                {
                    for ( int j = 0, s1 = m.getImplementations().getImplementation().size(); j < s1; j++ )
                    {
                        final Implementation current = m.getImplementations().getImplementation().get( j );

                        if ( current.getClazz() != null && current.getClazz().equals( current.getClazz() )
                             && current.isClassDeclaration() )
                        {
                            declaration = current;
                            break;
                        }
                    }
                }
            }
        }

        if ( declaration != null )
        {
            final Properties declaredProperties = this.getProperties( declaration.getIdentifier() );

            if ( declaredProperties != null )
            {
                for ( int i = 0, s0 = declaredProperties.getProperty().size(); i < s0; i++ )
                {
                    final Property p = declaredProperties.getProperty().get( i );

                    if ( properties.getProperty( p.getName() ) == null )
                    {
                        properties.getProperty().add( p );
                    }
                }
            }
        }

        final Properties specified = this.getSpecifiedProperties( implementation );

        if ( specified != null )
        {
            for ( int i = 0, s0 = specified.getProperty().size(); i < s0; i++ )
            {
                final Property p = specified.getProperty().get( i );

                if ( properties.getProperty( p.getName() ) == null )
                {
                    properties.getProperty().add( p );
                }
            }
        }

        java.util.Collections.sort( properties.getProperty(), new java.util.Comparator<Property>()
        {

            public int compare( final Property o1, final Property o2 )
            {
                return o1.getName().compareTo( o2.getName() );
            }

        } );

        return properties.getProperty().isEmpty() ? null : properties;
    }

    /**
     * Gets all properties specified for an implementation from this list of modules.
     *
     * @param implementation The identifier of the implementation to return specified properties of.
     *
     * @return List of all properties specified for {@code implementation} from the list or {@code null}, if no
     * properties are found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Properties getSpecifiedProperties( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Properties properties = new Properties();
        final Specifications specs = this.getSpecifications( implementation );

        if ( specs != null )
        {
            for ( int i = 0, s0 = specs.getSpecification().size(); i < s0; i++ )
            {
                final Specification s = specs.getSpecification().get( i );

                if ( s.getProperties() != null )
                {
                    properties.getProperty().addAll( s.getProperties().getProperty() );
                }
            }
        }

        java.util.Collections.sort( properties.getProperty(), new java.util.Comparator<Property>()
        {

            public int compare( final Property o1, final Property o2 )
            {
                return o1.getName().compareTo( o2.getName() );
            }

        } );

        return properties.getProperty().isEmpty() ? null : properties;
    }

    /**
     * Gets all messages of an implementation from this list of modules.
     *
     * @param implementation The identifier of the implementation to get all messages of.
     *
     * @return List of all messages of {@code implementation} from the list or {@code null}, if no messages are found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Messages getMessages( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Messages msgs = new Messages();
        final Implementation impl = this.getImplementation( implementation );
        this.collectMessages( impl, msgs, new Implementations(), true );

        Implementation declaration = null;

        if ( impl != null && impl.getClazz() != null && !impl.isClassDeclaration() )
        {
            for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
            {
                final Module m = this.getModule().get( i );

                if ( m.getImplementations() != null )
                {
                    for ( int j = 0, s1 = m.getImplementations().getImplementation().size(); j < s1; j++ )
                    {
                        final Implementation current = m.getImplementations().getImplementation().get( j );

                        if ( current.getClazz() != null && current.getClazz().equals( impl.getClazz() )
                             && current.isClassDeclaration() )
                        {
                            declaration = current;
                            break;
                        }
                    }
                }
            }
        }

        if ( declaration != null )
        {
            final Messages declaredMessages = this.getMessages( declaration.getIdentifier() );

            if ( declaredMessages != null )
            {
                for ( int i = 0, s0 = declaredMessages.getMessage().size(); i < s0; i++ )
                {
                    final Message m = declaredMessages.getMessage().get( i );

                    if ( msgs.getMessage( m.getName() ) == null )
                    {
                        msgs.getMessage().add( m );
                    }
                }
            }
        }

        java.util.Collections.sort( msgs.getMessage(), new java.util.Comparator<Message>()
        {

            public int compare( final Message o1, final Message o2 )
            {
                return o1.getName().compareTo( o2.getName() );
            }

        } );

        return msgs.getMessage().isEmpty() ? null : msgs;
    }

    /**
     * Gets all implementations implementing a given specification from this list of modules.
     *
     * @param specification The identifier of the specification to return all implementations of.
     *
     * @return All implementations implementing the specification identified by {@code specification} from the list or
     * {@code null}, if no implementation implementing {@code specification} is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     *
     * @see #getModule()
     */
    public Implementations getImplementations( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        final Implementations implementations = new Implementations();

        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getImplementations() != null )
            {
                for ( int j = 0, s1 = m.getImplementations().getImplementation().size(); j < s1; j++ )
                {
                    final Implementation impl = m.getImplementations().getImplementation().get( j );
                    final Specifications specs = this.getSpecifications( impl.getIdentifier() );

                    if ( specs != null && specs.getSpecification( specification ) != null )
                    {
                        implementations.getImplementation().add( impl );
                    }
                }
            }
        }

        return implementations.getImplementation().size() > 0 ? implementations : null;
    }

    /**
     * Merges this list of modules to a single module.
     *
     * @param name The name of the module to return.
     *
     * @return A module holding all model objects from the list.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     */
    public Module getMergedModule( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        final Modules copy = this.clone();
        final Module mergedModule = new Module();
        mergedModule.setName( name );

        for ( int i = 0, s0 = copy.getModule().size(); i < s0; i++ )
        {
            final Module m = copy.getModule().get( i );
            final java.util.Set<String> referencedMessages = new java.util.HashSet<String>();
            final java.util.Set<String> referencedProperties = new java.util.HashSet<String>();

            if ( m.getImplementations() != null )
            {
                for ( int j = 0, s1 = m.getImplementations().getImplementation().size(); j < s1; j++ )
                {
                    final Implementation impl = m.getImplementations().getImplementation().get( j );
                    if ( mergedModule.getImplementations() == null )
                    {
                        mergedModule.setImplementations( new Implementations() );
                    }

                    if ( impl.getMessages() != null && !impl.getMessages().getReference().isEmpty() )
                    {
                        for ( java.util.Iterator<MessageReference> it = impl.getMessages().getReference().iterator();
                              it.hasNext(); )
                        {
                            final String messageName = it.next().getName();
                            impl.getMessages().getMessage().add( m.getMessages().getMessage( messageName ) );
                            referencedMessages.add( messageName );
                            it.remove();
                        }
                    }

                    if ( impl.getProperties() != null && !impl.getProperties().getReference().isEmpty() )
                    {
                        for ( java.util.Iterator<PropertyReference> it = impl.getProperties().getReference().iterator();
                              it.hasNext(); )
                        {
                            final String propertyName = it.next().getName();
                            impl.getProperties().getProperty().add( m.getProperties().getProperty( propertyName ) );
                            referencedProperties.add( propertyName );
                            it.remove();
                        }
                    }

                    mergedModule.getImplementations().getImplementation().add( impl );
                }
            }

            if ( m.getSpecifications() != null )
            {
                if ( mergedModule.getSpecifications() == null )
                {
                    mergedModule.setSpecifications( new Specifications() );
                }

                for ( int j = 0, s1 = m.getSpecifications().getSpecification().size(); j < s1; j++ )
                {
                    final Specification s = m.getSpecifications().getSpecification().get( j );

                    if ( s.getProperties() != null && !s.getProperties().getReference().isEmpty() )
                    {
                        for ( java.util.Iterator<PropertyReference> it = s.getProperties().getReference().iterator();
                              it.hasNext(); )
                        {
                            final String propertyName = it.next().getName();
                            s.getProperties().getProperty().add( m.getProperties().getProperty( propertyName ) );
                            referencedProperties.add( propertyName );
                            it.remove();
                        }
                    }

                    mergedModule.getSpecifications().getSpecification().add( s );
                }
            }

            for ( String messageName : referencedMessages )
            {
                for ( java.util.Iterator<Message> it = m.getMessages().getMessage().iterator(); it.hasNext(); )
                {
                    if ( messageName.equals( it.next().getName() ) )
                    {
                        it.remove();
                        break;
                    }
                }
            }

            for ( String propertyName : referencedProperties )
            {
                for ( java.util.Iterator<Property> it = m.getProperties().getProperty().iterator(); it.hasNext(); )
                {
                    if ( propertyName.equals( it.next().getName() ) )
                    {
                        it.remove();
                        break;
                    }
                }
            }

            if ( m.getProperties() != null && !m.getProperties().getProperty().isEmpty() )
            {
                if ( mergedModule.getProperties() == null )
                {
                    mergedModule.setProperties( new Properties() );
                }

                mergedModule.getProperties().getProperty().addAll( m.getProperties().getProperty() );
            }

            if ( m.getMessages() != null && !m.getMessages().getMessage().isEmpty() )
            {
                if ( mergedModule.getMessages() == null )
                {
                    mergedModule.setMessages( new Messages() );
                }

                mergedModule.getMessages().getMessage().addAll( m.getMessages().getMessage() );
            }
        }

        return mergedModule;
    }

    /**
     * Gets the instance of an object from this list of modules.
     *
     * @param object The object to get the instance of.
     *
     * @return The instance of {@code object} from the list or {@code null} if no such instance is found.
     *
     * @throws NullPointerException if {@code object} is {@code null}.
     *
     * @see #getModule()
     * @see #createObject(org.jomc.model.Instance instance, java.lang.ClassLoader classLoader)
     */
    public Instance getInstance( final Object object )
    {
        if ( object == null )
        {
            throw new NullPointerException( "object" );
        }

        synchronized ( this.objects )
        {
            Instance instance = this.objects.get( object );

            if ( instance == null )
            {
                final Implementation i = this.getImplementation( object );

                if ( i != null )
                {
                    instance = this.getInstance( i.getIdentifier() );
                    if ( instance != null )
                    {
                        this.objects.put( object, instance );
                    }
                }
            }

            return instance;
        }
    }

    /**
     * Gets an instance for an implementation from this list of modules.
     *
     * @param implementation The identifier of the implementation to get an instance for.
     *
     * @return An instance for the implementation identified by {@code implementation} from the list or {@code null}, if
     * no such instance is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     *
     * @see #getModule()
     */
    public Instance getInstance( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Implementation i = this.getImplementation( implementation );

        if ( i != null && i.getClazz() != null )
        {
            final Instance instance = new Instance();
            instance.setIdentifier( i.getIdentifier() );
            instance.setName( i.getName() );
            instance.setClazz( i.getClazz() );
            instance.setStateless( i.isStateless() );
            instance.setDependencies( this.getDependencies( implementation ) );
            instance.setProperties( this.getProperties( implementation ) );
            instance.setMessages( this.getMessages( implementation ) );
            instance.setSpecifications( this.getSpecifications( implementation ) );
            this.collectAny( i, instance.getAny(), new Implementations(), true );
            return instance;
        }

        return null;
    }

    /**
     * Gets an instance for an implementation from this list of modules overridden with a given dependency.
     *
     * @param implementation The identifier of the implementation to get an instance for.
     * @param dependency The dependency to use for overriding model objects of the instance.
     *
     * @return An instance for the implementation identified by {@code implementation} from the list with any model
     * objects overridden using {@code dependency} or {@code null}, if no such instance is found.
     *
     * @throws NullPointerException if {@code implementation} or {@code dependency} is {@code null}.
     *
     * @see #getModule()
     */
    public Instance getInstance( final String implementation, final Dependency dependency )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }
        if ( dependency == null )
        {
            throw new NullPointerException( "dependency" );
        }

        Instance instance = this.getInstance( implementation );

        if ( instance != null )
        {
            final Specification dependencySpecification = this.getSpecification( dependency.getIdentifier() );

            if ( dependencySpecification != null && dependencySpecification.getScope() == null )
            {
                if ( dependency.getDependencies() != null && !dependency.getDependencies().getDependency().isEmpty() )
                {
                    final Dependencies dependencies = new Dependencies();
                    dependencies.getDependency().addAll( dependency.getDependencies().getDependency() );

                    if ( instance.getDependencies() != null )
                    {
                        for ( int i = 0, s0 = instance.getDependencies().getDependency().size(); i < s0; i++ )
                        {
                            final Dependency d = instance.getDependencies().getDependency().get( i );
                            final Dependency td = dependencies.getDependency( d.getName() );

                            if ( td == null )
                            {
                                dependencies.getDependency().add( d );
                            }
                            else
                            {
                                this.collectDependencies( d, td );
                            }
                        }
                    }

                    instance.setDependencies( dependencies );
                }

                if ( dependency.getMessages() != null && !dependency.getMessages().getMessage().isEmpty() )
                {
                    final Messages messages = new Messages();
                    messages.getMessage().addAll( dependency.getMessages().getMessage() );

                    if ( instance.getMessages() != null )
                    {
                        for ( int i = 0, s0 = instance.getMessages().getMessage().size(); i < s0; i++ )
                        {
                            final Message m = instance.getMessages().getMessage().get( i );

                            if ( messages.getMessage( m.getName() ) == null )
                            {
                                messages.getMessage().add( m );
                            }
                        }
                    }

                    instance.setMessages( messages );
                }

                if ( dependency.getProperties() != null && !dependency.getProperties().getProperty().isEmpty() )
                {
                    final Properties properties = new Properties();
                    properties.getProperty().addAll( dependency.getProperties().getProperty() );

                    if ( instance.getProperties() != null )
                    {
                        for ( int i = 0, s0 = instance.getProperties().getProperty().size(); i < s0; i++ )
                        {
                            final Property p = instance.getProperties().getProperty().get( i );

                            if ( properties.getProperty( p.getName() ) == null )
                            {
                                properties.getProperty().add( p );
                            }
                        }
                    }

                    instance.setProperties( properties );
                }
            }
        }

        return instance;
    }

    /**
     * Creates an object for a given instance from this list of modules.
     *
     * @param instance The instance to create an object of.
     * @param classLoader The class loader to use for creating the object or {@code null} to use the bootstrap class
     * loader.
     *
     * @return A new object of {@code instance} from the list or {@code null} if no such object is found.
     *
     * @throws NullPointerException if {@code instance}  is {@code null},
     * @throws InstantiationException if creating an object fails.
     *
     * @see #getModule()
     */
    public Object createObject( final Instance instance, final ClassLoader classLoader ) throws InstantiationException
    {
        if ( instance == null )
        {
            throw new NullPointerException( "instance" );
        }

        Object object = null;

        try
        {
            final Class<?> clazz = Class.forName( instance.getClazz(), true, classLoader );

            if ( java.lang.reflect.Modifier.isPublic( clazz.getModifiers() ) )
            {
                java.lang.reflect.Constructor ctor = null;

                if ( !java.lang.reflect.Modifier.isAbstract( clazz.getModifiers() ) )
                {
                    try
                    {
                        ctor = clazz.getConstructor( NO_CLASSES );
                    }
                    catch ( final NoSuchMethodException e )
                    {
                        ctor = null;
                    }
                }

                boolean assignable = true;
                if ( instance.getSpecifications() != null )
                {
                    for ( int i = 0, s0 = instance.getSpecifications().getSpecification().size(); i < s0; i++ )
                    {
                        final Specification s = instance.getSpecifications().getSpecification().get( i );

                        if ( s.getClazz() != null )
                        {
                            final Class<?> specClass = Class.forName( s.getClazz(), true, classLoader );

                            if ( !specClass.isAssignableFrom( clazz ) )
                            {
                                assignable = false;
                                break;
                            }
                        }
                    }
                }

                if ( ctor != null && assignable )
                {
                    synchronized ( this.objects )
                    {
                        object = clazz.newInstance();
                        this.objects.put( object, instance );
                    }
                }
                else
                {
                    java.lang.reflect.Method factoryMethod = null;
                    String methodName = null;

                    char[] c = instance.getName().toCharArray();
                    c[0] = Character.toUpperCase( c[0] );
                    methodName = "get" + String.valueOf( c );

                    boolean javaIdentifier = Character.isJavaIdentifierStart( c[0] );
                    if ( javaIdentifier )
                    {
                        for ( int idx = c.length - 1; idx > 0; idx-- )
                        {
                            if ( !Character.isJavaIdentifierPart( c[idx] ) )
                            {
                                javaIdentifier = false;
                                break;
                            }
                        }
                    }

                    if ( javaIdentifier )
                    {
                        try
                        {
                            factoryMethod = clazz.getMethod( methodName, (Class[]) null );
                        }
                        catch ( final NoSuchMethodException e )
                        {
                            factoryMethod = null;
                        }
                    }

                    if ( factoryMethod == null )
                    {
                        try
                        {
                            factoryMethod = clazz.getMethod( "getObject", (Class[]) null );
                        }
                        catch ( final NoSuchMethodException e )
                        {
                            factoryMethod = null;
                        }
                    }

                    if ( factoryMethod == null )
                    {
                        throw new InstantiationException( getMessage( "failedCreatingObject", instance.getIdentifier(),
                                                                      clazz.getName(), methodName ) );

                    }

                    if ( java.lang.reflect.Modifier.isStatic( factoryMethod.getModifiers() ) )
                    {
                        synchronized ( this.objects )
                        {
                            object = factoryMethod.invoke( null, (Object[]) null );
                            if ( object != null )
                            {
                                this.objects.put( object, instance );
                            }
                        }
                    }
                    else if ( ctor != null )
                    {
                        synchronized ( this.objects )
                        {
                            final Object o = ctor.newInstance();
                            this.objects.put( o, instance );

                            try
                            {
                                object = factoryMethod.invoke( o, (Object[]) null );
                            }
                            finally
                            {
                                this.objects.remove( o );
                            }

                            if ( object != null )
                            {
                                this.objects.put( object, instance );
                            }
                        }
                    }
                    else
                    {
                        throw new InstantiationException( getMessage( "failedCreatingObject", instance.getIdentifier(),
                                                                      clazz.getName(), methodName ) );

                    }
                }
            }

            return object;
        }
        catch ( final java.lang.reflect.InvocationTargetException e )
        {
            final Throwable target = e.getTargetException() != null ? e.getTargetException() : e;
            throw (InstantiationException) new InstantiationException(
                getMessage( "exceptionCreatingObject", instance.getIdentifier() ) ).initCause( target );

        }
        catch ( final IllegalAccessException e )
        {
            throw (InstantiationException) new InstantiationException(
                getMessage( "exceptionCreatingObject", instance.getIdentifier() ) ).initCause( e );

        }
        catch ( final ClassNotFoundException e )
        {
            throw (InstantiationException) new InstantiationException(
                getMessage( "exceptionCreatingObject", instance.getIdentifier() ) ).initCause( e );

        }
    }

    private void collectSpecifications( final Implementation implementation, final Specifications specifications,
                                        final Implementations seen, final boolean includeDeclared )
    {
        if ( implementation != null && seen.getImplementation( implementation.getIdentifier() ) == null )
        {
            seen.getImplementation().add( implementation );

            if ( includeDeclared && implementation.getSpecifications() != null )
            {
                for ( int i = 0, s0 = implementation.getSpecifications().getReference().size(); i < s0; i++ )
                {
                    final SpecificationReference r = implementation.getSpecifications().getReference().get( i );

                    if ( specifications.getReference( r.getIdentifier() ) == null )
                    {
                        specifications.getReference().add( r );

                        final Specification s = this.getSpecification( r.getIdentifier() );
                        if ( s != null && specifications.getSpecification( s.getIdentifier() ) == null )
                        {
                            specifications.getSpecification().add( s );
                        }
                    }
                }
            }

            if ( implementation.getImplementations() != null )
            {
                for ( int i = 0, s0 = implementation.getImplementations().getReference().size(); i < s0; i++ )
                {
                    final ImplementationReference r = implementation.getImplementations().getReference().get( i );

                    this.collectSpecifications(
                        this.getImplementation( r.getIdentifier() ), specifications, seen, true );

                }
            }
        }
    }

    private void collectDependencies( final Implementation implementation, final Dependencies dependencies,
                                      final Implementations seen, final boolean includeDeclared )
    {
        if ( implementation != null && seen.getImplementation( implementation.getIdentifier() ) == null )
        {
            seen.getImplementation().add( implementation );

            if ( includeDeclared && implementation.getDependencies() != null )
            {
                for ( int i = 0, s0 = implementation.getDependencies().getDependency().size(); i < s0; i++ )
                {
                    final Dependency d = implementation.getDependencies().getDependency().get( i );
                    final Dependency dependency = dependencies.getDependency( d.getName() );

                    if ( dependency == null )
                    {
                        dependencies.getDependency().add( d );
                    }
                    else
                    {
                        this.collectDependencies( d, dependency );
                    }
                }
            }

            if ( implementation.getImplementations() != null )
            {
                for ( int i = 0, s0 = implementation.getImplementations().getReference().size(); i < s0; i++ )
                {
                    final ImplementationReference r = implementation.getImplementations().getReference().get( i );

                    this.collectDependencies(
                        this.getImplementation( r.getIdentifier() ), dependencies, seen, true );

                }
            }
        }
    }

    private void collectDependencies( final Dependency source, final Dependency target )
    {
        if ( source.getMessages() != null )
        {
            if ( target.getMessages() == null )
            {
                target.setMessages( new Messages() );
            }

            for ( int i = 0, s0 = source.getMessages().getMessage().size(); i < s0; i++ )
            {
                final Message m = source.getMessages().getMessage().get( i );

                if ( target.getMessages().getMessage( m.getName() ) == null )
                {
                    target.getMessages().getMessage().add( m );
                }
            }
        }

        if ( source.getProperties() != null )
        {
            if ( target.getProperties() == null )
            {
                target.setProperties( new Properties() );
            }

            for ( int i = 0, s0 = source.getProperties().getProperty().size(); i < s0; i++ )
            {
                final Property p = source.getProperties().getProperty().get( i );

                if ( target.getProperties().getProperty( p.getName() ) == null )
                {
                    target.getProperties().getProperty().add( p );
                }
            }
        }

        if ( source.getDependencies() != null )
        {
            if ( target.getDependencies() == null )
            {
                target.setDependencies( new Dependencies() );
            }

            for ( int i = 0, s0 = source.getDependencies().getDependency().size(); i < s0; i++ )
            {
                final Dependency sd = source.getDependencies().getDependency().get( i );
                final Dependency td = target.getDependencies().getDependency( sd.getName() );

                if ( td == null )
                {
                    target.getDependencies().getDependency().add( sd );
                }
                else
                {
                    this.collectDependencies( sd, td );
                }
            }
        }
    }

    private void collectProperties( final Implementation implementation, final Properties properties,
                                    final Implementations seen, final boolean includeDeclared )
    {
        if ( implementation != null && seen.getImplementation( implementation.getIdentifier() ) == null )
        {
            seen.getImplementation().add( implementation );

            if ( includeDeclared && implementation.getProperties() != null )
            {
                for ( int i = 0, s0 = implementation.getProperties().getProperty().size(); i < s0; i++ )
                {
                    final Property p = implementation.getProperties().getProperty().get( i );

                    if ( properties.getProperty( p.getName() ) == null )
                    {
                        properties.getProperty().add( p );
                    }
                }

                if ( !implementation.getProperties().getReference().isEmpty() )
                {
                    final Module m = this.getModuleOfImplementation( implementation.getIdentifier() );

                    if ( m != null )
                    {
                        for ( int i = 0, s0 = implementation.getProperties().getReference().size(); i < s0; i++ )
                        {
                            final PropertyReference ref = implementation.getProperties().getReference().get( i );

                            if ( properties.getProperty( ref.getName() ) == null )
                            {
                                Property referenced = m.getProperties().getProperty( ref.getName() );
                                if ( referenced != null )
                                {
                                    referenced = new Property( referenced );
                                    referenced.setDeprecated( ref.isDeprecated() );
                                    referenced.setFinal( ref.isFinal() );
                                    referenced.setOverride( ref.isOverride() );
                                    properties.getProperty().add( referenced );
                                }
                            }
                        }
                    }
                }
            }

            if ( implementation.getImplementations() != null )
            {
                for ( int i = 0, s0 = implementation.getImplementations().getReference().size(); i < s0; i++ )
                {
                    final ImplementationReference r = implementation.getImplementations().getReference().get( i );
                    this.collectProperties( this.getImplementation( r.getIdentifier() ), properties, seen, true );
                }
            }
        }
    }

    private void collectMessages( final Implementation implementation, final Messages messages,
                                  final Implementations seen, final boolean includeDeclared )
    {
        if ( implementation != null && seen.getImplementation( implementation.getIdentifier() ) == null )
        {
            seen.getImplementation().add( implementation );

            if ( includeDeclared && implementation.getMessages() != null )
            {
                for ( int i = 0, s0 = implementation.getMessages().getMessage().size(); i < s0; i++ )
                {
                    final Message msg = implementation.getMessages().getMessage().get( i );

                    if ( messages.getMessage( msg.getName() ) == null )
                    {
                        messages.getMessage().add( msg );
                    }
                }

                if ( !implementation.getMessages().getReference().isEmpty() )
                {
                    final Module m = this.getModuleOfImplementation( implementation.getIdentifier() );

                    if ( m != null )
                    {
                        for ( int i = 0, s0 = implementation.getMessages().getReference().size(); i < s0; i++ )
                        {
                            final MessageReference ref = implementation.getMessages().getReference().get( i );

                            if ( messages.getMessage( ref.getName() ) == null )
                            {
                                Message referenced = m.getMessages().getMessage( ref.getName() );
                                if ( referenced != null )
                                {
                                    referenced = new Message( referenced );
                                    referenced.setDeprecated( ref.isDeprecated() );
                                    referenced.setFinal( ref.isFinal() );
                                    referenced.setOverride( ref.isOverride() );
                                    messages.getMessage().add( referenced );
                                }
                            }
                        }
                    }
                }
            }

            if ( implementation.getImplementations() != null )
            {
                for ( int i = 0, s0 = implementation.getImplementations().getReference().size(); i < s0; i++ )
                {
                    final ImplementationReference r = implementation.getImplementations().getReference().get( i );
                    this.collectMessages( this.getImplementation( r.getIdentifier() ), messages, seen, true );
                }
            }
        }
    }

    private void collectAny( final Implementation implementation, final List<Object> any, final Implementations seen,
                             final boolean includeDeclared )
    {
        if ( implementation != null && seen.getImplementation( implementation.getIdentifier() ) == null )
        {
            seen.getImplementation().add( implementation );

            if ( includeDeclared && !implementation.getAny().isEmpty() )
            {
                for ( int i = 0, s0 = implementation.getAny().size(); i < s0; i++ )
                {
                    final Object o = implementation.getAny().get( i );

                    if ( o instanceof org.w3c.dom.Element )
                    {
                        if ( this.getElement( any, (org.w3c.dom.Element) o ) == null )
                        {
                            any.add( o );
                        }

                        continue;
                    }

                    if ( o instanceof javax.xml.bind.JAXBElement )
                    {
                        if ( this.getElement( any, (javax.xml.bind.JAXBElement) o ) == null )
                        {
                            any.add( o );
                        }

                        continue;
                    }

                    any.add( o );
                }
            }

            if ( implementation.getImplementations() != null )
            {
                for ( int i = 0, s0 = implementation.getImplementations().getReference().size(); i < s0; i++ )
                {
                    final ImplementationReference r = implementation.getImplementations().getReference().get( i );
                    this.collectAny( this.getImplementation( r.getIdentifier() ), any, seen, true );
                }
            }
        }
    }

    private Implementation collectImplementation( final Class<?> clazz )
    {
        Implementation i = this.getImplementation( clazz );
        if ( i == null && clazz.getSuperclass() != null )
        {
            i = this.collectImplementation( clazz.getSuperclass() );
        }

        return i;
    }

    private org.w3c.dom.Element getElement( final List<Object> list, final org.w3c.dom.Element e )
    {
        for ( int i = 0, s0 = list.size(); i < s0; i++ )
        {
            final Object o = list.get( i );

            if ( o instanceof org.w3c.dom.Element )
            {
                final org.w3c.dom.Element current = (org.w3c.dom.Element) o;
                if ( ( e.getNamespaceURI() == null
                       ? current.getNamespaceURI() == null
                       : e.getNamespaceURI().equals( current.getNamespaceURI() ) )
                     && ( e.getLocalName() == null
                          ? current.getLocalName() == null
                          : e.getLocalName().equals( current.getLocalName() ) ) )
                {
                    return current;
                }
            }
        }

        return null;
    }

    private javax.xml.bind.JAXBElement getElement( final List<Object> list, final javax.xml.bind.JAXBElement e )
    {
        for ( int i = 0, s0 = list.size(); i < s0; i++ )
        {
            final Object o = list.get( i );

            if ( o instanceof javax.xml.bind.JAXBElement )
            {
                final javax.xml.bind.JAXBElement current = (javax.xml.bind.JAXBElement) o;
                if ( e.getName().equals( current.getName() ) )
                {
                    return current;
                }
            }
        }

        return null;
    }

    private void resolveClasspath( final Module cpModule, final ClassLoader classLoader )
    {
        for ( int i = 0, s0 = this.getModule().size(); i < s0; i++ )
        {
            final Module m = this.getModule().get( i );

            if ( m.getSpecifications() != null )
            {
                this.resolveClasspath( m.getSpecifications(), cpModule, classLoader );
            }

            if ( m.getImplementations() != null )
            {
                this.resolveClasspath( m.getImplementations(), cpModule, classLoader );
            }
        }
    }

    private void resolveClasspath( final SpecificationReference ref, final Module cpModule,
                                   final ClassLoader classLoader )
    {
        if ( this.getSpecification( ref.getIdentifier() ) == null )
        {
            this.resolveClasspath( ref.getIdentifier(), cpModule, classLoader );
        }
    }

    private void resolveClasspath( final Specifications references, final Module cpModule,
                                   final ClassLoader classLoader )
    {
        for ( int i = 0, s0 = references.getReference().size(); i < s0; i++ )
        {
            final SpecificationReference ref = references.getReference().get( i );
            this.resolveClasspath( ref, cpModule, classLoader );
        }
    }

    private void resolveClasspath( final Implementations implementations, final Module cpModule,
                                   final ClassLoader classLoader )
    {
        for ( int i = 0, s0 = implementations.getImplementation().size(); i < s0; i++ )
        {
            final Implementation implementation = implementations.getImplementation().get( i );

            if ( implementation.getSpecifications() != null )
            {
                this.resolveClasspath( implementation.getSpecifications(), cpModule, classLoader );
            }

            if ( implementation.getDependencies() != null )
            {
                this.resolveClasspath( implementation.getDependencies(), cpModule, classLoader );
            }
        }
    }

    private void resolveClasspath( final Dependencies dependencies, final Module cpModule,
                                   final ClassLoader classLoader )
    {
        for ( int i = 0, s0 = dependencies.getDependency().size(); i < s0; i++ )
        {
            final Dependency dependency = dependencies.getDependency().get( i );
            this.resolveClasspath( dependency, cpModule, classLoader );
        }
    }

    private boolean resolveClasspath( final String identifier, final Module cpModule, final ClassLoader classLoader )
    {
        boolean classpathSpecification = false;
        Specification specification = cpModule.getSpecifications() == null
                                      ? null : cpModule.getSpecifications().getSpecification( identifier );

        if ( specification == null )
        {
            try
            {
                final Class<?> classpathSpec = Class.forName( identifier, true, classLoader );
                if ( java.lang.reflect.Modifier.isPublic( classpathSpec.getModifiers() ) )
                {
                    classpathSpecification = true;
                    String vendor = null;
                    String version = null;

                    if ( classpathSpec.getPackage() != null )
                    {
                        vendor = classpathSpec.getPackage().getSpecificationVendor();
                        version = classpathSpec.getPackage().getSpecificationVersion();
                    }

                    specification = new Specification();
                    specification.setIdentifier( identifier );
                    specification.setClazz( classpathSpec.getName() );
                    specification.setMultiplicity( Multiplicity.MANY );
                    specification.setVendor( vendor );
                    specification.setVersion( version );

                    if ( cpModule.getSpecifications() == null )
                    {
                        cpModule.setSpecifications( new Specifications() );
                    }

                    cpModule.getSpecifications().getSpecification().add( specification );

                    this.resolveClasspath( specification, cpModule, classLoader );
                }
            }
            catch ( final ClassNotFoundException e )
            {
                classpathSpecification = false;
            }
        }

        return classpathSpecification;
    }

    private boolean resolveClasspath( final Specification specification, final Module cpModule,
                                      final ClassLoader classLoader )
    {
        boolean classpathImplementation = false;
        Implementation implementation =
            cpModule.getImplementations() == null ? null
            : cpModule.getImplementations().getImplementation( specification.getIdentifier() );

        if ( implementation == null )
        {
            String name = null;

            try
            {
                final Class<?> classpathImpl = Class.forName( specification.getClazz(), true, classLoader );

                if ( java.lang.reflect.Modifier.isPublic( classpathImpl.getModifiers() ) )
                {
                    if ( !java.lang.reflect.Modifier.isAbstract( classpathImpl.getModifiers() ) )
                    {
                        try
                        {
                            classpathImpl.getConstructor( NO_CLASSES );
                            name = "init";
                            classpathImplementation = true;
                        }
                        catch ( final NoSuchMethodException e )
                        {
                            classpathImplementation = false;
                        }
                    }

                    if ( !classpathImplementation )
                    {
                        final char[] c = classpathImpl.getName().substring(
                            classpathImpl.getPackage().getName().length() + 1 ).toCharArray();

                        name = String.valueOf( c );
                        c[0] = Character.toUpperCase( c[0] );

                        if ( this.checkFactoryMethod( classpathImpl, classpathImpl, "getDefault" ) )
                        {
                            name = "default";
                            classpathImplementation = true;
                        }
                        else if ( this.checkFactoryMethod( classpathImpl, classpathImpl, "getInstance" ) )
                        {
                            name = "instance";
                            classpathImplementation = true;
                        }
                        else if ( this.checkFactoryMethod( classpathImpl, classpathImpl, "get" + String.valueOf( c ) ) )
                        {
                            classpathImplementation = true;
                        }

                    }

                    if ( classpathImplementation )
                    {
                        String vendor = null;
                        String version = null;
                        if ( classpathImpl.getPackage() != null )
                        {
                            vendor = classpathImpl.getPackage().getImplementationVendor();
                            version = classpathImpl.getPackage().getImplementationVersion();
                        }

                        implementation = new Implementation();
                        implementation.setVendor( vendor );
                        implementation.setFinal( true );
                        implementation.setName( name );
                        implementation.setIdentifier( specification.getIdentifier() );
                        implementation.setClazz( classpathImpl.getName() );
                        implementation.setVersion( version );

                        final Specifications implemented = new Specifications();
                        final SpecificationReference ref = new SpecificationReference();
                        ref.setIdentifier( specification.getIdentifier() );
                        ref.setVersion( specification.getVersion() );
                        implemented.getReference().add( ref );
                        implementation.setSpecifications( implemented );

                        if ( cpModule.getImplementations() == null )
                        {
                            cpModule.setImplementations( new Implementations() );
                        }

                        cpModule.getImplementations().getImplementation().add( implementation );
                    }
                }
            }
            catch ( final ClassNotFoundException e )
            {
                classpathImplementation = false;
            }
        }

        return classpathImplementation;
    }

    private boolean checkFactoryMethod( final Class<?> clazz, final Class<?> type, final String methodName )
    {
        boolean factoryMethod = false;

        try
        {
            final java.lang.reflect.Method m = clazz.getMethod( methodName, (Class[]) null );
            factoryMethod = java.lang.reflect.Modifier.isStatic( m.getModifiers() )
                            && type.isAssignableFrom( m.getReturnType() );

        }
        catch ( final NoSuchMethodException e )
        {
            factoryMethod = false;
        }

        return factoryMethod;
    }

    private static String getMessage( final String key, final Object... args )
    {
        return java.text.MessageFormat.format( java.util.ResourceBundle.getBundle(
            Modules.class.getName().replace( '.', '/' ), java.util.Locale.getDefault() ).
            getString( key ), args );

    }]]>
      </ci:code>
    </jaxb:bindings>
  </jaxb:bindings>
</jaxb:bindings>
