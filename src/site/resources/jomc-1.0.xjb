<?xml version="1.0" encoding="UTF-8"?>
<!--

  Copyright (c) 2009 The JOMC Project
  Copyright (c) 2005 Christian Schulte <schulte2005@users.sourceforge.net>
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.

  THIS SOFTWARE IS PROVIDED BY THE JOMC PROJECT AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE JOMC PROJECT OR
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  $Id$

-->
<jaxb:bindings xmlns:xjc="http://java.sun.com/xml/ns/jaxb/xjc"
               xmlns:jaxb="http://java.sun.com/xml/ns/jaxb"
               xmlns:xs="http://www.w3.org/2001/XMLSchema"
               xmlns:jomc="http://jomc.org/model"
               xmlns:ci="http://jaxb.dev.java.net/plugin/code-injector"
               jaxb:version="2.0">

  <jaxb:bindings schemaLocation="jomc-1.0.xsd">
    <jaxb:bindings node="xs:complexType[@name='Texts']">
      <ci:code><![CDATA[
    /**
     * Gets a text for a given language.
     *
     * @param language The language of the text to return.
     *
     * @return The text with language {@code language} or the default text, if
     * no text matching {@code language} is found.
     *
     * @throws NullPointerException if {@code language} is {@code null}.
     */
    public Text getText( final String language )
    {
        if ( language == null )
        {
            throw new NullPointerException( "language" );
        }

        Text defaultText = null;

        for ( Text t : this.getText() )
        {
            if ( t.getLanguage().equals( this.getDefaultLanguage() ) )
            {
                defaultText = t;
            }
            if ( t.getLanguage().equals( language ) )
            {
                return t;
            }
        }

        return defaultText;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Specifications']">
      <ci:code><![CDATA[
    /**
     * Gets a specification for a given identifier from the list of
     * specifications.
     *
     * @param specification The identifier of the specification to return.
     *
     * @return The specification identified by {@code specification} from the
     * list or {@code null}, if no specification matching {@code specification}
     * is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     */
    public Specification getSpecification( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( Specification s : this.getSpecification() )
        {
            if ( specification.equals( s.getIdentifier() ) )
            {
                return s;
            }
        }

        return null;
    }

    /**
     * Gets a specification reference for a given identifier from the list of
     * references.
     *
     * @param specification The identifier of the reference to return.
     *
     * @return The specification reference identified by {@code specification}
     * from the list or {@code null}, if no specification reference matching
     * {@code specification} is found.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     */
    public SpecificationReference getReference( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( SpecificationReference r : this.getReference() )
        {
            if ( specification.equals( r.getIdentifier() ) )
            {
                return r;
            }
        }

        return null;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Implementations']">
      <ci:code><![CDATA[
    /**
     * Gets an implementation for a given identifier from the list.
     *
     * @param implementation The identifier of the implementation to return.
     *
     * @return The implementation identified by {@code implementation} from the
     * list or {@code null}, if no implementation matching
     * {@code implementation} is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     */
    public Implementation getImplementation( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( Implementation i : this.getImplementation() )
        {
            if ( implementation.equals( i.getIdentifier() ) )
            {
                return i;
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given clazz from the list.
     *
     * @param implementation The class of the implementation to return.
     *
     * @return The implementation identified by {@code implementation} from the
     * list or {@code null}, if no implementation matching
     * {@code implementation} is found.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     */
    public Implementation getImplementation( final Class implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( Implementation i : this.getImplementation() )
        {
            if ( implementation.getName().equals( i.getIdentifier() ) &&
                 i.getIdentifier().equals( i.getClazz() ) )
            {
                return i;
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given name from the list.
     *
     * @param name The name of the implementation to return.
     *
     * @return The implementation named {@code name} from the list or
     * {@code null}, if no implementation matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     */
    public Implementation getImplementationByName( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( Implementation i : this.getImplementation() )
        {
            if ( name.equals( i.getName() ) )
            {
                return i;
            }
        }

        return null;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Dependencies']">
      <ci:code><![CDATA[
    /**
     * Gets a dependency for a given name from the list.
     *
     * @param name The name of the dependency to return.
     *
     * @return The dependency with name {@code name} from the list or
     * {@code null}, if no dependency matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     */
    public Dependency getDependency( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "identifier" );
        }

        for ( Dependency d : this.getDependency() )
        {
            if ( name.equals( d.getName() ) )
            {
                return d;
            }
        }

        return null;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Properties']">
      <ci:code><![CDATA[
    /**
     * Gets a property for a given name from the list.
     *
     * @param name The name of the property to return.
     *
     * @return The property with name {@code name} from the list or
     * {@code null}, if no property matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     */
    public Property getProperty( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( Property p : this.getProperty() )
        {
            if ( name.equals( p.getName() ) )
            {
                return p;
            }
        }

        return null;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Property']">
      <ci:code><![CDATA[
    /**
     * Gets the java value of the property.
     *
     * @return The java value of the property.
     */
    public Object getPropertyValue()
    {
        final Class objectType;
        Object propertyValue = null;

        if ( this.getType() == PropertyType.BOOLEAN ||
             this.getType() == PropertyType.JAVA_LANG_BOOLEAN )
        {
            objectType = Boolean.class;
        }
        else if ( this.getType() == PropertyType.BYTE ||
                  this.getType() == PropertyType.JAVA_LANG_BYTE )
        {
            objectType = Byte.class;
        }
        else if ( this.getType() == PropertyType.CHAR ||
                  this.getType() == PropertyType.JAVA_LANG_CHARACTER )
        {
            objectType = Character.class;
        }
        else if ( this.getType() == PropertyType.DOUBLE ||
                  this.getType() == PropertyType.JAVA_LANG_DOUBLE )
        {
            objectType = Double.class;
        }
        else if ( this.getType() == PropertyType.FLOAT ||
                  this.getType() == PropertyType.JAVA_LANG_FLOAT )
        {
            objectType = Float.class;
        }
        else if ( this.getType() == PropertyType.INT ||
                  this.getType() == PropertyType.JAVA_LANG_INTEGER )
        {
            objectType = Integer.class;
        }
        else if ( this.getType() == PropertyType.LONG ||
                  this.getType() == PropertyType.JAVA_LANG_LONG )
        {
            objectType = Long.class;
        }
        else if ( this.getType() == PropertyType.SHORT ||
                  this.getType() == PropertyType.JAVA_LANG_SHORT )
        {
            objectType = Short.class;
        }
        else if ( this.getType() == PropertyType.JAVA_LANG_STRING )
        {
            objectType = String.class;
        }
        else if ( this.getType() == PropertyType.JAVA_LANG_OBJECT )
        {
            objectType = Object.class;
            propertyValue = this.getAny();
            if ( propertyValue != null &&
                 propertyValue instanceof javax.xml.bind.JAXBElement )
            {
                propertyValue =
                    ( (javax.xml.bind.JAXBElement) propertyValue ).getValue();

            }
        }
        else
        {
            throw new RuntimeException( this.getType().value() );
        }

        if ( objectType != Object.class && this.getValue() != null )
        {
            try
            {
                final java.lang.reflect.Constructor ctor;
                final Object arg;

                if ( objectType == Character.class )
                {
                    ctor = objectType.getConstructor( new Class[]
                        {
                            char.class
                        } );

                    arg = new Character( this.getValue().charAt( 0 ) );
                }
                else
                {
                    ctor = objectType.getConstructor( new Class[]
                        {
                            String.class
                        } );

                    arg = this.getValue();
                }

                propertyValue = ctor.newInstance( new Object[]
                    {
                        arg
                    } );

            }
            catch ( InstantiationException e )
            {
                throw new RuntimeException( e );
            }
            catch ( IllegalAccessException e )
            {
                throw new RuntimeException( e );
            }
            catch ( java.lang.reflect.InvocationTargetException e )
            {
                throw new RuntimeException( e );
            }
            catch ( NoSuchMethodException e )
            {
                throw new RuntimeException( e );
            }
        }

        return propertyValue;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Messages']">
      <ci:code><![CDATA[
    /**
     * Gets a message for a given name from the list.
     *
     * @param name The name of the message to return.
     *
     * @return The message with name {@code name} from the list or {@code null},
     * if no message matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     */
    public Message getMessage( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( Message m : this.getMessage() )
        {
            if ( name.equals( m.getName() ) )
            {
                return m;
            }
        }

        return null;
    }

    /**
     * Gets a message reference for a given name from the list of references.
     *
     * @param name The name of the message reference to return.
     *
     * @return The message reference with name {@code name} from the list of
     * references or {@code null}, if no message reference matching {@code name}
     * is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     */
    public MessageReference getReference( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( MessageReference r : this.getReference() )
        {
            if ( name.equals( r.getName() ) )
            {
                return r;
            }
        }

        return null;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Arguments']">
      <ci:code><![CDATA[
    /**
     * Gets an argument for a given name from the list.
     *
     * @param name The name of the argument to return.
     *
     * @return The argument with name {@code name} from the list or
     * {@code null}, if no argument matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     */
    public Argument getArgument( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( Argument a : this.getArgument() )
        {
            if ( name.equals( a.getName() ) )
            {
                return a;
            }
        }

        return null;
    }

    /**
     * Gets an argument for a given index from the list of arguments.
     *
     * @param index The index of the argument to return.
     *
     * @return The argument at {@code index} from the list.
     *
     * @throws IndexOutOfBoundsException if {@code index} is negative
     * or greater or equal to the size of the list.
     */
    public Argument getArgument( final int index )
    {
        if ( index < 0 || index >= this.getArgument().size() )
        {
            throw new IndexOutOfBoundsException( Integer.toString( index ) );
        }

        for ( Argument a : this.getArgument() )
        {
            if ( index == a.getIndex() )
            {
                return a;
            }
        }

        return null;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Instances']">
      <ci:code><![CDATA[
    /**
     * Gets an instance for a given identifier from the list.
     *
     * @param identifier The identifier of the instance to return.
     *
     * @return The instance identified by {@code identifier} from the list or
     * {@code null}, if no instance matching {@code identifier} is found.
     *
     * @throws NullPointerException if {@code identifier} is {@code null}.
     */
    public Instance getInstance( final String identifier )
    {
        if ( identifier == null )
        {
            throw new NullPointerException( "identifier" );
        }

        for ( Instance i : this.getInstance() )
        {
            if ( i.getIdentifier().equals( identifier ) )
            {
                return i;
            }
        }

        return null;
    }
]]></ci:code>
    </jaxb:bindings>
    <jaxb:bindings node="xs:complexType[@name='Modules']">
      <ci:code><![CDATA[
    /**
     * Gets a module for a given name from the list.
     *
     * @param name The name of the module to return.
     *
     * @return The module with name {@code name} from the list or {@code null},
     * if no module matching {@code name} is found.
     *
     * @throws NullPointerException if {@code name} is {@code null}.
     */
    public Module getModule( final String name )
    {
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getName().equals( name ) )
            {
                return m;
            }
        }

        return null;
    }

    /**
     * Gets the specifications of an instance.
     *
     * @return The specifications of an instance or {@code null}, if no specifications could be resolved.
     */
    public Specifications getSpecifications()
    {
        final Specifications specifications = new Specifications();
        for ( Module m : this.getModule() )
        {
            if ( m.getSpecifications() != null )
            {
                specifications.getSpecification().addAll( m.getSpecifications().getSpecification() );
            }
        }

        return specifications.getSpecification().isEmpty() ? null : specifications;
    }

    /**
     * Gets the implementations of an instance.
     *
     * @return The implementations of an instance or {@code null}, if no implementations could be resolved.
     */
    public Implementations getImplementations()
    {
        final Implementations implementations = new Implementations();
        for ( Module m : this.getModule() )
        {
            if ( m.getImplementations() != null )
            {
                implementations.getImplementation().addAll( m.getImplementations().getImplementation() );
            }
        }

        return implementations.getImplementation().isEmpty() ? null : implementations;
    }

    /**
     * Gets the module declaring a given specification.
     *
     * @param specification The identifier of the specification whose module to return.
     *
     * @return The module declaring {@code specification} or {@code null}, if no module could be resolved.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     */
    public Module getModuleOfSpecification( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getSpecifications() != null )
            {
                for ( Specification s : m.getSpecifications().getSpecification() )
                {
                    if ( specification.equals( s.getIdentifier() ) )
                    {
                        return m;
                    }
                }
            }
        }

        return null;
    }

    /**
     * Gets the module declaring a given implementation.
     *
     * @param implementation The identifier of the implementation whose module to return.
     *
     * @return The module declaring {@code implementation} or {@code null}, if no module could be resolved.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     */
    public Module getModuleOfImplementation( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getImplementations() != null )
            {
                for ( Implementation i : m.getImplementations().getImplementation() )
                {
                    if ( implementation.equals( i.getIdentifier() ) )
                    {
                        return m;
                    }
                }
            }
        }

        return null;
    }

    /**
     * Gets an implementation including referenced model objects as a module.
     *
     * @param implementation The identifier of the implementation to resolve.
     *
     * @return A module declaring {@code implementation} in addition to all referenced model objects or {@code null} if
     * no implementation matching {@code implementation} is available.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     */
    public Module getImplementationModule( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        Module m = null;
        final Implementation i = this.getImplementation( implementation );

        if ( i != null )
        {
            m = new Module();
            m.setSpecifications( new Specifications() );
            m.setImplementations( new Implementations() );
            m.setName( i.getIdentifier() );
            m.setVersion( i.getVersion() );
            m.setVendor( i.getVendor() );

            this.collectImplementationModule( m, implementation );

            final Dependencies dependencies = this.getDependencies( implementation );
            final List<SpecificationReference> references = this.getSpecifications( implementation );

            if ( dependencies != null )
            {
                for ( Dependency d : dependencies.getDependency() )
                {
                    if ( m.getSpecifications().getSpecification( d.getIdentifier() ) == null )
                    {
                        final Specification s = this.getSpecification( d.getIdentifier() );

                        if ( s != null )
                        {
                            m.getSpecifications().getSpecification().add( s );
                        }
                    }
                }
            }

            if ( references != null )
            {
                for ( SpecificationReference ref : references )
                {
                    if ( m.getSpecifications().getSpecification( ref.getIdentifier() ) == null )
                    {
                        final Specification s = this.getSpecification( ref.getIdentifier() );
                        if ( s != null )
                        {
                            m.getSpecifications().getSpecification().add( s );
                        }
                    }
                }
            }
        }

        return m;
    }

    private void collectImplementationModule( final Module module, final String parent )
    {
        final Implementation i = this.getImplementation( parent );
        if ( i != null )
        {
            if ( i.getParent() != null )
            {
                this.collectImplementationModule( module, i.getParent() );
            }

            if ( module.getImplementations().getImplementation( i.getIdentifier() ) == null )
            {
                final Module m = this.getModuleOfImplementation( i.getIdentifier() );
                module.getImplementations().getImplementation().add( i );

                if ( i.getMessages() != null )
                {
                    for ( java.util.Iterator<MessageReference> ref = i.getMessages().getReference().iterator();
                          ref.hasNext(); )
                    {
                        i.getMessages().getMessage().add( m.getMessages().getMessage( ref.next().getName() ) );
                        ref.remove();
                    }
                }
            }
        }
    }

    /**
     * Gets a specification for a given identifier.
     *
     * @param specification The identifier of the specification to return.
     *
     * @return The specification identified by {@code specification} or {@code null}, if no specification matching
     * {@code specification} is available.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     */
    public Specification getSpecification( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getSpecifications() != null )
            {
                final Specification s = m.getSpecifications().getSpecification( specification );
                if ( s != null )
                {
                    return s;
                }
            }
        }

        return null;
    }

    /**
     * Gets references to all specifications an implementation implements.
     *
     * @param implementation The identifier of the implementation to get all implemented specifications of.
     *
     * @return List of references to all specifications implemented by {@code implementation} or {@code null}, if no
     * implementation matching {@code implementation} is available.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     */
    public List<SpecificationReference> getSpecifications( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        Specifications specs = new Specifications();
        this.collectSpecifications( implementation, specs );
        return specs.getReference().isEmpty() ? null : specs.getReference();
    }

    private void collectSpecifications( final String implementation, final Specifications specifications )
    {
        final Implementation i = this.getImplementation( implementation );

        if ( i != null )
        {
            if ( i.getParent() != null )
            {
                this.collectSpecifications( i.getParent(), specifications );
            }

            if ( i.getSpecifications() != null )
            {
                for ( SpecificationReference ref : i.getSpecifications().getReference() )
                {
                    if ( specifications.getReference( ref.getIdentifier() ) == null )
                    {
                        specifications.getReference().add( ref );
                    }
                }
            }
        }
    }

    /**
     * Gets an implementation for a given identifier.
     *
     * @param implementation The identifier of the implementation to return.
     *
     * @return The implementation identified by {@code implementation} or {@code null}, if no implementation matching
     * {@code implementation} is available.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     */
    public Implementation getImplementation( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getImplementations() != null )
            {
                final Implementation i = m.getImplementations().getImplementation( implementation );
                if ( i != null )
                {
                    return i;
                }
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given class.
     *
     * @param implementation The class of the implementation to return.
     *
     * @return The implementation identified by {@code implementation} or {@code null}, if no implementation matching
     * {@code implementation} is available.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     */
    public Implementation getImplementation( final Class implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        for ( Module m : this.getModule() )
        {
            if ( m.getImplementations() != null )
            {
                final Implementation i = m.getImplementations().getImplementation( implementation );
                if ( i != null )
                {
                    return i;
                }
            }
        }

        return null;
    }

    /**
     * Gets an implementation for a given name implementing a given specification.
     *
     * @param specification The identifier of the specification to return an implementation of.
     * @param name The name of the implementation to return.
     *
     * @return The implementation with name {@code name} implementing the specification identified by
     * {@code specification} or {@code null}, if no such implementation is found.
     *
     * @throws NullPointerException if {@code specification} or {@code name} is {@code null}.
     */
    public Implementation getImplementation( final String specification, final String name )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        final Implementations implementations = this.getImplementations( specification );
        if ( implementations != null )
        {
            return implementations.getImplementationByName( name );
        }

        return null;
    }

    /**
     * Gets all dependencies of an implementation.
     *
     * @param implementation The identifier of the implementation to get all dependencies of.
     *
     * @return List of all dependencies of {@code implementation} or {@code null}, if nothing could be resolved.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     */
    public Dependencies getDependencies( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Dependencies dependencies = new Dependencies();
        this.collectDependencies( implementation, dependencies );
        java.util.Collections.sort( dependencies.getDependency(), new java.util.Comparator<Dependency>()
        {

            public int compare( final Dependency o1, final Dependency o2 )
            {
                return o1.getName().compareTo( o2.getName() );
            }

        } );

        return dependencies.getDependency().size() > 0 ? dependencies : null;
    }

    private void collectDependencies( final String implementation, final Dependencies dependencies )
    {
        final Implementation i = this.getImplementation( implementation );

        if ( i != null )
        {
            if ( i.getDependencies() != null )
            {
                for ( Dependency d : i.getDependencies().getDependency() )
                {
                    if ( dependencies.getDependency( d.getName() ) == null )
                    {
                        dependencies.getDependency().add( d );
                    }
                }
            }

            if ( i.getParent() != null )
            {
                this.collectDependencies( i.getParent(), dependencies );
            }
        }
    }

    /**
     * Gets all properties of an implementation.
     *
     * @param implementation The identifier of the implementation to get all properties of.
     *
     * @return List of all properties of {@code implementation} or {@code null}, if nothing could be resolved.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     */
    public Properties getProperties( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Properties properties = new Properties();
        this.collectProperties( implementation, properties );
        final Properties specified = this.getSpecifiedProperties( implementation );

        if ( specified != null )
        {
            for ( Property p : specified.getProperty() )
            {
                if ( properties.getProperty( p.getName() ) == null )
                {
                    properties.getProperty().add( p );
                }
            }
        }

        java.util.Collections.sort( properties.getProperty(), new java.util.Comparator<Property>()
        {

            public int compare( final Property o1, final Property o2 )
            {
                return o1.getName().compareTo( o2.getName() );
            }

        } );

        return properties.getProperty().size() > 0 ? properties : null;
    }

    private void collectProperties( final String implementation, final Properties properties )
    {
        final Implementation i = this.getImplementation( implementation );

        if ( i != null )
        {
            if ( i.getProperties() != null )
            {
                for ( Property p : i.getProperties().getProperty() )
                {
                    if ( properties.getProperty( p.getName() ) == null )
                    {
                        properties.getProperty().add( p );
                    }
                }
            }

            if ( i.getParent() != null )
            {
                this.collectProperties( i.getParent(), properties );
            }
        }
    }

    /**
     * Gets all properties specified for an implementation.
     *
     * @param implementation The identifier of the implementation to return specified properties of.
     *
     * @return List of all properties specified for {@code implementation} or {@code null}, if nothing could be
     * resolved.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     */
    public Properties getSpecifiedProperties( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Properties properties = new Properties();
        final List<SpecificationReference> references = this.getSpecifications( implementation );

        if ( references != null )
        {
            for ( SpecificationReference r : references )
            {
                final Specification s = this.getSpecification( r.getIdentifier() );

                if ( s != null && s.getProperties() != null )
                {
                    properties.getProperty().addAll( s.getProperties().getProperty() );
                }
            }
        }

        java.util.Collections.sort( properties.getProperty(), new java.util.Comparator<Property>()
        {

            public int compare( final Property o1, final Property o2 )
            {
                return o1.getName().compareTo( o2.getName() );
            }

        } );

        return properties.getProperty().size() > 0 ? properties : null;
    }

    /**
     * Gets all messages of an implementation.
     *
     * @param implementation The identifier of the implementation to get all messages of.
     *
     * @return List of messages of {@code implementation} or {@code null}, if nothing could be resolved.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     */
    public Messages getMessages( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Messages msgs = new Messages();
        this.collectMessages( implementation, msgs );

        java.util.Collections.sort( msgs.getMessage(), new java.util.Comparator<Message>()
        {

            public int compare( final Message o1, final Message o2 )
            {
                return o1.getName().compareTo( o2.getName() );
            }

        } );

        return msgs.getMessage().size() > 0 ? msgs : null;
    }

    private void collectMessages( final String implementation, final Messages messages )
    {
        final Implementation i = this.getImplementation( implementation );

        if ( i != null )
        {
            if ( i.getMessages() != null )
            {
                for ( Message msg : i.getMessages().getMessage() )
                {
                    if ( messages.getMessage( msg.getName() ) == null )
                    {
                        messages.getMessage().add( msg );
                    }
                }
                if ( !i.getMessages().getReference().isEmpty() )
                {
                    final Module m = this.getModuleOfImplementation( i.getIdentifier() );

                    if ( m != null )
                    {
                        for ( MessageReference ref : i.getMessages().getReference() )
                        {
                            if ( messages.getMessage( ref.getName() ) == null )
                            {
                                messages.getMessage().add( m.getMessages().getMessage( ref.getName() ) );
                            }
                        }
                    }
                }
            }

            if ( i.getParent() != null )
            {
                this.collectMessages( i.getParent(), messages );
            }
        }
    }

    /**
     * Gets all implementations implementing a given specification.
     *
     * @param specification The identifier of the specification to return implementations of.
     *
     * @return All implementations implementing the specification identified by {@code specification} or {@code null},
     * if no implementation implementing {@code specification} is available.
     *
     * @throws NullPointerException if {@code specification} is {@code null}.
     */
    public Implementations getImplementations( final String specification )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }

        final Implementations implementations = new Implementations();
        for ( Module m : this.getModule() )
        {
            if ( m.getImplementations() != null )
            {
                for ( Implementation i : m.getImplementations().getImplementation() )
                {
                    final List<SpecificationReference> references = this.getSpecifications( i.getIdentifier() );

                    if ( references != null )
                    {
                        for ( SpecificationReference ref : references )
                        {
                            if ( specification.equals( ref.getIdentifier() ) )
                            {
                                implementations.getImplementation().add( i );
                            }
                        }
                    }
                }
            }
        }

        return implementations.getImplementation().size() > 0 ? implementations : null;
    }

    /**
     * Gets all implementations implementing a given dependency.
     *
     * @param implementation The identifier of the implementation declaring {@code dependency}.
     * @param dependency The name of the dependency to return implementations of.
     *
     * @return All implementations of {@code dependency} or {@code null}, if no implementation is available.
     *
     * @throws NullPointerException if {@code implementation} or {@code dependency} is {@code null}.
     */
    public Implementations getImplementations( final String implementation, final String dependency )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }
        if ( dependency == null )
        {
            throw new NullPointerException( "dependency" );
        }

        final Implementations implementations = new Implementations();
        final Implementation i = this.getImplementation( implementation );

        if ( i != null )
        {
            final Dependencies dependencies = this.getDependencies( implementation );

            if ( dependencies != null )
            {
                final Dependency d = dependencies.getDependency( dependency );

                if ( d != null )
                {
                    final Implementations available = this.getImplementations( d.getIdentifier() );

                    if ( available != null )
                    {
                        implementations.getImplementation().addAll( available.getImplementation() );
                    }
                }
            }
        }

        return implementations.getImplementation().size() > 0 ? implementations : null;
    }

    /**
     * Gets an instance of an implementation.
     *
     * @param implementation The identifier of the implementation to return an instance of.
     *
     * @return An instance of the implementation identified by {@code implementation}  or {@code null}, if no instance
     * is available.
     *
     * @throws NullPointerException if {@code implementation} is {@code null}.
     */
    public Instance getInstance( final String implementation )
    {
        if ( implementation == null )
        {
            throw new NullPointerException( "implementation" );
        }

        final Implementation i = this.getImplementation( implementation );
        Instance instance = null;

        if ( i != null && i.getClazz() != null )
        {
            instance = new Instance();
            instance.setIdentifier( i.getIdentifier() );
            instance.setClazz( i.getClazz() );
            instance.setScope( Scope.MULTITON );
            instance.setStateless( i.isStateless() );
            instance.setSpecifications( new Specifications() );
            instance.setDependencies( this.getDependencies( i.getIdentifier() ) );
            instance.setProperties( this.getProperties( i.getIdentifier() ) );
            instance.setMessages( this.getMessages( i.getIdentifier() ) );


            final List<SpecificationReference> specifications = this.getSpecifications( i.getIdentifier() );
            if ( specifications != null )
            {
                for ( SpecificationReference ref : specifications )
                {
                    final Specification specification = this.getSpecification( ref.getIdentifier() );
                    if ( specification != null )
                    {
                        instance.getSpecifications().getSpecification().add( specification );
                    }
                }
            }
        }

        return instance;
    }

    /**
     * Gets an instance of an implementation of a given specification.
     *
     * @param specification The identifier of the specification to return an instance of.
     * @param name The name of the implementation implementing {@code specification} to return an instance of.
     *
     * @return An instance of the implementation with name {@code name} implementing the specification identified by
     * {@code specification} or {@code null}, if no instance is available.
     *
     * @throws NullPointerException if {@code specification} or {@code name} is {@code null}.
     */
    public Instance getInstance( final String specification, final String name )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }

        final Specification s = this.getSpecification( specification );

        Instance instance = null;

        if ( s != null )
        {
            final Implementation i = this.getImplementation( specification, name );

            if ( i != null )
            {
                instance = this.getInstance( i.getIdentifier() );

                if ( instance != null )
                {
                    instance.setScope( s.getScope() );
                }
            }
        }

        return instance;
    }

    /**
     * Gets an instance of an implementation of a given specification as required by a given dependency.
     *
     * @param specification The identifier of the specification to return an implementation instance of.
     * @param name The name of the implementation to return an instance of.
     * @param dependency The dependency requiring the instance.
     *
     * @return An instance of the implementation with name {@code name} implementing the specification identified by
     * {@code specification} as required by {@code dependency} or {@code null}, if no such instance is available.
     *
     * @throws NullPointerException if {@code specification}, {@code name} or {@code dependency} is {@code null}.
     */
    public Instance getInstance( final String specification, final String name, final Dependency dependency )
    {
        if ( specification == null )
        {
            throw new NullPointerException( "specification" );
        }
        if ( name == null )
        {
            throw new NullPointerException( "name" );
        }
        if ( dependency == null )
        {
            throw new NullPointerException( "dependency" );
        }

        final Instance instance = this.getInstance( specification, name );

        if ( instance != null )
        {
            final Properties properties = new Properties();

            if ( dependency.getProperties() != null )
            {
                properties.getProperty().addAll( dependency.getProperties().getProperty() );
            }

            if ( instance.getProperties() != null )
            {
                for ( Property p : instance.getProperties().getProperty() )
                {
                    if ( properties.getProperty( p.getName() ) == null )
                    {
                        properties.getProperty().add( p );
                    }
                }
            }

            instance.setProperties( properties.getProperty().isEmpty() ? null : properties );
        }

        return instance;
    }

]]></ci:code>
    </jaxb:bindings>
  </jaxb:bindings>
</jaxb:bindings>
